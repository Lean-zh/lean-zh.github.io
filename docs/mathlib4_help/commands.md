# Commands

Mathlib ç‰ˆæœ¬ï¼š`e4cf8333e0be712392567e370eead57e05d636a7`

## \#adaptation_note
å®šä¹‰äºï¼š`adaptationNoteCmd`

é€‚é…æ³¨é‡Šï¼ˆadaptation notesï¼‰æ˜¯ç”¨äºæŒ‡ç¤ºæŸæ®µä»£ç å·²å›  Lean æ ¸å¿ƒå˜åŠ¨è€Œä¿®æ”¹çš„æ³¨é‡Šã€‚è¿™ç±»æ³¨é‡Šé€šå¸¸éœ€è¦æœªæ¥é‡‡å–è¿›ä¸€æ­¥çš„ç»´æŠ¤æªæ–½ã€‚

## \#aesop_rules
å®šä¹‰äºï¼š`Aesop.Frontend.Parser.showRules`


## \#aesop_stats
å®šä¹‰äºï¼š`Aesop.Frontend.Parser.showStats`


## \#allow_unused_tactic
å®šä¹‰äºï¼š`Mathlib.Linter.UnusedTactic.Â«command#allow_unused_tactic!___Â»`

`#allow_unused_tactic` æ¥å—ä»¥ç©ºæ ¼åˆ†éš”çš„æ ‡è¯†ç¬¦åˆ—è¡¨ã€‚è¿™äº›æ ‡è¯†ç¬¦å°†è¢«æœªä½¿ç”¨ç­–ç•¥æ£€æŸ¥å™¨ï¼ˆunused tactic linterï¼‰å…è®¸ï¼šå³ä½¿è¿™äº›ç­–ç•¥ä¸ä¿®æ”¹ç›®æ ‡ï¼Œä¹Ÿä¸ä¼šè§¦å‘è­¦å‘Šã€‚

æ³¨æ„ï¼šä¸ºæ­¤ï¼Œè¿™äº›æ ‡è¯†ç¬¦åº”ä¸ºå„ç­–ç•¥çš„ `SyntaxNodeKind`ã€‚

ä¾‹å¦‚ï¼Œå…è®¸ `done` å’Œ `skip` ç­–ç•¥å¯ä½¿ç”¨ï¼š
```lean
#allow_unused_tactic Lean.Parser.Tactic.done Lean.Parser.Tactic.skip
```

æ­¤å˜æ›´ä»…ä½œç”¨äºå½“å‰æ–‡ä»¶ã€‚è‹¥éœ€**æŒä¹…æ€§**å˜æ›´ï¼Œè¯·ä½¿ç”¨ `!` æ ‡å¿—ï¼šå‘½ä»¤ `#allow_unused_tactic! ids` å°†ä½¿æ£€æŸ¥å™¨åœ¨å¯¼å…¥è¯¥æ–‡ä»¶çš„æ–‡ä»¶ä¸­ç»§ç»­å¿½ç•¥è¿™äº›ç­–ç•¥ã€‚

å‘½ä»¤ `#show_kind tac` å¯è¾…åŠ©æŸ¥æ‰¾ `SyntaxNodeKind`ã€‚

## \#check
å®šä¹‰äºï¼š`Lean.Parser.Command.check`


## \#check_assertions
å®šä¹‰äºï¼š`Mathlib.AssertNotExist.Â«command#check_assertions!Â»`

`#check_assertions` æ£€ç´¢æ‰€æœ‰å£°æ˜åŠå£°æ˜ä¸å­˜åœ¨ï¼ˆåŒ…æ‹¬é—´æ¥å¯¼å…¥æ–‡ä»¶ä¸­çš„ï¼‰çš„å¯¼å…¥é¡¹ï¼Œå¹¶æŠ¥å‘Šå…¶å½“å‰çŠ¶æ€ï¼š
* âœ“ è¡¨ç¤ºå£°æ˜æˆ–å¯¼å…¥å­˜åœ¨ï¼Œ
* Ã— è¡¨ç¤ºå£°æ˜æˆ–å¯¼å…¥ä¸å­˜åœ¨ã€‚

è¿™æ„å‘³ç€é¢„æœŸæ‰€æœ‰æ£€æŸ¥åœ¨ `#check_assertions` ä½¿ç”¨æ—¶ï¼ˆé€šå¸¸åœ¨æ„å»ºå®Œæ•´ `Mathlib` åï¼‰å‡**æˆåŠŸ**ã€‚

è‹¥æ‰€æœ‰å£°æ˜åŠå¯¼å…¥åœ¨ `#check_assertions` ä½¿ç”¨æ—¶å‡å­˜åœ¨ï¼Œåˆ™å‘½ä»¤è®°å½•ä¿¡æ¯ã€‚å¦åˆ™ï¼Œå‘å‡ºè­¦å‘Šã€‚

å˜ä½“ `#check_assertions!` ä»…æ‰“å°ç¯å¢ƒä¸­ä¸å­˜åœ¨çš„å£°æ˜/å¯¼å…¥é¡¹ã€‚ç‰¹åˆ«åœ°ï¼Œè‹¥ä¸€åˆ‡å·²å¯¼å…¥ï¼Œåˆ™é™é»˜ï¼Œä¾¿äºæµ‹è¯•ã€‚

## \#check_failure
å®šä¹‰äºï¼š`Lean.Parser.Command.check_failure`


## \#check_simp
å®šä¹‰äºï¼š`Lean.Parser.checkSimp`

`#check_simp t ~> r` æ£€æŸ¥ `simp` æ˜¯å¦å°† `t` è§„çº¦ä¸º `r`ã€‚

## \#check_simp
å®šä¹‰äºï¼š`Lean.Parser.checkSimpFailure`

`#check_simp t !~>` æ£€æŸ¥ `simp` æ˜¯å¦è§„çº¦ `t` å¤±è´¥ã€‚

## \#check_tactic
å®šä¹‰äºï¼š`Lean.Parser.checkTactic`

`#check_tactic t ~> r by commands` åœ¨ç›®æ ‡ä¸º `t` æ—¶è¿è¡Œç­–ç•¥åºåˆ— `commands`ï¼Œå¹¶éªŒè¯ç»“æœè¡¨è¾¾å¼æ˜¯å¦è§„çº¦ä¸º `r`ã€‚

## \#check_tactic_failure
å®šä¹‰äºï¼š`Lean.Parser.checkTacticFailure`

`#check_tactic_failure t by tac` åœ¨ç›®æ ‡ä¸º `t` æ—¶è¿è¡Œç­–ç•¥ `tac`ï¼Œå¹¶éªŒè¯å…¶æ˜¯å¦å¤±è´¥ã€‚

## \#conv
å®šä¹‰äºï¼š`Mathlib.Tactic.Conv.Â«command#conv_=>_Â»`

å‘½ä»¤ `#conv tac => e` å°†å¯¹ `e` è¿è¡Œè½¬æ¢ç­–ç•¥ `tac`ï¼Œå¹¶æ˜¾ç¤ºç»“æœè¡¨è¾¾å¼ï¼ˆèˆå¼ƒè¯æ˜ï¼‰ã€‚ä¾‹å¦‚ï¼Œ`#conv rw [true_and_iff] => True âˆ§ False` æ˜¾ç¤º `False`ã€‚å¦æœ‰å¤šä¸ªå¸¸ç”¨è½¬æ¢ç­–ç•¥çš„ç®€å†™å‘½ä»¤ï¼š

* `#whnf e` æ˜¯ `#conv whnf => e` çš„ç®€å†™
* `#simp e` æ˜¯ `#conv simp => e` çš„ç®€å†™
* `#norm_num e` æ˜¯ `#conv norm_num => e` çš„ç®€å†™
* `#push_neg e` æ˜¯ `#conv push_neg => e` çš„ç®€å†™

## \#count_heartbeats
å®šä¹‰äºï¼š`Mathlib.CountHeartbeats.Â«command#count_heartbeatsApproximatelyIn__Â»`

`#count_heartbeats in cmd` ç»Ÿè®¡å°é—­å‘½ä»¤ `cmd` ä½¿ç”¨çš„å¿ƒè·³æ¬¡æ•°ã€‚ä½¿ç”¨ `#count_heartbeats` ç»Ÿè®¡åç»­æ‰€æœ‰å£°æ˜çš„å¿ƒè·³æ¬¡æ•°ã€‚

æ­¤å‘½ä»¤æœ€é€‚ç”¨äºé€šè¿‡ `set_option maxHeartbeats` ä¸ºé•¿è¿è¡Œå£°æ˜è®¾ç½®å……è¶³ä½†åˆç†çš„é™åˆ¶ã€‚

è‹¥å¦‚æ­¤æ“ä½œï¼Œè¯·å‹¿å°†é™åˆ¶è®¾è‡³æœ€ä½ã€‚éšç€ `simp` é›†åŠåº“å…¶ä»–åŠŸèƒ½çš„æ¼”è¿›ï¼Œå…¶ä»–è´¡çŒ®è€…å¯èƒ½å‘ç°å…¶ï¼ˆå¯èƒ½æ— å…³çš„ï¼‰å˜æ›´å¯¼è‡´å£°æ˜è¶…å‡ºé™åˆ¶ã€‚`count_heartbearts in` å°†é€šè¿‡â€œTry this:â€è‡ªåŠ¨å»ºè®®ä½¿ç”¨æ»¡è¶³æ¡ä»¶çš„æœ€å° `2^k * 200000` å½¢å¼çš„ `set_option maxHeartbeats`ã€‚

æ³¨æ„ï¼Œé€šè¿‡ `IO.getNumHeartbeats` è®¿é—®çš„å†…éƒ¨å¿ƒè·³è®¡æ•°å™¨ç²’åº¦æ¯” `set_option maxHeartbeats` è®¾ç½®çš„é™åˆ¶ç²¾ç»† 1000 å€ã€‚å› æœ¬å‘½ä»¤é¢å‘ç”¨æˆ·ï¼Œæ•…é™¤ä»¥ 1000ã€‚

å¯é€‰å…³é”®å­— `approximately` å°†å¿ƒè·³æ¬¡æ•°å‘ä¸‹èˆå…¥è‡³æœ€æ¥è¿‘çš„åƒä½ã€‚æ­¤åŠŸèƒ½æœ‰åŠ©äºæå‡æµ‹è¯•å¯¹å¿ƒè·³æ¬¡æ•°å°å˜æ›´çš„ç¨³å®šæ€§ã€‚ä½¿ç”¨ `#count_heartbeats approximately in cmd` å¯ç”¨æ­¤åŠŸèƒ½ã€‚

## \#count_heartbeats
å®šä¹‰äºï¼š`Mathlib.Linter.CountHeartbeats.Â«command#count_heartbeatsApproximatelyÂ»`

â€œcountHeartbeatsâ€æ£€æŸ¥å™¨ç»Ÿè®¡æ¯ä¸ªå£°æ˜çš„å¿ƒè·³æ¬¡æ•°ã€‚

å…¶æ•ˆæœç±»ä¼¼äº `#count_heartbeats in xxx`ï¼Œä½†åº”ç”¨äºæ‰€æœ‰å£°æ˜ã€‚

æ³¨æ„ï¼Œæ£€æŸ¥å™¨ä»…ç»Ÿè®¡â€œé¡¶å±‚â€å£°æ˜çš„å¿ƒè·³æ¬¡æ•°ï¼šå…¶æŸ¥çœ‹ `set_option ... in` å†…éƒ¨ï¼Œä½†ä¸æŸ¥çœ‹å¦‚ `mutual` å—å†…éƒ¨ã€‚

ä¾¿æ·ç¬¦å· `#count_heartbeats` ä»…å°†æ£€æŸ¥å™¨é€‰é¡¹è®¾ä¸º trueã€‚

## \#count_heartbeats!
å®šä¹‰äºï¼š`Mathlib.CountHeartbeats.Â«command#count_heartbeats!_In__Â»`

`#count_heartbeats! in cmd` è¿è¡Œå‘½ä»¤ `10` æ¬¡ï¼ŒæŠ¥å‘Šå¿ƒè·³æ¬¡æ•°èŒƒå›´åŠæ ‡å‡†å·®ã€‚å‘½ä»¤ `#count_heartbeats! n in cmd` è¿è¡Œ `n` æ¬¡ã€‚

ç¤ºä¾‹ï¼š
```lean
#count_heartbeats! in
def f := 37
```
æ˜¾ç¤ºä¿¡æ¯ `Min: 7 Max: 8 StdDev: 14%`ã€‚

## \#discr_tree_key
å®šä¹‰äºï¼š`Lean.Parser.discrTreeKeyCmd`

`#discr_tree_key  t` æ‰“å°é¡¹ `t` çš„æ­§è§†æ ‘é”®ï¼ˆè‹¥ä¸ºå•ä¸ªæ ‡è¯†ç¬¦ï¼Œåˆ™ä¸ºè¯¥å¸¸é‡çš„ç±»å‹ï¼‰ã€‚ä½¿ç”¨é»˜è®¤é”®ç”Ÿæˆé…ç½®ã€‚

ä¾‹å¦‚ï¼š
```
#discr_tree_key (âˆ€ {a n : Nat}, bar a (OfNat.ofNat n))
-- bar _ (@OfNat.ofNat Nat _ _)

#discr_tree_simp_key Nat.add_assoc
-- @HAdd.hAdd Nat Nat Nat _ (@HAdd.hAdd Nat Nat Nat _ _ _) _
```

`#discr_tree_simp_key` ç±»ä¼¼ `#discr_tree_key`ï¼Œä½†å°†åº•å±‚ç±»å‹è§†ä¸º simp å¼•ç†ï¼Œå³è½¬æ¢ä¸ºç­‰å¼å¹¶ç”Ÿæˆå·¦ä¾§é”®ã€‚

## \#discr_tree_simp_key
å®šä¹‰äºï¼š`Lean.Parser.discrTreeSimpKeyCmd`

`#discr_tree_key  t` æ‰“å°é¡¹ `t` çš„æ­§è§†æ ‘é”®ï¼ˆè‹¥ä¸ºå•ä¸ªæ ‡è¯†ç¬¦ï¼Œåˆ™ä¸ºè¯¥å¸¸é‡çš„ç±»å‹ï¼‰ã€‚ä½¿ç”¨é»˜è®¤é”®ç”Ÿæˆé…ç½®ã€‚

ä¾‹å¦‚ï¼š
```lean
#discr_tree_key (âˆ€ {a n : Nat}, bar a (OfNat.ofNat n))
-- bar _ (@OfNat.ofNat Nat _ _)

#discr_tree_simp_key Nat.add_assoc
-- @HAdd.hAdd Nat Nat Nat _ (@HAdd.hAdd Nat Nat Nat _ _ _) _
```

`#discr_tree_simp_key` ç±»ä¼¼ `#discr_tree_key`ï¼Œä½†å°†åº•å±‚ç±»å‹è§†ä¸º simp å¼•ç†ï¼Œå³è½¬æ¢ä¸ºç­‰å¼å¹¶ç”Ÿæˆå·¦ä¾§é”®ã€‚

## \#eval!
å®šä¹‰äºï¼š`Lean.Parser.Command.evalBang`

`#eval e` é€šè¿‡ç¼–è¯‘å’Œæ±‚å€¼æ¥è¯„ä¼°è¡¨è¾¾å¼ `e`ã€‚

* è¯¥å‘½ä»¤å°è¯•ä½¿ç”¨ `ToExpr`ã€`Repr` æˆ– `ToString` å®ä¾‹æ¥æ‰“å°ç»“æœã€‚
* å¦‚æœ `e` æ˜¯ç±»å‹ä¸º `m ty` çš„å•å­å€¼ï¼Œåˆ™å‘½ä»¤ä¼šå°è¯•å°†å•å­ `m` é€‚é…åˆ° `#eval` æ”¯æŒçš„å•å­ä¹‹ä¸€ï¼ŒåŒ…æ‹¬ `IO`ã€`CoreM`ã€`MetaM`ã€`TermElabM` å’Œ `CommandElabM`ã€‚ç”¨æˆ·å¯é€šè¿‡å®šä¹‰ `MonadEval` å®ä¾‹æ¥æ‰©å±•æ”¯æŒçš„å•å­åˆ—è¡¨ã€‚

ç”±äºä¸å¥å…¨æ€§ï¼Œ`#eval` æ‹’ç»è¯„ä¼°ä¾èµ–äº `sorry` çš„è¡¨è¾¾å¼ï¼ˆå³ä½¿é—´æ¥ä¾èµ–ï¼‰ï¼Œå› ä¸º `sorry` çš„å­˜åœ¨å¯èƒ½å¯¼è‡´è¿è¡Œæ—¶ä¸ç¨³å®šå’Œå´©æºƒã€‚å¯ä½¿ç”¨ `#eval! e` å‘½ä»¤è¦†ç›–æ­¤æ£€æŸ¥ã€‚

é€‰é¡¹ï¼š
* è‹¥ `eval.pp` ä¸º trueï¼ˆé»˜è®¤ï¼štrueï¼‰ï¼Œåˆ™å°è¯•ä½¿ç”¨ `ToExpr` å®ä¾‹ä»¥åˆ©ç”¨å¸¸è§„çš„æ¼‚äº®æ‰“å°æœºã€‚å¦åˆ™ï¼Œä»…å°è¯•ä½¿ç”¨ `Repr` å’Œ `ToString` å®ä¾‹ã€‚
* è‹¥ `eval.type` ä¸º trueï¼ˆé»˜è®¤ï¼šfalseï¼‰ï¼Œåˆ™æ¼‚äº®æ‰“å°æ±‚å€¼å€¼çš„ç±»å‹ã€‚
* è‹¥ `eval.derive.repr` ä¸º trueï¼ˆé»˜è®¤ï¼štrueï¼‰ï¼Œåˆ™å½“æ— å…¶ä»–æ–¹å¼æ‰“å°ç»“æœæ—¶ï¼Œå°è¯•è‡ªåŠ¨æ´¾ç”Ÿ `Repr` å®ä¾‹ã€‚

å¦è§ï¼š`#reduce e` ç”¨äºé€šè¿‡é¡¹å½’çº¦è¿›è¡Œæ±‚å€¼ã€‚

## \#exit
å®šä¹‰äºï¼š`Lean.Parser.Command.exit`

## \#explode
å®šä¹‰äºï¼š`Mathlib.Explode.Â«command#explode_Â»`

`#explode expr` ä»¥é€è¡Œæ ¼å¼æ˜¾ç¤ºè¯æ˜é¡¹ï¼Œç±»ä¼¼äºFitché£æ ¼è¯æ˜æˆ–Metamathè¯æ˜é£æ ¼ã€‚

ä¾‹å¦‚ï¼Œåˆ†è§£ä»¥ä¸‹å®šç†ï¼š

```lean
#explode iff_of_true
```

ç”Ÿæˆï¼š

```lean
iff_of_true : âˆ€ {a b : Prop}, a â†’ b â†’ (a â†” b)

0â”‚         â”‚ a         â”œ Prop
1â”‚         â”‚ b         â”œ Prop
2â”‚         â”‚ ha        â”œ a
3â”‚         â”‚ hb        â”œ b
4â”‚         â”‚ xâœ        â”‚ â”Œ a
5â”‚4,3      â”‚ âˆ€I        â”‚ a â†’ b
6â”‚         â”‚ xâœ        â”‚ â”Œ b
7â”‚6,2      â”‚ âˆ€I        â”‚ b â†’ a
8â”‚5,7      â”‚ Iff.intro â”‚ a â†” b
9â”‚0,1,2,3,8â”‚ âˆ€I        â”‚ âˆ€ {a b : Prop}, a â†’ b â†’ (a â†” b)
```

## æ¦‚è¿°

`#explode` å‘½ä»¤å°†å®šç†çš„ä¸»ä½“åˆ†è§£ä¸ºå…¶ç»„æˆéƒ¨åˆ†ï¼Œé€è¡Œæ˜¾ç¤ºæ¯ä¸ªè¡¨è¾¾å¼æ„é€ å­ã€‚æ„é€ å­åœ¨ç¬¬ä¸‰åˆ—ä»¥æŸç§æ–¹å¼æŒ‡ç¤ºï¼Œå…¶ä¾èµ–å…³ç³»è®°å½•åœ¨ç¬¬äºŒåˆ—ã€‚

ä¸»è¦æ„é€ å­ç±»å‹åŒ…æ‹¬ï¼š

  - Lambdaè¡¨è¾¾å¼ï¼ˆ`Expr.lam`ï¼‰ã€‚è¡¨è¾¾å¼ `fun (h : p) => s` æ˜¾ç¤ºä¸ºï¼š
    ```lean
     0â”‚    â”‚ h   â”‚ â”Œ p
     1â”‚**  â”‚ **  â”‚ â”‚ q
     2â”‚1,2 â”‚ âˆ€I  â”‚ âˆ€ (h : p), q
    ```
    å…¶ä¸­ `**` ä¸ºé€šé…ç¬¦ï¼Œä¸”æ­¥éª¤0åˆ°1ä¹‹é—´å¯èƒ½æœ‰ä¸­é—´æ­¥éª¤ã€‚åµŒå¥—çš„lambdaè¡¨è¾¾å¼å¯åˆå¹¶ï¼Œ`âˆ€I` å¯ä¾èµ–ä¸€ç³»åˆ—å‚æ•°ã€‚

  - åº”ç”¨ï¼ˆ`Expr.app`ï¼‰ã€‚è¡¨è¾¾å¼ `f a b c` æ˜¾ç¤ºä¸ºï¼š
     ```lean
     0â”‚**      â”‚ f  â”‚ A â†’ B â†’ C â†’ D
     1â”‚**      â”‚ a  â”‚ A
     2â”‚**      â”‚ b  â”‚ B
     3â”‚**      â”‚ c  â”‚ C
     1â”‚0,1,2,3 â”‚ âˆ€E â”‚ D
     ```
     å„æ­¥éª¤é—´å¯èƒ½æœ‰ä¸­é—´æ­¥éª¤ã€‚ç‰¹æ®Šæƒ…å†µä¸‹ï¼Œè‹¥ `f` ä¸ºå¸¸é‡ï¼Œå¯çœç•¥ï¼Œæ˜¾ç¤ºä¸ºï¼š
     ```lean
     0â”‚**    â”‚ a â”‚ A
     1â”‚**    â”‚ b â”‚ B
     2â”‚**    â”‚ c â”‚ C
     3â”‚1,2,3 â”‚ f â”‚ D
     ```

  - Letè¡¨è¾¾å¼ï¼ˆ`Expr.letE`ï¼‰æ— ç‰¹æ®Šæ˜¾ç¤ºæ–¹å¼ï¼Œä½†ç¡®ä¿åœ¨ `let x := v; b` ä¸­å…ˆå¤„ç† `v` å†å¤„ç† `b`ï¼Œè€Œéå…ˆè¿›è¡Œzetaå½’çº¦ã€‚è¿™é¿å…lambdaåˆå¹¶å’Œåº”ç”¨åˆå¹¶ä½¿å« `let` çš„è¯æ˜éš¾ä»¥è§£é‡Šã€‚

  - å…¶ä»–å†…å®¹ï¼ˆå¸¸é‡ã€fvarsç­‰ï¼‰æ˜¾ç¤º `x : X` ä¸ºï¼š
    ```lean
    0â”‚  â”‚ x â”‚ X
    ```

## è¯¦ç»†è¯´æ˜

`#explode` çš„è¾“å‡ºä¸ºå››åˆ—Fitché£æ ¼è¯æ˜å›¾ï¼Œæ¨¡ä»¿Metamathçš„[æ­¤ç±»æ˜¾ç¤º](http://us.metamath.org/mpeuni/ru.html)ã€‚åˆ—å¤´ä¸ºâ€œæ­¥éª¤â€ã€â€œå‡è®¾â€ã€â€œå¼•ç”¨â€ã€â€œç±»å‹â€ï¼ˆæˆ–Metamathä¸­çš„â€œè¡¨è¾¾å¼â€ï¼‰ï¼š
* **æ­¥éª¤**ï¼šè¯æ˜ä¸­æ¯è¡Œçš„é€’å¢åºå·ï¼Œç”¨äºå‡è®¾å­—æ®µã€‚
* **å‡è®¾**ï¼šå½“å‰æ­¥éª¤çš„ç›´æ¥å­é¡¹ã€‚è¿™äº›æ˜¯å½“å‰æ­¥éª¤è¡¨è¾¾å¼çš„å­è¡¨è¾¾å¼æ­¥éª¤å·ã€‚å¯¹äºå®šç†åº”ç”¨ï¼Œä¸ºå®šç†å‚æ•°ï¼›å¯¹äºå…¨ç§°é‡è¯ï¼Œä¸ºæ‰€æœ‰ç»‘å®šå˜é‡åŠç»“è®ºã€‚
* **å¼•ç”¨**ï¼šåº”ç”¨çš„å®šç†åç§°ã€‚è¿™åœ¨Metamathä¸­æ˜ç¡®ï¼Œä½†Leanä¸­æŸäº›ç‰¹æ®Šæ­¥éª¤å¯èƒ½å› è¯æ˜é¡¹ç»“æ„ä¸å®Œå…¨åŒ¹é…è€Œæœ‰é•¿åç§°ã€‚
  * è‹¥å®šç†ä¸º `foo (x y : Z) : A x -> B y -> C x y`ï¼š
    * å¼•ç”¨å­—æ®µä¸º `foo`ï¼Œ
    * `x` å’Œ `y` è¢«æŠ‘åˆ¶ï¼Œå› é¡¹æ„é€ ä¸å…·è¶£å‘³ï¼Œ
    * å‡è®¾å­—æ®µå¼•ç”¨è¯æ˜ `A x` å’Œ `B y` çš„æ­¥éª¤ã€‚å¯¹åº”è¯æ˜é¡¹å¦‚ `@foo x y pA pB`ï¼Œå…¶ä¸­ `pA` å’Œ `pB` ä¸ºå­è¯æ˜ã€‚
    * å‡è®¾åˆ—ä¸­ï¼Œè¢«æŠ‘åˆ¶é¡¹è¢«çœç•¥ï¼ŒåŒ…æ‹¬åº”è¢«æŠ‘åˆ¶ä½†æœªè¢«æŠ‘åˆ¶çš„é¡¹ï¼ˆå°¤å…¶æ˜¯lambdaå‚æ•°ï¼‰ã€‚
      TODOï¼šå®ç°é…ç½®é€‰é¡¹ä»¥ä½¿ç”¨ `_` è€Œéæ­¥éª¤å·è¡¨ç¤ºè¢«æŠ‘åˆ¶é¡¹ã€‚
  * è‹¥è¯æ˜é¡¹å¤´éƒ¨ä¸ºå±€éƒ¨å¸¸é‡æˆ–lambdaï¼Œåˆ™å¼•ç”¨å­—æ®µæ˜¾ç¤º `âˆ€E`ï¼ˆå…¨ç§°æ¶ˆé™¤ï¼‰ã€‚ä¾‹å¦‚ï¼Œ`h : A -> B` å’Œ `ha : A` é€šè¿‡ `h ha` è¯æ˜ `b`ï¼Œåˆ™é‡æ–°è§£é‡Šä¸º `âˆ€E h ha`ï¼Œå…¶ä¸­ `âˆ€E` ä¸ºï¼ˆnå…ƒï¼‰å‡è¨€æ¨ç†ã€‚
  * è‹¥è¯æ˜é¡¹ä¸ºlambdaï¼Œåˆ™ä½¿ç”¨ `âˆ€I`ï¼ˆå…¨ç§°å¼•å…¥ï¼‰å¼•ç”¨lambdaä½“ã€‚ç¼©è¿›çº§åˆ«å¢åŠ ï¼Œæ‹¬å·åŒ…å›´lambdaä½“çš„è¯æ˜ï¼Œèµ·å§‹äºæ ‡æœ‰lambdaå˜é‡ååŠå…¶ç±»å‹çš„æ­¥éª¤ï¼Œç»ˆæ­¢äº `âˆ€I` æ­¥éª¤ã€‚Metamathæ— æ­¤ç±»æ­¥éª¤ï¼Œä½†é£æ ¼åŸºäºä¸€é˜¶é€»è¾‘çš„Fitchè¯æ˜ã€‚

## \#find
å®šä¹‰äºï¼š`Mathlib.Tactic.Find.Â«command#find_Â»`

## \#find_home
å®šä¹‰äºï¼š`Â«command#find_home!_Â»`

å°½å¯èƒ½åœ¨å¯¼å…¥å±‚æ¬¡ç»“æ„çš„é«˜å¤„æ‰¾åˆ°å‘½åå£°æ˜å¯èƒ½å­˜åœ¨çš„ä½ç½®ã€‚
ä½¿ç”¨ `#find_home!` å°†å¼ºåˆ¶ç§»é™¤å½“å‰æ–‡ä»¶ã€‚æ³¨æ„ï¼Œåœ¨å« `import Mathlib` çš„æ–‡ä»¶ä¸­ä½¿ç”¨æ•ˆæœæœ€ä½³ã€‚

å³ä½¿ä½¿ç”¨ `#find_home! lemma`ï¼Œå½“å‰æ–‡ä»¶ä»å¯èƒ½ä¸ºå”¯ä¸€å»ºè®®ã€‚åŸå› æ˜¯ `#find_home!` æ‰«æå½“å‰æ–‡ä»¶ä¸‹æ–¹çš„å¯¼å…¥å›¾ï¼Œé€‰æ‹©åŒ…å«å‡ºç°åœ¨ `lemma` ä¸­çš„å£°æ˜çš„æ–‡ä»¶ï¼ˆæ’é™¤å½“å‰æ–‡ä»¶æœ¬èº«ï¼‰ï¼Œå¹¶å¯»æ‰¾è¿™äº›æ–‡ä»¶çš„æ‰€æœ‰æœ€å°ä¸Šç•Œã€‚

ç®€å•ç¤ºä¾‹ï¼Œè‹¥ `lemma` åœ¨ä»…å¯¼å…¥ `A.lean` å’Œ `B.lean` çš„æ–‡ä»¶ä¸­ï¼Œä¸”å„ä½¿ç”¨ä¸€ä¸ªå¼•ç†ï¼Œåˆ™ `#find_home! lemma` è¿”å›å½“å‰æ–‡ä»¶ã€‚

## \#find_syntax
å®šä¹‰äºï¼š`Mathlib.FindSyntax.Â«command#find_syntax_ApproxÂ»`

`#find_syntax` å‘½ä»¤æ¥å—å­—ç¬¦ä¸² `str`ï¼Œå¹¶ä»ç¯å¢ƒä¸­æ£€ç´¢æ‰€æœ‰åŒ…å« `str` çš„ `syntax` é¡¹å€™é€‰ã€‚

å…¶è¿˜ç²—ç•¥å°è¯•é‡æ–°ç”Ÿæˆè¯­æ³•å¤–è§‚ï¼šä»…ä¸ºç¤ºæ„è¯­æ³•å¯èƒ½å½¢å¼ï¼Œä¸ä¿è¯æ­£ç¡®æ€§ã€‚

å¯é€‰å°¾éš `approx`ï¼ˆå¦‚ `#find_syntax "âˆ˜" approx`ï¼‰ä»…æ„å›¾ä½¿æµ‹è¯•æ›´ç¨³å®šï¼šä¸è¾“å‡ºç°æœ‰è¯­æ³•å£°æ˜çš„ç²¾ç¡®æ€»æ•°ï¼Œè€Œæ˜¯è¿”å›å…¶å‘ä¸‹å–æ•´è‡³å‰ä¸€ä¸ª100çš„å€æ•°ã€‚

## \#guard
å®šä¹‰äº: `Lean.Parser.Command.guardCmd`

ç”¨äºæ£€æŸ¥è¡¨è¾¾å¼æ±‚å€¼ç»“æœä¸º `true` çš„å‘½ä»¤ã€‚

`#guard e` å¯¹ `e` è¿›è¡Œç»†éƒ¨åŒ–ï¼Œç¡®ä¿å…¶ç±»å‹ä¸º `Bool` åæ±‚å€¼ï¼Œå¹¶æ£€æŸ¥ç»“æœæ˜¯å¦ä¸º `true`ã€‚è¯¥è¡¨è¾¾å¼åœ¨ç»†éƒ¨åŒ–æ—¶*ä¸ä¼š*åŒ…å«ä½¿ç”¨ `variable` å£°æ˜çš„å˜é‡ï¼Œå› ä¸ºè¿™äº›å˜é‡æ— æ³•è¢«æ±‚å€¼ã€‚

ç”±äºä½¿ç”¨äº†å¼ºåˆ¶è½¬æ¢ï¼Œåªè¦å‘½é¢˜ `p` æ˜¯å¯åˆ¤å®šçš„ï¼Œå³å¯ç›´æ¥ä¹¦å†™ `#guard p` è€Œæ— éœ€å†™æˆ `#guard decide p`ã€‚ä¸€ä¸ªæ¨è®ºæ˜¯ï¼Œè‹¥å­˜åœ¨å¯åˆ¤å®šçš„ç­‰å¼ï¼Œåˆ™å¯ç›´æ¥ä¹¦å†™ `#guard a = b`ã€‚éœ€æ³¨æ„è¿™ä¸ç›´æ¥æ£€æŸ¥ `a` å’Œ `b` æ˜¯å¦æ±‚å€¼ä¸ºç›¸åŒå¯¹è±¡å¹¶ä¸å®Œå…¨ç›¸åŒï¼Œå› ä¸ºå®ƒä½¿ç”¨äº† `DecidableEq` å®ä¾‹æ¥è¿›è¡Œæ±‚å€¼ã€‚

æ³¨æ„ï¼šæ­¤å‘½ä»¤ä½¿ç”¨éå—ä¿¡ä»»çš„æ±‚å€¼å™¨ï¼Œå› æ­¤ `#guard` é€šè¿‡*å¹¶ä¸*ä»£è¡¨è¡¨è¾¾å¼ç­‰äº `true` çš„è¯æ˜ã€‚

## \#guard_expr
å®šä¹‰äº: `Lean.Parser.Command.guardExprCmd`

ç”¨äºæ£€æŸ¥ä¸¤ä¸ªè¡¨è¾¾å¼ç›¸ç­‰æ€§çš„å‘½ä»¤ã€‚
* `#guard_expr e = e'` æ£€æŸ¥ `e` å’Œ `e'` åœ¨å¯çº¦é€æ˜åº¦ä¸‹æ˜¯å¦å®šä¹‰ç­‰ä»·ã€‚
* `#guard_expr e =~ e'` æ£€æŸ¥ `e` å’Œ `e'` åœ¨é»˜è®¤é€æ˜åº¦ä¸‹æ˜¯å¦å®šä¹‰ç­‰ä»·ã€‚
* `#guard_expr e =â‚› e'` æ£€æŸ¥ `e` å’Œ `e'` æ˜¯å¦è¯­æ³•ç­‰ä»·ã€‚
* `#guard_expr e =â‚ e'` æ£€æŸ¥ `e` å’Œ `e'` æ˜¯å¦ Î± ç­‰ä»·ã€‚

æ­¤ä¸º `guard_expr` ç­–ç•¥çš„å‘½ä»¤ç‰ˆæœ¬ã€‚

## \#guard_msgs
å®šä¹‰äº: `Lean.guardMsgsCmd`

`/-- ... -/ #guard_msgs in cmd` æ•è·å‘½ä»¤ `cmd` ç”Ÿæˆçš„æ¶ˆæ¯å¹¶æ£€æŸ¥å…¶æ˜¯å¦ä¸æ–‡æ¡£å­—ç¬¦ä¸²å†…å®¹åŒ¹é…ã€‚

åŸºç¡€ç¤ºä¾‹ï¼š
```lean
/--
error: æœªçŸ¥æ ‡è¯†ç¬¦ 'x'
-/
#guard_msgs in
example : Î± := x
```
æ­¤ç¤ºä¾‹æ£€æŸ¥æ˜¯å¦å­˜åœ¨è¯¥é”™è¯¯å¹¶æ¶ˆè´¹è¯¥æ¶ˆæ¯ã€‚

é»˜è®¤æƒ…å†µä¸‹ï¼Œè¯¥å‘½ä»¤æ•è·æ‰€æœ‰æ¶ˆæ¯ï¼Œä½†å¯è°ƒæ•´è¿‡æ»¤æ¡ä»¶ã€‚ä¾‹å¦‚ï¼Œä»…é€‰æ‹©è­¦å‘Šï¼š
```lean
/--
warning: å£°æ˜ä½¿ç”¨äº† 'sorry'
-/
#guard_msgs(warning) in
example : Î± := sorry
```
æˆ–ä»…é€‰æ‹©é”™è¯¯ï¼š
```lean
#guard_msgs(error) in
example : Î± := sorry
```
åœ¨å‰ä¾‹ä¸­ï¼Œç”±äºæœªæ•è·è­¦å‘Šï¼Œ`sorry` å¤„ä¼šäº§ç”Ÿè­¦å‘Šã€‚è‹¥éœ€å®Œå…¨ä¸¢å¼ƒè­¦å‘Šï¼Œå¯ä½¿ç”¨ï¼š
```lean
#guard_msgs(error, drop warning) in
example : Î± := sorry
```

ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œ`#guard_msgs` æ¥å—æ‹¬å·å†…çš„é€—å·åˆ†éš”é…ç½®é¡¹åˆ—è¡¨ï¼š
```lean
#guard_msgs (configElt,*) in cmd
```
é»˜è®¤é…ç½®åˆ—è¡¨ä¸º `(all, whitespace := normalized, ordering := exact)`ã€‚

æ¶ˆæ¯è¿‡æ»¤å™¨ï¼ˆæŒ‰ä»å·¦åˆ°å³é¡ºåºå¤„ç†ï¼‰ï¼š
- `info`ã€`warning`ã€`error`ï¼šæ•è·æŒ‡å®šä¸¥é‡çº§åˆ«çš„æ¶ˆæ¯ã€‚
- `all`ï¼šæ•è·æ‰€æœ‰æ¶ˆæ¯ï¼ˆé»˜è®¤ï¼‰ã€‚
- `drop info`ã€`drop warning`ã€`drop error`ï¼šä¸¢å¼ƒæŒ‡å®šä¸¥é‡çº§åˆ«çš„æ¶ˆæ¯ã€‚
- `drop all`ï¼šä¸¢å¼ƒæ‰€æœ‰æ¶ˆæ¯ã€‚

ç©ºç™½å¤„ç†ï¼ˆåœ¨ä¿®å‰ªé¦–å°¾ç©ºç™½åï¼‰ï¼š
- `whitespace := exact` è¦æ±‚ç©ºç™½å®Œå…¨åŒ¹é…ã€‚
- `whitespace := normalized` åœ¨åŒ¹é…å‰å°†æ‰€æœ‰æ¢è¡Œç¬¦è½¬æ¢ä¸ºç©ºæ ¼ï¼ˆé»˜è®¤ï¼‰ã€‚å…è®¸æŠ˜è¡Œã€‚
- `whitespace := lax` åœ¨åŒ¹é…å‰å°†ç©ºç™½åˆå¹¶ä¸ºå•ä¸ªç©ºæ ¼ã€‚

æ¶ˆæ¯é¡ºåºï¼š
- `ordering := exact` ä½¿ç”¨æ¶ˆæ¯çš„ç²¾ç¡®é¡ºåºï¼ˆé»˜è®¤ï¼‰ã€‚
- `ordering := sorted` æŒ‰å­—å…¸åºæ’åºæ¶ˆæ¯ã€‚é€‚ç”¨äºæµ‹è¯•å‘½ä»¤æ¶ˆæ¯é¡ºåºä¸ç¡®å®šçš„æƒ…å†µã€‚

ä¾‹å¦‚ï¼Œ`#guard_msgs (error, drop all) in cmd` è¡¨ç¤ºæ£€æŸ¥é”™è¯¯å¹¶ä¸¢å¼ƒå…¶ä»–æ‰€æœ‰æ¶ˆæ¯ã€‚

å‘½ä»¤ç»†éƒ¨åŒ–å™¨å¯¹ `#guard_msgs` çš„é™æ€æ£€æŸ¥æœ‰ç‰¹æ®Šæ”¯æŒã€‚`#guard_msgs` è‡ªèº«å¸Œæœ›æ•è·é™æ€æ£€æŸ¥è­¦å‘Šï¼Œå› æ­¤å°†å…¶é™„åŠ çš„å‘½ä»¤è§†ä¸ºé¡¶å±‚å‘½ä»¤è¿›è¡Œç»†éƒ¨åŒ–ã€‚ç„¶è€Œï¼Œå‘½ä»¤ç»†éƒ¨åŒ–å™¨ä¼šä¸º*æ‰€æœ‰*é¡¶å±‚å‘½ä»¤è¿è¡Œé™æ€æ£€æŸ¥ï¼ŒåŒ…æ‹¬ `#guard_msgs` è‡ªèº«ï¼Œè¿™ä¼šå¯¼è‡´é‡å¤æˆ–æœªæ•è·çš„é™æ€æ£€æŸ¥è­¦å‘Šã€‚é¡¶å±‚å‘½ä»¤ç»†éƒ¨åŒ–å™¨ä»…åœ¨ `#guard_msgs` ä¸å­˜åœ¨æ—¶è¿è¡Œé™æ€æ£€æŸ¥ã€‚

## \#help
å®šä¹‰äº: `Batteries.Tactic.Â«command#help_Term+____Â»`

å‘½ä»¤ `#help term` æ˜¾ç¤ºå½“å‰ç¯å¢ƒä¸­å®šä¹‰çš„æ‰€æœ‰é¡¹è¯­æ³•ã€‚è¯¦è§ `#help cat`ã€‚

## \#help
å®šä¹‰äº: `Batteries.Tactic.Â«command#help_Cat+______Â»`

å‘½ä»¤ `#help cat C` æ˜¾ç¤ºå½“å‰ç¯å¢ƒä¸­è¯­æ³•ç±»åˆ« `C` å®šä¹‰çš„æ‰€æœ‰è¯­æ³•ã€‚
æ¯ä¸ªè¯­æ³•çš„æ ¼å¼å¦‚ä¸‹ï¼š
```lean
## first
å®šä¹‰äº: `Parser.tactic.first`

  `first | tac | ...` ä¾æ¬¡è¿è¡Œæ¯ä¸ª `tac` ç›´è‡³æˆåŠŸï¼Œå¦åˆ™å¤±è´¥ã€‚
```
å¼•å·å†…ä¸ºè¯­æ³•çš„å‰å¯¼æ ‡è®°ï¼ˆå¦‚é€‚ç”¨ï¼‰ï¼Œåè·Ÿè¯­æ³•çš„å…¨åï¼ˆå¯ç‚¹å‡»è·³è½¬è‡³å®šä¹‰ï¼‰åŠæ–‡æ¡£ã€‚

* `#help cat C id` å½¢å¼ä»…æ˜¾ç¤ºä»¥ `id` å¼€å¤´çš„è¯­æ³•ã€‚
* `#help cat+ C` å½¢å¼é¢å¤–æ˜¾ç¤ºä¸æ‰€åˆ—è¯­æ³•ç›¸å…³è”çš„ `macro` å’Œ `elab` ä¿¡æ¯ã€‚

## \#help
å®šä¹‰äº: `Batteries.Tactic.Â«command#help_Command+____Â»`

å‘½ä»¤ `#help command` æ˜¾ç¤ºå½“å‰ç¯å¢ƒä¸­å®šä¹‰çš„æ‰€æœ‰å‘½ä»¤ã€‚è¯¦è§ `#help cat`ã€‚

## \#help
å®šä¹‰äº: `Batteries.Tactic.Â«command#help_AttrAttribute___Â»`

å‘½ä»¤ `#help attribute`ï¼ˆæˆ–ç®€å†™ `#help attr`ï¼‰æ˜¾ç¤ºå½“å‰ç¯å¢ƒä¸­å®šä¹‰çš„æ‰€æœ‰å±æ€§ã€‚
æ¯ä¸ªå±æ€§çš„æ ¼å¼å¦‚ä¸‹ï¼š
```lean
[inline]: æ ‡è®°å®šä¹‰ä»¥å§‹ç»ˆå†…è”
```
è¡¨ç¤º `inline` æ˜¯å¯åº”ç”¨äºå®šä¹‰çš„å±æ€§ï¼Œå¦‚ `@[inline] def foo := 1`ã€‚ï¼ˆä¸ªåˆ«å±æ€§å¯èƒ½æœ‰åº”ç”¨ä½ç½®é™åˆ¶ï¼Œè¯¦è§å±æ€§æ–‡æ¡£ã€‚ï¼‰æ­¤å¤„æ˜¾ç¤ºå±æ€§çš„ `descr` å­—æ®µåŠæ–‡æ¡£å­—ç¬¦ä¸²ã€‚

`#help attr id` å½¢å¼ä»…æ˜¾ç¤ºä»¥ `id` å¼€å¤´çš„å±æ€§ã€‚

## \#help
å®šä¹‰äº: `Batteries.Tactic.Â«command#help_Note___Â»`

`#help note "foo"` æœç´¢æ ‡ç­¾ä»¥ "foo" å¼€å¤´çš„æ‰€æœ‰åº“æ³¨ï¼Œå¹¶æŒ‰æ ‡ç­¾å­—æ¯é¡ºåºåˆ†ç»„æ˜¾ç¤ºã€‚è¯¥å‘½ä»¤ä»…æ˜¾ç¤ºåœ¨å¯¼å…¥æ–‡ä»¶æˆ–åŒä¸€æ–‡ä»¶ä¸­è¯¥å‘½ä»¤è¡Œä¸Šæ–¹å£°æ˜çš„åº“æ³¨ã€‚

## \#help
å®šä¹‰äº: `Batteries.Tactic.Â«command#help_Cats___Â»`

å‘½ä»¤ `#help cats` æ˜¾ç¤ºå½“å‰ç¯å¢ƒä¸­å®šä¹‰çš„æ‰€æœ‰è¯­æ³•ç±»åˆ«ã€‚
æ¯ä¸ªè¯­æ³•çš„æ ¼å¼å¦‚ä¸‹ï¼š
```lean
category command [Lean.Parser.initFnâœ]
```
æ­¤å¤„è¯­æ³•ç±»åˆ«åä¸º `command`ï¼Œ`Lean.Parser.initFnâœ` ä¸ºå¼•å…¥è¯¥ç±»åˆ«å£°æ˜çš„åç§°ï¼ˆå¸¸ä¸ºåŒ¿åå£°æ˜ï¼Œä½†å¯ç‚¹å‡»è·³è½¬è‡³å®šä¹‰ï¼‰ã€‚è‹¥å­˜åœ¨æ–‡æ¡£å­—ç¬¦ä¸²ï¼Œäº¦ä¼šæ˜¾ç¤ºã€‚

`#help cats id` å½¢å¼ä»…æ˜¾ç¤ºä»¥ `id` å¼€å¤´çš„è¯­æ³•ç±»åˆ«ã€‚

## \#help
å®šä¹‰äº: `Batteries.Tactic.Â«command#help_Tactic+____Â»`

å‘½ä»¤ `#help tactic` æ˜¾ç¤ºå½“å‰ç¯å¢ƒä¸­å®šä¹‰çš„æ‰€æœ‰ç­–ç•¥ã€‚è¯¦è§ `#help cat`ã€‚

## \#help
å®šä¹‰äº: `Batteries.Tactic.Â«command#help_Conv+____Â»`

å‘½ä»¤ `#help conv` æ˜¾ç¤ºå½“å‰ç¯å¢ƒä¸­å®šä¹‰çš„æ‰€æœ‰è½¬æ¢ç­–ç•¥ã€‚è¯¦è§ `#help cat`ã€‚

## \#help
å®šä¹‰äº: `Batteries.Tactic.Â«command#help_Option___Â»`

å‘½ä»¤ `#help option` æ˜¾ç¤ºå½“å‰ç¯å¢ƒä¸­å®šä¹‰çš„æ‰€æœ‰é€‰é¡¹ã€‚
æ¯ä¸ªé€‰é¡¹çš„æ ¼å¼å¦‚ä¸‹ï¼š
```lean
option pp.all : Bool := false
  ï¼ˆç¾è§‚æ‰“å°å™¨ï¼‰æ˜¾ç¤ºå¼ºåˆ¶è½¬æ¢ã€éšå¼å‚æ•°ã€è¯æ˜é¡¹ã€å…¨é™å®šåã€å®‡å®™ï¼Œå¹¶åœ¨ç¾è§‚æ‰“å°æ—¶ç¦ç”¨ Î² å½’çº¦å’Œè®°æ³•
```
è¡¨ç¤º `pp.all` ä¸ºå¯è®¾ç½®ä¸º `Bool` å€¼çš„é€‰é¡¹ï¼Œé»˜è®¤å€¼ä¸º `false`ã€‚è‹¥é€‰é¡¹å·²é€šè¿‡å¦‚ `set_option pp.all true` ä¿®æ”¹é»˜è®¤å€¼ï¼Œå°†æ˜¾ç¤º `ï¼ˆå½“å‰å€¼ï¼štrueï¼‰` çš„æ³¨é‡Šã€‚

`#help option id` å½¢å¼ä»…æ˜¾ç¤ºä»¥ `id` å¼€å¤´çš„é€‰é¡¹ã€‚

## \#html
å®šä¹‰äº: `ProofWidgets.HtmlCommand.htmlCmd`

åœ¨ä¿¡æ¯è§†å›¾ä¸­æ˜¾ç¤º `Html` ç±»å‹çš„å€¼ã€‚

è¾“å…¥å¯ä¸ºçº¯å€¼æˆ–ä»»ä½• Lean å…ƒç¼–ç¨‹å•å­ä¸­çš„è®¡ç®—ï¼ˆå¦‚ `CommandElabM Html`ï¼‰ã€‚

## \#import_bumps
å®šä¹‰äº: `Mathlib.Linter.MinImports.Â«command#import_bumpsÂ»`

`minImports` ä»£ç æ£€æŸ¥å·¥å…·ä¼šé€æ­¥è®¡ç®—æ¯ä¸ªæ–‡ä»¶æ„å»ºæ‰€éœ€çš„æœ€å°å¯¼å…¥é›†ã€‚æ¯å½“æ£€æµ‹åˆ°æ–°å‘½ä»¤éœ€è¦å¢åŠ å…¶å·²è®¡ç®—çš„ï¼ˆä¼ é€’ï¼‰å¯¼å…¥æ—¶ï¼Œè¯¥å·¥å…·ä¼šå‘å‡ºè­¦å‘Šï¼ŒæŒ‡å‡ºæ›´å¤§çš„æœ€å°å¯¼å…¥é›†ã€‚

ä¸ç›¸å…³çš„ `#min_imports` å‘½ä»¤ä¸åŒï¼Œæ­¤æ£€æŸ¥å·¥å…·ä¼šè€ƒè™‘ç¬¦å·å’Œç­–ç•¥ä¿¡æ¯ã€‚å®ƒä»¥å¢é‡æ–¹å¼å·¥ä½œï¼Œæä¾›æ›´é€‚åˆæ‹†åˆ†æ–‡ä»¶ç­‰ä¿¡æ¯ã€‚

å¦ä¸€é‡è¦åŒºåˆ«æ˜¯ï¼Œ`minImports` *æ£€æŸ¥å·¥å…·* ä»è®¾ç½®é€‰é¡¹ä¸º `true` çš„ä½ç½®å¼€å§‹å‘ä¸‹è®¡ç®—å¯¼å…¥ï¼Œè€Œ `#min_imports` *å‘½ä»¤* åˆ™ä»å‘½ä»¤æ‰€åœ¨ä½ç½®å‘ä¸ŠæŸ¥çœ‹æ‰€éœ€çš„å¯¼å…¥ã€‚

## \#info_trees
å®šä¹‰äº: `Lean.infoTreesCmd`

æ ¼å¼åŒ–å¹¶æ‰“å°æŒ‡å®šå‘½ä»¤çš„ä¿¡æ¯æ ‘ã€‚æ­¤åŠŸèƒ½ä¸»è¦ç”¨äºè°ƒè¯•ä¿¡æ¯æ ‘ã€‚

## \#instances
å®šä¹‰äº: `Batteries.Tactic.Instances.instancesCmd`

`#instances é¡¹` æ‰“å°ç»™å®šç±»çš„æ‰€æœ‰å®ä¾‹ã€‚ä¾‹å¦‚ï¼Œ`#instances Add _` ç»™å‡ºæ‰€æœ‰ `Add` å®ä¾‹ï¼Œ`#instances Add Nat` ç»™å‡º `Nat` å®ä¾‹ã€‚`é¡¹` å¯ä»¥æ˜¯å‡ºç°åœ¨ `[...]` ç»‘å®šå™¨ä¸­çš„ä»»ä½•ç±»å‹ã€‚

æœ«å°¾çš„ä¸‹åˆ’çº¿å¯çœç•¥ï¼Œ`#instances Add` ä¸ `#instances Add _` ç­‰æ•ˆï¼›è¯¥å‘½ä»¤ä¼šæ·»åŠ å…ƒå˜é‡ï¼Œç›´è‡³å‚æ•°ä¸å†æ˜¯å‡½æ•°ã€‚

`#instances` å‘½ä»¤ä¸ `#synth` å¯†åˆ‡ç›¸å…³ï¼Œä½† `#synth` æ‰§è¡Œå®Œæ•´çš„å®ä¾‹åˆæˆç®—æ³•ï¼Œè€Œ `#instances` ä»…æ‰§è¡ŒæŸ¥æ‰¾æ½œåœ¨å®ä¾‹çš„ç¬¬ä¸€æ­¥ã€‚

## \#instances
å®šä¹‰äº: `Batteries.Tactic.Instances.Â«command#instances__:_Â»`

`#instances é¡¹` æ‰“å°ç»™å®šç±»çš„æ‰€æœ‰å®ä¾‹ã€‚ä¾‹å¦‚ï¼Œ`#instances Add _` ç»™å‡ºæ‰€æœ‰ `Add` å®ä¾‹ï¼Œ`#instances Add Nat` ç»™å‡º `Nat` å®ä¾‹ã€‚`é¡¹` å¯ä»¥æ˜¯å‡ºç°åœ¨ `[...]` ç»‘å®šå™¨ä¸­çš„ä»»ä½•ç±»å‹ã€‚

æœ«å°¾çš„ä¸‹åˆ’çº¿å¯çœç•¥ï¼Œ`#instances Add` ä¸ `#instances Add _` ç­‰æ•ˆï¼›è¯¥å‘½ä»¤ä¼šæ·»åŠ å…ƒå˜é‡ï¼Œç›´è‡³å‚æ•°ä¸å†æ˜¯å‡½æ•°ã€‚

`#instances` å‘½ä»¤ä¸ `#synth` å¯†åˆ‡ç›¸å…³ï¼Œä½† `#synth` æ‰§è¡Œå®Œæ•´çš„å®ä¾‹åˆæˆç®—æ³•ï¼Œè€Œ `#instances` ä»…æ‰§è¡ŒæŸ¥æ‰¾æ½œåœ¨å®ä¾‹çš„ç¬¬ä¸€æ­¥ã€‚

## \#kerodon_tags
å®šä¹‰äº: `Mathlib.StacksTag.kerodonTags`

`#kerodon_tags` å‘½ä»¤æ£€ç´¢æ‰€æœ‰å…·æœ‰ `kerodon` å±æ€§çš„å£°æ˜ã€‚

å¯¹æ¯ä¸ªæ‰¾åˆ°çš„å£°æ˜ï¼Œæ‰“å°ä¸€è¡Œï¼š
```
'declaration_name' å¯¹åº”äºæ ‡ç­¾ 'declaration_tag'ã€‚
```
å˜ä½“ `#kerodon_tags!` è¿˜ä¼šåœ¨æ¯ä¸ªæ‘˜è¦è¡Œåæ·»åŠ å®šç†é™ˆè¿°ã€‚

## \#leansearch
å®šä¹‰äº: `LeanSearchClient.leansearch_search_cmd`

åœ¨ Lean å†…æœç´¢ [LeanSearch](https://leansearch.net/)ã€‚æŸ¥è¯¢åº”ä¸ºä»¥ `.` æˆ– `?` ç»“å°¾çš„å­—ç¬¦ä¸²ã€‚è¯¥å‘½ä»¤å¯ä½œä¸ºå‘½ä»¤ã€æœ¯è¯­æˆ–ç­–ç•¥ä½¿ç”¨ï¼Œå¦‚ä¸‹ä¾‹æ‰€ç¤ºã€‚åœ¨ç­–ç•¥æ¨¡å¼ä¸‹ï¼Œä»…æ˜¾ç¤ºæœ‰æ•ˆç­–ç•¥ã€‚

```lean
#leansearch "è‹¥è‡ªç„¶æ•° n å°äº mï¼Œåˆ™ n çš„åç»§å°äº m çš„åç»§ã€‚"

example := #leansearch "è‹¥è‡ªç„¶æ•° n å°äº mï¼Œåˆ™ n çš„åç»§å°äº m çš„åç»§ã€‚"

example : 3 â‰¤ 5 := by
  #leansearch "è‹¥è‡ªç„¶æ•° n å°äº mï¼Œåˆ™ n çš„åç»§å°äº m çš„åç»§ã€‚"
  sorry
```

## \#lint
å®šä¹‰äº: `Batteries.Tactic.Lint.Â«command#lint+-*Only___Â»`

å‘½ä»¤ `#lint` åœ¨å½“å‰æ–‡ä»¶è¿è¡Œä»£ç æ£€æŸ¥å·¥å…·ï¼ˆé»˜è®¤æƒ…å†µä¸‹ï¼‰ã€‚

`#lint only æŸæ£€æŸ¥å·¥å…·` å¯ç”¨äºä»…è¿è¡Œå•ä¸ªæ£€æŸ¥å·¥å…·ã€‚

## \#list_linters
å®šä¹‰äº: `Batteries.Tactic.Lint.Â«command#list_lintersÂ»`

å‘½ä»¤ `#list_linters` æ‰“å°æ‰€æœ‰å¯ç”¨æ£€æŸ¥å·¥å…·çš„åˆ—è¡¨ã€‚

## \#long_instances
å®šä¹‰äº: `Â«command#long_instances_Â»`

åˆ—å‡ºæ‰€æœ‰ä»¥ `inst` å¼€å¤´çš„é•¿åç§°å®ä¾‹ï¼ŒæŒ‰å®šä¹‰å®ƒä»¬çš„æ¨¡å—åˆ†ç»„ã€‚æ­¤åŠŸèƒ½æœ‰åŠ©äºæŸ¥æ‰¾å…·æœ‰è’è°¬åç§°çš„è‡ªåŠ¨å‘½åå®ä¾‹ã€‚

ä½¿ç”¨æ–¹å¼ä¸º `#long_names` æˆ– `#long_names 100` æŒ‡å®šé•¿åº¦ã€‚

## \#long_names
å®šä¹‰äº: `Â«command#long_names_Â»`

åˆ—å‡ºæ‰€æœ‰å…·æœ‰é•¿åç§°çš„å£°æ˜ï¼ŒæŒ‰å®šä¹‰å®ƒä»¬çš„æ¨¡å—åˆ†ç»„ã€‚ä½¿ç”¨æ–¹å¼ä¸º `#long_names` æˆ– `#long_names 100` æŒ‡å®šé•¿åº¦ã€‚

## \#loogle
å®šä¹‰äº: `LeanSearchClient.loogle_cmd`

åœ¨ Lean å†…æœç´¢ [Loogle](https://loogle.lean-lang.org/json)ã€‚è¯¥å‘½ä»¤å¯ä½œä¸ºå‘½ä»¤ã€æœ¯è¯­æˆ–ç­–ç•¥ä½¿ç”¨ï¼Œå¦‚ä¸‹ä¾‹æ‰€ç¤ºã€‚åœ¨ç­–ç•¥æ¨¡å¼ä¸‹ï¼Œä»…æ˜¾ç¤ºæœ‰æ•ˆç­–ç•¥ã€‚

```lean
#loogle List ?a â†’ ?a

example := #loogle List ?a â†’ ?a

example : 3 â‰¤ 5 := by
  #loogle Nat.succ_le_succ
  sorry

```

## Loogle ä½¿ç”¨æ–¹å¼

Loogle é€šè¿‡å¤šç§æ–¹å¼æŸ¥æ‰¾å®šä¹‰å’Œå¼•ç†ï¼š

é€šè¿‡å¸¸é‡ï¼š
ğŸ” Real.sin
æŸ¥æ‰¾æ‰€æœ‰é™ˆè¿°ä¸­æåŠæ­£å¼¦å‡½æ•°çš„å¼•ç†ã€‚

é€šè¿‡å¼•ç†åç§°å­ä¸²ï¼š
ğŸ” "differ"
æŸ¥æ‰¾æ‰€æœ‰åç§°ä¸­åŒ…å« "differ" çš„å¼•ç†ã€‚

é€šè¿‡å­è¡¨è¾¾å¼ï¼š
ğŸ” _ * (_ ^ _)
æŸ¥æ‰¾æ‰€æœ‰é™ˆè¿°ä¸­æŸå¤„åŒ…å«ä¹˜ç§¯ä¸”ç¬¬äºŒä¸ªå‚æ•°ä¸ºæŸæ¬¡å¹‚çš„å¼•ç†ã€‚

æ¨¡å¼ä¹Ÿå¯éçº¿æ€§ï¼Œå¦‚ï¼š
ğŸ” Real.sqrt ?a * Real.sqrt ?a

è‹¥æ¨¡å¼å«æœ‰å‚æ•°ï¼Œåˆ™å‚æ•°ä»¥ä»»æ„é¡ºåºåŒ¹é…ã€‚ä»¥ä¸‹ä¸¤è€…å‡ä¼šæ‰¾åˆ° List.mapï¼š
ğŸ” (?a -> ?b) -> List ?a -> List ?b
ğŸ” List ?a -> (?a -> ?b) -> List ?b

é€šè¿‡ä¸»è¦ç»“è®ºï¼š
ğŸ” |- tsum _ = _ * tsum _
æŸ¥æ‰¾æ‰€æœ‰ç»“è®ºï¼ˆæ‰€æœ‰ â†’ å’Œ âˆ€ å³ä¾§çš„å­è¡¨è¾¾å¼ï¼‰å…·æœ‰ç»™å®šå½¢çŠ¶çš„å¼•ç†ã€‚

å¦‚å‰æ‰€è¿°ï¼Œè‹¥æ¨¡å¼å«æœ‰å‚æ•°ï¼Œåˆ™å‚æ•°ä»¥ä»»æ„é¡ºåºåŒ¹é…å¼•ç†çš„å‡è®¾ï¼›ä¾‹å¦‚ï¼Œ
ğŸ” |- _ < _ â†’ tsum _ < tsum _
å°†æ‰¾åˆ° tsum_lt_tsumï¼Œå³ä½¿å‡è®¾ f i < g i å¹¶éæœ€åã€‚

è‹¥ä¼ é€’å¤šä¸ªæœç´¢è¿‡æ»¤å™¨ï¼ˆä»¥é€—å·åˆ†éš”ï¼‰ï¼ŒLoogle å°†è¿”å›åŒ¹é…æ‰€æœ‰è¿‡æ»¤å™¨çš„å¼•ç†ã€‚æœç´¢
ğŸ” Real.sin, "two", tsum, _ * _, _ ^ _, |- _ < _ â†’ _
å°†æŸ¥æ‰¾æ‰€æœ‰æåŠå¸¸é‡ Real.sin å’Œ tsumã€åç§°åŒ…å« "two" å­ä¸²ã€ç±»å‹æŸå¤„åŒ…å«ä¹˜ç§¯å’Œå¹‚ï¼Œå¹¶å…·æœ‰ _ < _ å½¢å¼å‡è®¾çš„å¼•ç†ï¼ˆè‹¥å­˜åœ¨æ­¤ç±»å¼•ç†ï¼‰ã€‚å…ƒå˜é‡ï¼ˆ?aï¼‰åœ¨æ¯ä¸ªè¿‡æ»¤å™¨ä¸­ç‹¬ç«‹åˆ†é…ã€‚

## \#loogle
å®šä¹‰äº: `LeanSearchClient.just_loogle_cmd`

åœ¨ Lean å†…æœç´¢ [Loogle](https://loogle.lean-lang.org/json)ã€‚è¯¥å‘½ä»¤å¯ä½œä¸ºå‘½ä»¤ã€æœ¯è¯­æˆ–ç­–ç•¥ä½¿ç”¨ï¼Œå¦‚ä¸‹ä¾‹æ‰€ç¤ºã€‚åœ¨ç­–ç•¥æ¨¡å¼ä¸‹ï¼Œä»…æ˜¾ç¤ºæœ‰æ•ˆç­–ç•¥ã€‚

```lean
#loogle List ?a â†’ ?a

example := #loogle List ?a â†’ ?a

example : 3 â‰¤ 5 := by
  #loogle Nat.succ_le_succ
  sorry

```

## Loogle ä½¿ç”¨æ–¹å¼

Loogle é€šè¿‡å¤šç§æ–¹å¼æŸ¥æ‰¾å®šä¹‰å’Œå¼•ç†ï¼š

é€šè¿‡å¸¸é‡ï¼š
ğŸ” Real.sin
æŸ¥æ‰¾æ‰€æœ‰é™ˆè¿°ä¸­æåŠæ­£å¼¦å‡½æ•°çš„å¼•ç†ã€‚

é€šè¿‡å¼•ç†åç§°å­ä¸²ï¼š
ğŸ” "differ"
æŸ¥æ‰¾æ‰€æœ‰åç§°ä¸­åŒ…å« "differ" çš„å¼•ç†ã€‚

é€šè¿‡å­è¡¨è¾¾å¼ï¼š
ğŸ” _ * (_ ^ _)
æŸ¥æ‰¾æ‰€æœ‰é™ˆè¿°ä¸­æŸå¤„åŒ…å«ä¹˜ç§¯ä¸”ç¬¬äºŒä¸ªå‚æ•°ä¸ºæŸæ¬¡å¹‚çš„å¼•ç†ã€‚

æ¨¡å¼ä¹Ÿå¯éçº¿æ€§ï¼Œå¦‚ï¼š
ğŸ” Real.sqrt ?a * Real.sqrt ?a

è‹¥æ¨¡å¼å«æœ‰å‚æ•°ï¼Œåˆ™å‚æ•°ä»¥ä»»æ„é¡ºåºåŒ¹é…ã€‚ä»¥ä¸‹ä¸¤è€…å‡ä¼šæ‰¾åˆ° List.mapï¼š
ğŸ” (?a -> ?b) -> List ?a -> List ?b
ğŸ” List ?a -> (?a -> ?b) -> List ?b

é€šè¿‡ä¸»è¦ç»“è®ºï¼š
ğŸ” |- tsum _ = _ * tsum _
æŸ¥æ‰¾æ‰€æœ‰ç»“è®ºï¼ˆæ‰€æœ‰ â†’ å’Œ âˆ€ å³ä¾§çš„å­è¡¨è¾¾å¼ï¼‰å…·æœ‰ç»™å®šå½¢çŠ¶çš„å¼•ç†ã€‚

å¦‚å‰æ‰€è¿°ï¼Œè‹¥æ¨¡å¼å«æœ‰å‚æ•°ï¼Œåˆ™å‚æ•°ä»¥ä»»æ„é¡ºåºåŒ¹é…å¼•ç†çš„å‡è®¾ï¼›ä¾‹å¦‚ï¼Œ
ğŸ” |- _ < _ â†’ tsum _ < tsum _
å°†æ‰¾åˆ° tsum_lt_tsumï¼Œå³ä½¿å‡è®¾ f i < g i å¹¶éæœ€åã€‚

è‹¥ä¼ é€’å¤šä¸ªæœç´¢è¿‡æ»¤å™¨ï¼ˆä»¥é€—å·åˆ†éš”ï¼‰ï¼ŒLoogle å°†è¿”å›åŒ¹é…æ‰€æœ‰è¿‡æ»¤å™¨çš„å¼•ç†ã€‚æœç´¢
ğŸ” Real.sin, "two", tsum, _ * _, _ ^ _, |- _ < _ â†’ _
å°†æŸ¥æ‰¾æ‰€æœ‰æåŠå¸¸é‡ Real.sin å’Œ tsumã€åç§°åŒ…å« "two" å­ä¸²ã€ç±»å‹æŸå¤„åŒ…å«ä¹˜ç§¯å’Œå¹‚ï¼Œå¹¶å…·æœ‰ _ < _ å½¢å¼å‡è®¾çš„å¼•ç†ï¼ˆè‹¥å­˜åœ¨æ­¤ç±»å¼•ç†ï¼‰ã€‚å…ƒå˜é‡ï¼ˆ?aï¼‰åœ¨æ¯ä¸ªè¿‡æ»¤å™¨ä¸­ç‹¬ç«‹åˆ†é…ã€‚

## \#min_imports
å®šä¹‰äº: `Mathlib.Command.MinImports.minImpsStx`

`#min_imports in cmd` æ‰«æè¯­æ³• `cmd` åŠå…¶ç»è¯¦ç»†é˜è¿°åå¾—åˆ°çš„å£°æ˜ï¼Œä»¥å¯»æ‰¾ä¸€ç»„è¶³ä»¥ä½¿ `cmd` æ­£å¸¸å·¥ä½œçš„æœ€å°å¯¼å…¥é›†åˆã€‚

## \#min_imports
å®šä¹‰äº: `Mathlib.Command.MinImports.Â«command#min_importsIn_Â»`

`#min_imports in cmd` æ‰«æè¯­æ³• `cmd` åŠå…¶ç»è¯¦ç»†é˜è¿°åå¾—åˆ°çš„å£°æ˜ï¼Œä»¥å¯»æ‰¾ä¸€ç»„è¶³ä»¥ä½¿ `cmd` æ­£å¸¸å·¥ä½œçš„æœ€å°å¯¼å…¥é›†åˆã€‚

## \#min_imports
å®šä¹‰äº: `Â«command#min_importsÂ»`

å°è¯•é€šè¿‡åˆ†æå£°æ˜è®¡ç®—æ­¤æ–‡ä»¶æ‰€éœ€çš„æœ€å°å¯¼å…¥é›†åˆã€‚

æ­¤å‘½ä»¤éœ€åœ¨æ–‡ä»¶æœ«å°¾è¿è¡Œï¼Œä¸”ä¸æ„ŸçŸ¥è¯­æ³•ä¸ç­–ç•¥ï¼Œå› æ­¤ç»“æœå¯èƒ½ä»éœ€æ‰‹åŠ¨è°ƒæ•´ã€‚

## \#minimize_imports
å®šä¹‰äº: `Â«command#minimize_importsÂ»`


## \#moogle
å®šä¹‰äº: `LeanSearchClient.moogle_search_cmd`

åœ¨ Lean å†…éƒ¨æœç´¢ [Moogle](https://www.moogle.ai/api/search)ã€‚  
æŸ¥è¯¢åº”ä¸ºä»¥ `.` æˆ– `?` ç»“å°¾çš„å­—ç¬¦ä¸²ã€‚è¯¥å‘½ä»¤å¯ä½œä¸ºå‘½ä»¤ã€é¡¹æˆ–ç­–ç•¥ä½¿ç”¨ï¼Œå¦‚ä¸‹ä¾‹æ‰€ç¤ºã€‚åœ¨ç­–ç•¥æ¨¡å¼ä¸‹ï¼Œä»…æ˜¾ç¤ºæœ‰æ•ˆç­–ç•¥ã€‚

```lean
#moogle "è‹¥è‡ªç„¶æ•° n å°äº mï¼Œåˆ™ n çš„åç»§å°äº m çš„åç»§ã€‚"

example := #moogle "è‹¥è‡ªç„¶æ•° n å°äº mï¼Œåˆ™ n çš„åç»§å°äº m çš„åç»§ã€‚"

example : 3 â‰¤ 5 := by
  #moogle "è‹¥è‡ªç„¶æ•° n å°äº mï¼Œåˆ™ n çš„åç»§å°äº m çš„åç»§ã€‚"
  sorry
```

## \#norm_num
å®šä¹‰äº: `Mathlib.Tactic.normNumCmd`

åŸºç¡€ç”¨æ³•ä¸º `#norm_num e`ï¼Œå…¶ä¸­ `e` ä¸ºè¡¨è¾¾å¼ï¼Œå°†æ‰“å° `e` çš„ `norm_num` å½¢å¼ã€‚

è¯­æ³•ï¼š`#norm_num` (`only`)? (`[` åŒ–ç®€å¼•ç†åˆ—è¡¨ `]`)? `:`? è¡¨è¾¾å¼

æ­¤å‘½ä»¤æ¥å—ä¸ `#simp` ç›¸åŒçš„é€‰é¡¹ã€‚ä¾‹å¦‚å¯ä½¿ç”¨ `#norm_num [f, g] : e` æŒ‡å®šé¢å¤–åŒ–ç®€å¼•ç†ï¼ˆå†’å·å¯é€‰ä½†æœ‰åŠ©äºè§£æï¼‰ã€‚`only` é™åˆ¶ `norm_num` ä»…ä½¿ç”¨æä¾›çš„å¼•ç†ï¼Œå› æ­¤ `#norm_num only : e` è¡Œä¸ºç±»ä¼¼äº `norm_num1`ã€‚

ä¸ `norm_num` ä¸åŒï¼Œæ­¤å‘½ä»¤åœ¨æœªè¿›è¡Œä»»ä½•åŒ–ç®€æ—¶ä¸ä¼šå¤±è´¥ã€‚

`#norm_num` ç†è§£å±€éƒ¨å˜é‡ï¼Œå› æ­¤å¯åˆ©ç”¨å…¶å¼•å…¥å‚æ•°ã€‚

## \#parse
å®šä¹‰äº: `Mathlib.GuardExceptions.parseCmd`

`#parse parserFnId => str` å…è®¸æ•è·è§£æå¼‚å¸¸ã€‚  
`parserFnId` ä¸º `ParserFn` çš„æ ‡è¯†ç¬¦ï¼Œ`str` ä¸º `parserFnId` åº”è§£æçš„å­—ç¬¦ä¸²ã€‚

è‹¥è§£ææˆåŠŸï¼Œåˆ™è¾“å‡ºè¢«è®°å½•ï¼›è‹¥è§£æå¤±è´¥ï¼Œåˆ™è¾“å‡ºè¢«æ•è·ä¸ºå¼‚å¸¸ã€‚

æ— è®ºç»“æœå¦‚ä½•ï¼Œå‡å¯ä½¿ç”¨ `#guard_msgs` æ•è·è§£æé”™è¯¯ã€‚

ä¾‹å¦‚ï¼Œ`#parse` å¯å¦‚ä¸‹ä½¿ç”¨ï¼š
```lean
/-- error: <input>:1:3: Stacks æ ‡ç­¾å¿…é¡»ä¸º 4 ä¸ªå­—ç¬¦ -/
#guard_msgs in #parse Mathlib.Stacks.stacksTagFn => "A05"
```

## \#print
å®šä¹‰äº: `Batteries.Tactic.printPrefix`

å‘½ä»¤ `#print prefix foo` å°†æ‰“å°æ‰€æœ‰ä»¥å‘½åç©ºé—´ `foo` å¼€å¤´çš„å®šä¹‰ã€‚

ä¾‹å¦‚ï¼Œä»¥ä¸‹å‘½ä»¤å°†æ‰“å° `List` å‘½åç©ºé—´ä¸­çš„å®šä¹‰ï¼š

```lean
#print prefix List
```

`#print prefix` å¯é€šè¿‡ `PrintPrefixConfig` ä¸­çš„æ ‡å¿—è¿›è¡Œæ§åˆ¶ï¼Œè¿™äº›æ ‡å¿—æä¾›ç­›é€‰åç§°ä¸æ ¼å¼åŒ–çš„é€‰é¡¹ã€‚ä¾‹å¦‚ï¼Œé»˜è®¤æ’é™¤å†…éƒ¨åç§°ï¼Œä½†å¯é€šè¿‡é…ç½®è°ƒæ•´ï¼š
```lean
#print prefix (config := {internals := true}) List
```

é»˜è®¤æƒ…å†µä¸‹ï¼Œ`#print prefix` åœ¨æ¯ä¸ªåç§°åæ‰“å°ç±»å‹ã€‚å¯é€šè¿‡è®¾ç½® `showTypes` ä¸º `false` å…³é—­ï¼š
```lean
#print prefix (config := {showTypes := false}) List
```

å®Œæ•´æ ‡å¿—é›†å¯æŸ¥é˜… `Lean.Elab.Command.PrintPrefixConfig` æ–‡æ¡£ã€‚

## \#print
å®šä¹‰äº: `Lean.Parser.Command.printAxioms`


## \#print
å®šä¹‰äº: `Lean.Parser.Command.printTacTags`

æ˜¾ç¤ºæ‰€æœ‰å¯ç”¨ç­–ç•¥æ ‡ç­¾åŠå…¶æ–‡æ¡£ã€‚

## \#print
å®šä¹‰äº: `Batteries.Tactic.Â«command#printOpaques_Â»`

å‘½ä»¤ `#print opaques X` æ‰“å° `X` ä¾èµ–çš„æ‰€æœ‰ä¸é€æ˜å®šä¹‰ã€‚

ä¸é€æ˜å®šä¹‰åŒ…æ‹¬éƒ¨åˆ†å®šä¹‰ä¸å…¬ç†ã€‚ä»…åˆ—å‡ºè®¡ç®—ç›¸å…³ä¸Šä¸‹æ–‡ä¸­å‡ºç°çš„ä¾èµ–é¡¹ï¼Œè¯æ˜é¡¹å†…çš„å‡ºç°è¢«å¿½ç•¥ã€‚æ­¤å‘½ä»¤æœ‰åŠ©äºåˆ¤æ–­å®šä¹‰æ˜¯å¦å¯èƒ½ä¾èµ–å¹³å°ã€å¯èƒ½éƒ¨åˆ†æˆ–å¯èƒ½ä¸å¯è®¡ç®—ã€‚

ä¾‹å¦‚ï¼Œ`#print opaques Std.HashMap.insert` æ˜¾ç¤º `Std.HashMap.insert` ä¾èµ–äºä¸é€æ˜å®šä¹‰ `System.Platform.getNumBits` ä¸ `UInt64.toUSize`ã€‚å› æ­¤ `Std.HashMap.insert` åœ¨ 32 ä½æˆ– 64 ä½å¹³å°ç¼–è¯‘æ—¶å¯èƒ½æœ‰ä¸åŒè¡Œä¸ºã€‚

`#print opaques Stream.forIn` æ˜¾ç¤º `Stream.forIn` å¯èƒ½éƒ¨åˆ†ï¼Œå› å…¶ä¾èµ–éƒ¨åˆ†å®šä¹‰ `Stream.forIn.visit`ã€‚è‹¥è¾“å…¥æµæ— ç•Œï¼Œ`Stream.forIn` å¯èƒ½ä¸ç»ˆæ­¢ã€‚

`#print opaques Classical.choice` æ˜¾ç¤º `Classical.choice` è‡ªèº«ä¸ºä¸é€æ˜å®šä¹‰ï¼ˆå…¬ç†ï¼‰ã€‚è€Œ `#print opaques Classical.axiomOfChoice` æ— è¾“å‡ºï¼Œå› å…¶ä¸ºå‘½é¢˜æ•…è®¡ç®—æ— å…³ï¼ˆ`#print axioms` æ˜¾ç¤º `Classical.axiomOfChoice` ä¾èµ– `Classical.choice` å…¬ç†ï¼‰ã€‚

## \#print
å®šä¹‰äº: `Lean.Parser.Command.printEqns`


## \#print
å®šä¹‰äº: `Batteries.Tactic.Â«command#printDependents___Â»`

å‘½ä»¤ `#print dependents X Y` æ‰“å°æ–‡ä»¶ä¸­æ‰€æœ‰ä¼ é€’ä¾èµ–äº `X` æˆ– `Y` çš„å£°æ˜åˆ—è¡¨ã€‚æ¯ä¸ªå£°æ˜åæ˜¾ç¤ºå…¶ä½“ä¸­ç›´æ¥å¼•ç”¨ä¸”åŒæ ·ä¾èµ– `X` æˆ– `Y` çš„å£°æ˜åˆ—è¡¨ã€‚

ä¾‹å¦‚ï¼Œä¸‹æ–¹ `#print axioms bar'` æ˜¾ç¤º `bar'` ä¾èµ– `Classical.choice`ï¼Œä½†æœªè¯´æ˜åŸå› ã€‚`#print dependents Classical.choice` æŒ‡å‡º `bar'` ä¾èµ– `Classical.choice` å› å…¶ä½¿ç”¨ `foo`ï¼Œè€Œ `foo` ä½¿ç”¨ `Classical.em`ã€‚`bar` æœªè¢«åˆ—å‡ºå› å…¶è¯æ˜æœªä½¿ç”¨ `Classical.choice`ã€‚
```
import Batteries.Tactic.PrintDependents

theorem foo : x = y âˆ¨ x â‰  y := Classical.em _
theorem bar : 1 = 1 âˆ¨ 1 â‰  1 := by simp
theorem bar' : 1 = 1 âˆ¨ 1 â‰  1 := foo

#print axioms bar'
-- 'bar'' ä¾èµ–å…¬ç†: [Classical.choice, Quot.sound, propext]

#print dependents Classical.choice
-- foo: Classical.em
-- bar': foo
```

## \#print
å®šä¹‰äº: `Lean.Parser.Command.print`


## \#print_fun_prop_theorems
å®šä¹‰äº: `Mathlib.Meta.FunProp.Â«command#print_fun_prop_theorems__Â»`

æ‰“å°é™„åŠ äºæŸå‡½æ•°çš„æ‰€æœ‰å‡½æ•°å±æ€§çš„å‘½ä»¤ã€‚

ä¾‹å¦‚ï¼š
```
#print_fun_prop_theorems HAdd.hAdd
```
å¯èƒ½è¾“å‡ºï¼š
```
Continuous
  continuous_add, å‚æ•°: [4,5], ä¼˜å…ˆçº§: 1000
  continuous_add_left, å‚æ•°: [5], ä¼˜å…ˆçº§: 1000
  continuous_add_right, å‚æ•° [4], ä¼˜å…ˆçº§: 1000
  ...
Diferentiable
  Differentiable.add, å‚æ•°: [4,5], ä¼˜å…ˆçº§: 1000
  Differentiable.add_const, å‚æ•°: [4], ä¼˜å…ˆçº§: 1000
  Differentiable.const_add, å‚æ•°: [5], ä¼˜å…ˆçº§: 1000
  ...
```

ä¹Ÿå¯ä»…æŸ¥çœ‹ç‰¹å®šå‡½æ•°å±æ€§çš„å®šç†ï¼š
```
#print_fun_prop_theorems HAdd.hAdd Continuous
```

## \#push_neg
å®šä¹‰äº: `Mathlib.Tactic.PushNeg.pushNeg`

è¯­æ³•ä¸º `#push_neg e`ï¼Œå…¶ä¸­ `e` ä¸ºè¡¨è¾¾å¼ï¼Œå°†æ‰“å° `e` çš„ `push_neg` å½¢å¼ã€‚

`#push_neg` ç†è§£å±€éƒ¨å˜é‡ï¼Œå› æ­¤å¯åˆ©ç”¨å…¶å¼•å…¥å‚æ•°ã€‚

## \#reduce
å®šä¹‰äº: `Lean.reduceCmd`

`#reduce <è¡¨è¾¾å¼>` å°†è¡¨è¾¾å¼ `<è¡¨è¾¾å¼>` è§„çº¦è‡³å…¶æ­£è§„å½¢å¼ã€‚æ­¤è¿‡ç¨‹æ¶‰åŠåº”ç”¨è§„çº¦è§„åˆ™ç›´è‡³æ— æ³•ç»§ç»­è§„çº¦ã€‚

é»˜è®¤æƒ…å†µä¸‹ï¼Œè¡¨è¾¾å¼ä¸­çš„è¯æ˜ä¸ç±»å‹ä¸è¢«è§„çº¦ã€‚ä½¿ç”¨ä¿®é¥°ç¬¦ `(proofs := true)` ä¸ `(types := true)` å¯è§„çº¦ä¹‹ã€‚æ³¨æ„å‘½é¢˜åœ¨ Lean ä¸­ä¸ºç±»å‹ã€‚

**è­¦å‘Šï¼š** æ­¤æ“ä½œå¯èƒ½è®¡ç®—é‡è¾ƒå¤§ï¼Œå°¤å…¶å¯¹äºå¤æ‚è¡¨è¾¾å¼ã€‚

å»ºè®®å¯¹ç®€å•è¡¨è¾¾å¼ä½¿ç”¨ `#eval <è¡¨è¾¾å¼>` è¿›è¡Œæ±‚å€¼/æ‰§è¡Œã€‚

## \#reset_min_imports
å®šä¹‰äº: `Mathlib.Linter.Â«command#reset_min_importsÂ»`

`#reset_min_imports` å°†å½“å‰ç´¯ç§¯çš„å¯¼å…¥åˆ—è¡¨è®¾ç½®ä¸ºç©ºã€‚

## \#sample
å®šä¹‰äº: `Plausible.Â«command#sample_Â»`

`#sample type`ï¼Œå…¶ä¸­ `type` å…·æœ‰ `SampleableExt` çš„å®ä¾‹ï¼Œä½¿ç”¨é€’å¢çš„å¤§å°å‚æ•°æ‰“å°åæ¬¡ `type` ç±»å‹çš„éšæœºå€¼ã€‚

```lean
#sample Nat
-- è¾“å‡º
-- 0
-- 0
-- 2
-- 24
-- 64
-- 76
-- 5
-- 132
-- 8
-- 449
-- æˆ–å…¶ä»–æ•°å­—åºåˆ—

#sample List Int
-- è¾“å‡º
-- []
-- [1, 1]
-- [-7, 9, -6]
-- [36]
-- [-500, 105, 260]
-- [-290]
-- [17, 156]
-- [-2364, -7599, 661, -2411, -3576, 5517, -3823, -968]
-- [-643]
-- [11892, 16329, -15095, -15461]
-- æˆ–å…¶ä»–å†…å®¹
```

## \#search
å®šä¹‰äº: `LeanSearchClient.search_cmd`

æ ¹æ®é€‰é¡¹ `leansearchclient.backend` çš„è®¾ç½®ï¼Œåœ¨ Lean ä¸­æœç´¢ [Moogle](https://www.moogle.ai/api/search) æˆ– [LeanSearch](https://leansearch.net/)ã€‚æŸ¥è¯¢åº”ä¸ºä»¥ `.` æˆ– `?` ç»“å°¾çš„å­—ç¬¦ä¸²ã€‚è¯¥å‘½ä»¤å¯ä½œä¸ºå‘½ä»¤ã€é¡¹å’Œç­–ç•¥ä½¿ç”¨ï¼Œå¦‚ä¸‹ä¾‹æ‰€ç¤ºã€‚åœ¨ç­–ç•¥æ¨¡å¼ä¸‹ï¼Œä»…æ˜¾ç¤ºæœ‰æ•ˆçš„ç­–ç•¥ã€‚

```lean
#search "è‹¥è‡ªç„¶æ•° n å°äº mï¼Œåˆ™ n çš„åç»§å°äº m çš„åç»§ã€‚"

example := #search "è‹¥è‡ªç„¶æ•° n å°äº mï¼Œåˆ™ n çš„åç»§å°äº m çš„åç»§ã€‚"

example : 3 â‰¤ 5 := by
  #search "è‹¥è‡ªç„¶æ•° n å°äº mï¼Œåˆ™ n çš„åç»§å°äº m çš„åç»§ã€‚"
  sorry
```
åœ¨ç­–ç•¥æ¨¡å¼ä¸‹ï¼Œè‹¥æœªæä¾›æŸ¥è¯¢å­—ç¬¦ä¸²ï¼Œåˆ™åŸºäºç›®æ ‡çŠ¶æ€æŸ¥è¯¢ [LeanStateSearch](https://premise-search.com)ã€‚

## \#show_kind
å®šä¹‰äº: `Mathlib.Linter.UnusedTactic.Â«command#show_kind_Â»`

`#show_kind tac` æ¥å—ä¸€ä¸ªç­–ç•¥çš„è¯­æ³•ä½œä¸ºè¾“å…¥ï¼Œå¹¶è¿”å›è¯¥ç­–ç•¥è¯­æ³•æ ‘å¤´éƒ¨çš„ `SyntaxNodeKind`ã€‚

è¾“å…¥çš„è¯­æ³•éœ€è¦å¯è§£æï¼Œä½†å¯ä»¥*æå…¶*ç®€ç•¥ã€‚ä¾‹å¦‚ï¼Œè¦æŸ¥çœ‹ `refine` ç­–ç•¥çš„ `SyntaxNodeKind`ï¼Œå¯ä»¥ä½¿ç”¨ï¼š
```lean
#show_kind refine _
```
å°¾éšçš„ä¸‹åˆ’çº¿ `_` ä½¿è¯­æ³•æœ‰æ•ˆï¼Œå› ä¸º `refine` é¢„æœŸæœ‰å…¶ä»–å†…å®¹ã€‚

## \#show_unused
å®šä¹‰äº: `Batteries.Tactic.ShowUnused.Â«command#show_unused___Â»`

`#show_unused decl1 decl2 ..` å°†é«˜äº®å½“å‰æ–‡ä»¶ä¸­æœªå‚ä¸å£°æ˜ `decl1`ã€`decl2` ç­‰å®šä¹‰çš„æ‰€æœ‰å®šç†æˆ–å®šä¹‰ã€‚ç»“æœæ—¢æ˜¾ç¤ºåœ¨ `#show_unused` çš„æ¶ˆæ¯ä¸­ï¼Œä¹Ÿæ˜¾ç¤ºåœ¨å£°æ˜æœ¬èº«ä¸Šã€‚
```lean
def foo := 1
def baz := 2
def bar := foo
#show_unused bar -- é«˜äº® `baz`
```

## \#simp
å®šä¹‰äº: `Mathlib.Tactic.Conv.Â«command#simpOnly_=>__Â»`

* `#simp => e` å¯¹è¡¨è¾¾å¼ `e` è¿è¡Œ `simp`ï¼Œå¹¶æ˜¾ç¤ºç®€åŒ–åçš„ç»“æœè¡¨è¾¾å¼ã€‚
* `#simp only [lems] => e` å¯¹ `e` è¿è¡Œ `simp only [lems]`ã€‚
* `=>` æ˜¯å¯é€‰çš„ï¼Œå› æ­¤ `#simp e` å’Œ `#simp only [lems] e` è¡Œä¸ºç›¸åŒã€‚ä¸»è¦ç”¨äºæ¶ˆé™¤è¡¨è¾¾å¼ `e` ä¸å¼•ç†ä¹‹é—´çš„æ­§ä¹‰ã€‚

## \#stacks_tags
å®šä¹‰äº: `Mathlib.StacksTag.stacksTags`

`#stacks_tags` æ£€ç´¢æ‰€æœ‰å…·æœ‰ `stacks` å±æ€§çš„å£°æ˜ã€‚

å¯¹äºæ¯ä¸ªæ‰¾åˆ°çš„å£°æ˜ï¼Œæ‰“å°ä¸€è¡Œï¼š
```
'declaration_name' å¯¹åº”äºæ ‡ç­¾ 'declaration_tag'ã€‚
```
å˜ä½“ `#stacks_tags!` åœ¨æ¯ä¸ªæ‘˜è¦è¡Œåæ·»åŠ å®šç†é™ˆè¿°ã€‚

## \#string_diagram
å®šä¹‰äº: `Mathlib.Tactic.Widget.stringDiagram`

æ˜¾ç¤ºç»™å®šé¡¹çš„å¼¦å›¾ã€‚

ç¤ºä¾‹ç”¨æ³•ï¼š
```lean
/- ç­‰å¼å®šç†çš„å¼¦å›¾ã€‚ -/
#string_diagram MonoidalCategory.whisker_exchange

/- æ€å°„çš„å¼¦å›¾ã€‚ -/
variable {C : Type u} [Category.{v} C] [MonoidalCategory C] {X Y : C} (f : ğŸ™_ C âŸ¶ X âŠ— Y) in
#string_diagram f
```

## \#synth
å®šä¹‰äº: `Lean.Parser.Command.synth`


## \#test
å®šä¹‰äº: `Plausible.Â«command#test_Â»`


## \#time
å®šä¹‰äº: `Lean.Parser.timeCmd`

è®¡æ—¶å‘½ä»¤çš„è¯¦ç»†é˜è¿°ï¼Œå¹¶æ‰“å°ç»“æœï¼ˆä»¥æ¯«ç§’ä¸ºå•ä½ï¼‰ã€‚

ç¤ºä¾‹ç”¨æ³•ï¼š
```lean
set_option maxRecDepth 100000 in
#time example : (List.range 500).length = 500 := rfl
```

## \#trans_imports
å®šä¹‰äº: `transImportsStx`

`#trans_imports` æŠ¥å‘Šå½“å‰æ¨¡å—æœ‰å¤šå°‘ä¸ªä¼ é€’æ€§å¯¼å…¥ã€‚è¯¥å‘½ä»¤æ¥å—å¯é€‰çš„å­—ç¬¦ä¸²è¾“å…¥ï¼š`#trans_imports str` è¿˜æ˜¾ç¤ºåç§°ä»¥ `str` å¼€å¤´çš„ä¼ é€’æ€§å¯¼å…¥æ¨¡å—ã€‚

ä¸»è¦ç”¨äºæµ‹è¯•ï¼Œè¯¥å‘½ä»¤è¿˜æ¥å—å¯é€‰çš„ `at_most x` è¾“å…¥ï¼šè‹¥å¯¼å…¥æ•°é‡ä¸è¶…è¿‡ `x`ï¼Œåˆ™æ¶ˆæ¯æ¶‰åŠ `x`ï¼Œè€Œéå®é™…å¯èƒ½å˜åŒ–çš„å¯¼å…¥æ•°é‡ã€‚

## \#unfold?
å®šä¹‰äº: `Mathlib.Tactic.InteractiveUnfold.unfoldCommand`

`#unfold? e` æ˜¾ç¤º `e` çš„æ‰€æœ‰å±•å¼€ã€‚åœ¨ç­–ç•¥æ¨¡å¼ä¸‹ï¼Œè¯·ä½¿ç”¨ `unfold?`ã€‚

## \#version
å®šä¹‰äº: `Lean.Parser.Command.version`

æ˜¾ç¤ºå½“å‰ Lean ç‰ˆæœ¬ã€‚æ‰“å° `Lean.versionString`ã€‚

## \#where
å®šä¹‰äº: `Lean.Parser.Command.where`

`#where` æè¿°å½“å‰ä½œç”¨åŸŸçš„çŠ¶æ€ã€‚åŒ…æ‹¬å½“å‰å‘½åç©ºé—´ã€`open` çš„å‘½åç©ºé—´ã€`universe` å’Œ `variable` å‘½ä»¤ï¼Œä»¥åŠé€šè¿‡ `set_option` è®¾ç½®çš„é€‰é¡¹ã€‚

## \#whnf
å®šä¹‰äº: `Mathlib.Tactic.Conv.Â«command#whnf_Â»`

å‘½ä»¤ `#whnf e` å°† `e` æ±‚å€¼è‡³å¼±å¤´èŒƒå¼ï¼ˆWHNFï¼‰ï¼Œå³è¡¨è¾¾å¼çš„â€œå¤´â€è¢«çº¦ç®€è‡³åŸè¯­â€”â€”lambda æˆ– forallï¼Œæˆ–å…¬ç†æˆ–å½’çº³ç±»å‹ã€‚ç±»ä¼¼äº `#reduce e`ï¼Œä½†ä¸ä¼šå®Œå…¨çº¦ç®€è¡¨è¾¾å¼ï¼Œä»…æš´éœ²ç¬¬ä¸€ä¸ªæ„é€ å­ã€‚ä¾‹å¦‚ï¼š
```lean
open Nat List
set_option pp.notation false
#whnf [1, 2, 3].map succ
-- cons (succ 1) (map succ (cons 2 (cons 3 nil)))
#reduce [1, 2, 3].map succ
-- cons 2 (cons 3 (cons 4 nil))
```
è¯¥è¡¨è¾¾å¼çš„å¤´ä¸º `List.cons` æ„é€ å­ï¼Œå› æ­¤å¯çœ‹å‡ºåˆ—è¡¨éç©ºï¼Œä½†å­é¡¹ `Nat.succ 1` å’Œ `List.map Nat.succ (List.cons 2 (List.cons 3 List.nil))` ä»æœªè¢«æ±‚å€¼ã€‚`#reduce` ç­‰æ•ˆäºå¯¹æ‰€æœ‰å­é¡¹ä½¿ç”¨ `#whnf`ã€‚

## \#whnfR
å®šä¹‰äº: `Mathlib.Tactic.Conv.Â«command#whnfR_Â»`

å‘½ä»¤ `#whnfR e` ä»¥å¯çº¦é€æ˜æ€§å°† `e` æ±‚å€¼è‡³å¼±å¤´èŒƒå¼ï¼Œå³ä½¿ç”¨ `whnf` ä½†ä»…å±•å¼€å¯çº¦å®šä¹‰ã€‚

## \#widget
å®šä¹‰äº: `Lean.Widget.widgetCmd`

ä½¿ç”¨ `#widget <widget>` æ˜¾ç¤ºé¢æ¿å°éƒ¨ä»¶ï¼Œä½¿ç”¨ `#widget <widget> with <props>` æ˜¾ç¤ºå¸¦æœ‰ç»™å®šå±æ€§ï¼ˆpropsï¼‰çš„å°éƒ¨ä»¶ã€‚ç”¨äºè°ƒè¯•å°éƒ¨ä»¶ã€‚

`<widget>` çš„ç±»å‹å¿…é¡»å®ç° `Widget.ToModule`ï¼Œ`<props>` çš„ç±»å‹å¿…é¡»å®ç° `Server.RpcEncodable`ã€‚ç‰¹åˆ«æ˜¯ï¼Œ`<props> : Json` æœ‰æ•ˆã€‚

## %reset_grind_attrs
å®šä¹‰äº: `Lean.Parser.resetGrindAttrs`

é‡ç½®æ‰€æœ‰ `grind` å±æ€§ã€‚æ­¤å‘½ä»¤ä»…ä¾›æµ‹è¯•ä½¿ç”¨ï¼Œä¸åº”ç”¨äºåº”ç”¨ç¨‹åºã€‚

## /-!
å®šä¹‰äº: `Lean.Parser.Command.moduleDoc`

`/-! <text> -/` å®šä¹‰å¯è¢«æ–‡æ¡£ç”Ÿæˆå·¥å…·æ˜¾ç¤ºçš„*æ¨¡å—æ–‡æ¡£å­—ç¬¦ä¸²*ã€‚è¯¥å­—ç¬¦ä¸²ä¸æ–‡ä»¶ä¸­çš„å¯¹åº”ä½ç½®å…³è”ã€‚å¯åœ¨åŒä¸€æ–‡ä»¶ä¸­å¤šæ¬¡ä½¿ç”¨ã€‚

## add_aesop_rules
å®šä¹‰äº: `Aesop.Frontend.Parser.addRules`


## add_decl_doc
å®šä¹‰äº: `Lean.Parser.Command.addDocString`

å‘ç°æœ‰å£°æ˜æ·»åŠ æ–‡æ¡£å­—ç¬¦ä¸²ï¼Œæ›¿æ¢ä»»ä½•ç°æœ‰æ–‡æ¡£å­—ç¬¦ä¸²ã€‚æä¾›çš„æ–‡æ¡£å­—ç¬¦ä¸²åº”ä½œä¸º `add_decl_doc` å‘½ä»¤çš„æ–‡æ¡£å­—ç¬¦ä¸²ç¼–å†™ï¼Œå¦‚ï¼š
```
/-- æˆ‘çš„æ–°æ–‡æ¡£å­—ç¬¦ä¸² -/
add_decl_doc oldDeclaration
```

è¿™é€‚ç”¨äºè‡ªåŠ¨ç”Ÿæˆçš„å£°æ˜ï¼Œå…¶æºä»£ç ä¸­æ— å¤„ç¼–å†™æ–‡æ¡£å­—ç¬¦ä¸²ã€‚

ç»“æ„ä¸­çš„çˆ¶æŠ•å½±å³ä¸ºä¸€ä¾‹ï¼š
```lean
structure Triple (Î± Î² Î³ : Type) extends Prod Î± Î² where
  thrd : Î³

/-- æå–ä¸‰å…ƒç»„çš„å‰ä¸¤ä¸ªæŠ•å½±ã€‚ -/
add_decl_doc Triple.toProd
```

æ–‡æ¡£ä»…å¯æ·»åŠ è‡³åŒä¸€æ¨¡å—ä¸­çš„å£°æ˜ã€‚

## alias
å®šä¹‰äº: `Batteries.Tactic.Alias.alias`

å‘½ä»¤ `alias name := target` åˆ›å»º `target` çš„åŒä¹‰è¯ï¼Œä½¿ç”¨ç»™å®šåç§°ã€‚

å‘½ä»¤ `alias âŸ¨fwd, revâŸ© := target` ä¸º iff å®šç†çš„æ­£å‘å’Œåå‘åˆ›å»ºåŒä¹‰è¯ã€‚è‹¥ä»…éœ€ä¸€ä¸ªæ–¹å‘ï¼Œä½¿ç”¨ `_`ã€‚

è¿™äº›å‘½ä»¤æ¥å—æ‰€æœ‰ä¸`def`å’Œ`theorem`ç›¸åŒçš„ä¿®é¥°ç¬¦å’Œå±æ€§ã€‚

## alias
å®šä¹‰äºï¼š`Batteries.Tactic.Alias.aliasLR`

å‘½ä»¤`alias name := target`åˆ›å»º`target`çš„åŒä¹‰è¯`name`ã€‚

å‘½ä»¤`alias âŸ¨fwd, revâŸ© := target`ä¸ºiffå®šç†çš„æ­£å‘å’Œåå‘åˆ›å»ºåŒä¹‰è¯ã€‚å¦‚æœåªéœ€è¦ä¸€ä¸ªæ–¹å‘ï¼Œä½¿ç”¨`_`ã€‚

è¿™äº›å‘½ä»¤æ¥å—æ‰€æœ‰ä¸`def`å’Œ`theorem`ç›¸åŒçš„ä¿®é¥°ç¬¦å’Œå±æ€§ã€‚

## assert_exists
å®šä¹‰äºï¼š`commandAssert_exists_`

`assert_exists n`æ˜¯ä¸€ä¸ªç”¨æˆ·å‘½ä»¤ï¼Œç”¨äºæ–­è¨€å½“å‰å¯¼å…¥ä½œç”¨åŸŸä¸­å­˜åœ¨åä¸º`n`çš„å£°æ˜ã€‚

æ³¨æ„ä½¿ç”¨åç§°ï¼ˆå¦‚`Rat`ï¼‰è€Œéç¬¦å·ï¼ˆå¦‚`â„š`ï¼‰ã€‚

## assert_no_sorry
å®šä¹‰äºï¼š`commandAssert_no_sorry_`

å¦‚æœç»™å®šæ ‡è¯†ç¬¦ä½¿ç”¨äº†`sorryAx`ï¼Œåˆ™æŠ›å‡ºé”™è¯¯ã€‚

## assert_not_exists
å®šä¹‰äºï¼š`commandAssert_not_exists_`

`assert_not_exists dâ‚ dâ‚‚ ... dâ‚™`æ˜¯ä¸€ä¸ªç”¨æˆ·å‘½ä»¤ï¼Œç”¨äºæ–­è¨€å½“å‰å¯¼å…¥ä½œç”¨åŸŸä¸­*ä¸å­˜åœ¨*åä¸º`dâ‚ dâ‚‚ ... dâ‚™`çš„å£°æ˜ã€‚

æ³¨æ„ä½¿ç”¨åç§°ï¼ˆå¦‚`Rat`ï¼‰è€Œéç¬¦å·ï¼ˆå¦‚`â„š`ï¼‰ã€‚

åœ¨mathlibä¸­å¯èƒ½ï¼ˆè°¨æ…åœ°ï¼ï¼‰ç”¨äºå¼ºåˆ¶æ‰§è¡ŒæŸäº›æ–‡ä»¶ç›¸äº’ç‹¬ç«‹çš„è®¡åˆ’ã€‚

å¦‚æœåœ¨å¼€å‘mathlibæ—¶é‡åˆ°`assert_not_exists`å‘½ä»¤çš„é”™è¯¯ï¼Œå¯èƒ½æ˜¯å› ä¸ºæ‚¨å‘æ–‡ä»¶å¼•å…¥äº†æ–°çš„å¯¼å…¥ä¾èµ–é¡¹ã€‚

åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ‚¨åº”é‡æ„æ‚¨çš„å·¥ä½œï¼ˆä¾‹å¦‚é€šè¿‡åˆ›å»ºæ–°æ–‡ä»¶è€Œéå‘ç°æœ‰æ–‡ä»¶æ·»åŠ å¯¼å…¥ï¼‰ã€‚æ‚¨*ä¸åº”*æœªç»äº‹å…ˆä»”ç»†è®¨è®ºå°±åˆ é™¤`assert_not_exists`è¯­å¥ã€‚

`assert_not_exists`è¯­å¥é€šå¸¸åº”ä½äºæ–‡ä»¶é¡¶éƒ¨ï¼Œæ¨¡å—æ–‡æ¡£ä¹‹åã€‚

## assert_not_imported
å®šä¹‰äºï¼š`commandAssert_not_imported_`

`assert_not_imported mâ‚ mâ‚‚ ... mâ‚™`æ£€æŸ¥æ¨¡å—`mâ‚ mâ‚‚ ... mâ‚™`ä¸­çš„æ¯ä¸€ä¸ªéƒ½ä¸åœ¨å½“å‰æ–‡ä»¶çš„ä¼ é€’å¯¼å…¥ä¸­ã€‚

è¯¥å‘½ä»¤å½“å‰ä¸æ£€æŸ¥æ¨¡å—`mâ‚ mâ‚‚ ... mâ‚™`æ˜¯å¦å®é™…å­˜åœ¨ã€‚

## attribute
å®šä¹‰äºï¼š`Lean.Parser.Command.attribute`


## binder_predicate
å®šä¹‰äºï¼š`Lean.Parser.Command.binderPredicate`

å£°æ˜ä¸€ä¸ªç»‘å®šå™¨è°“è¯ã€‚ä¾‹å¦‚ï¼š
```lean
binder_predicate x " > " y:term => `($x > $y)
```

## builtin_dsimproc
å®šä¹‰äºï¼š`Lean.Parser.Â«command__Builtin_dsimproc__[_]_(_):=_Â»`

ä¸€ä¸ªå†…ç½®çš„defeqç®€åŒ–è¿‡ç¨‹ã€‚

## builtin_dsimproc_decl
å®šä¹‰äºï¼š`Lean.Parser.Â«command_Builtin_dsimproc_decl_(_):=_Â»`

ä¸€ä¸ªå†…ç½®çš„defeqç®€åŒ–è¿‡ç¨‹å£°æ˜ã€‚

## builtin_grind_propagator
å®šä¹‰äºï¼š`Lean.Parser.Â«command_Builtin_grind_propagator____:=_Â»`

ä¸€ä¸ªä¸º`grind`ç­–ç•¥è®¾è®¡çš„å†…ç½®ä¼ æ’­å™¨ã€‚

## builtin_simproc
å®šä¹‰äºï¼š`Lean.Parser.Â«command__Builtin_simproc__[_]_(_):=_Â»`

ä¸€ä¸ªå†…ç½®çš„ç®€åŒ–è¿‡ç¨‹ã€‚

## builtin_simproc_decl
å®šä¹‰äºï¼š`Lean.Parser.Â«command_Builtin_simproc_decl_(_):=_Â»`

ä¸€ä¸ªå†…ç½®çš„ç®€åŒ–è¿‡ç¨‹å£°æ˜ã€‚

## builtin_simproc_pattern%
å®šä¹‰äºï¼š`Lean.Parser.simprocPatternBuiltin`

å°†æ¨¡å¼ä¸å†…ç½®ç®€åŒ–è¿‡ç¨‹å…³è”çš„è¾…åŠ©å‘½ä»¤ã€‚

## class
å®šä¹‰äºï¼š`Lean.Parser.Command.classAbbrev`

å°†
```
class abbrev C <params> := D_1, ..., D_n
```
æ‰©å±•ä¸º
```
class C <params> extends D_1, ..., D_n
attribute [instance] C.mk
```

## compile_def%
å®šä¹‰äºï¼š`Mathlib.Util.Â«commandCompile_def%_Â»`

`compile_def% Foo.foo`ä¸ºå®šä¹‰`Foo.foo`æ·»åŠ ç¼–è¯‘ä»£ç ã€‚è¿™å¯ç”¨äºç±»å‹ç±»æŠ•å½±æˆ–åƒ`List._sizeOf_1`è¿™æ ·çš„å®šä¹‰ï¼Œé»˜è®¤æƒ…å†µä¸‹Leanä¸ä¼šä¸ºè¿™äº›ç”Ÿæˆç¼–è¯‘ä»£ç ï¼ˆå› ä¸º99%çš„æ—¶é—´ä¸ä¼šä½¿ç”¨å®ƒä»¬ï¼‰ã€‚

## compile_inductive%
å®šä¹‰äºï¼š`Mathlib.Util.Â«commandCompile_inductive%_Â»`

`compile_inductive% Foo`ä¸ºé€’å½’å™¨`Foo.rec`åˆ›å»ºç¼–è¯‘ä»£ç ï¼Œä»¥ä¾¿åœ¨å®šä¹‰ä¸­ä½¿ç”¨`Foo.rec`è€Œæ— éœ€å°†å®šä¹‰æ ‡è®°ä¸º`noncomputable`ã€‚

## count_heartbeats
å®šä¹‰äºï¼š`Mathlib.CountHeartbeats.commandCount_heartbeats`

`count_heartbeats`è‡ª"2025-01-12"èµ·å·²å¼ƒç”¨ï¼Œæ¨èä½¿ç”¨`#count_heartbeats`

## declare_aesop_rule_sets
å®šä¹‰äºï¼š`Aesop.Frontend.Parser.declareRuleSets`


## declare_bitwise_int_theorems
å®šä¹‰äºï¼š`commandDeclare_bitwise_int_theorems__`


## declare_bitwise_uint_theorems
å®šä¹‰äºï¼š`commandDeclare_bitwise_uint_theorems__`


## declare_command_config_elab
å®šä¹‰äºï¼š`Lean.Elab.Tactic.commandConfigElab`


## declare_config_elab
å®šä¹‰äºï¼š`Lean.Elab.Tactic.configElab`


## declare_int_theorems
å®šä¹‰äºï¼š`commandDeclare_int_theorems__`


## declare_simp_like_tactic
å®šä¹‰äºï¼š`Lean.Parser.Tactic.declareSimpLikeTactic`


## declare_syntax_cat
å®šä¹‰äºï¼š`Lean.Parser.Command.syntaxCat`


## declare_uint_simprocs
å®šä¹‰äºï¼š`commandDeclare_uint_simprocs_`


## declare_uint_theorems
å®šä¹‰äºï¼š`commandDeclare_uint_theorems__`


## deprecate
å®šä¹‰äºï¼š`Mathlib.Tactic.DeprecateTo.commandDeprecateTo______`

ç¼–å†™
```lean
deprecate to new_name new_nameâ‚‚ ... new_nameâ‚™
theorem old_name : True := .intro
```
å…¶ä¸­`new_name new_nameâ‚‚ ... new_nameâ‚™`æ˜¯ä¸€ç³»åˆ—æ ‡è¯†ç¬¦ï¼Œç”Ÿæˆ`Try this`å»ºè®®ï¼š
```lean
theorem new_name : True := .intro

@[deprecated (since := "YYYY-MM-DD")] alias old_name := new_name

@[deprecated (since := "YYYY-MM-DD")] alias old_nameâ‚‚ := new_nameâ‚‚
...

@[deprecated (since := "YYYY-MM-DD")] alias old_nameâ‚™ := new_nameâ‚™
```
å…¶ä¸­`old_name old_nameâ‚‚ ... old_nameâ‚™`æ˜¯åˆå§‹å‘½ä»¤ç”Ÿæˆçš„æœªé»‘åå•å£°æ˜ã€‚

"YYYY-MM-DD"æ¡ç›®æ˜¯ä»Šå¤©çš„æ—¥æœŸï¼Œè‡ªåŠ¨å¡«å……ã€‚

`deprecate to`åŠªåŠ›å°†`old_name`ï¼ˆâ€œå¯è§â€åç§°ï¼‰ä¸ç”¨æˆ·ç”Ÿæˆçš„ç¬¬ä¸€ä¸ªæ ‡è¯†ç¬¦`new_name`åŒ¹é…ã€‚æ—§çš„è‡ªåŠ¨ç”Ÿæˆå£°æ˜`old_nameâ‚‚ ... old_nameâ‚™`æŒ‰å­—æ¯é¡ºåºæ£€ç´¢ã€‚åœ¨åˆå§‹å£°æ˜æœ€å¤šç”Ÿæˆä¸€ä¸ªéé»‘åå•å£°æ˜çš„æƒ…å†µä¸‹ï¼Œå­—æ¯æ’åºæ— å…³ç´§è¦ã€‚

æŠ€æœ¯ä¸Šï¼Œè¯¥å‘½ä»¤è¿˜æ¥å—ä¸€ä¸ªå¯é€‰çš„`String`å‚æ•°æ¥å¡«å……`since`ä¸­çš„æ—¥æœŸã€‚ä½†ä¸»è¦ç”¨äºè°ƒè¯•ç›®çš„ï¼Œå› ä¸ºå˜é‡æ—¥æœŸä¼šå¯¼è‡´æµ‹è¯•æ—¶é—´ä¾èµ–ã€‚

## deriving
å®šä¹‰äºï¼š`Lean.Parser.Command.deriving`


## dsimproc
å®šä¹‰äºï¼š`Lean.Parser.Â«command__Dsimproc__[_]_(_):=_Â»`

ç±»ä¼¼äº`simproc`ï¼Œä½†ç»“æœè¡¨è¾¾å¼å¿…é¡»ä¸è¾“å…¥è¡¨è¾¾å¼åœ¨å®šä¹‰ä¸Šç›¸ç­‰ã€‚

## dsimproc_decl
å®šä¹‰äºï¼š`Lean.Parser.Â«command_Dsimproc_decl_(_):=_Â»`

ç”¨æˆ·å®šä¹‰çš„defeqç®€åŒ–è¿‡ç¨‹å£°æ˜ã€‚è¦åœ¨`simp`ç­–ç•¥ä¸­æ¿€æ´»æ­¤è¿‡ç¨‹ï¼Œå¿…é¡»å°†å…¶ä½œä¸ºå‚æ•°æä¾›ï¼Œæˆ–ä½¿ç”¨`attribute`å‘½ä»¤è®¾ç½®å…¶`[simproc]`å±æ€§ã€‚

## elab
å®šä¹‰äºï¼š`Lean.Parser.Command.elab`


## elab_rules
å®šä¹‰äºï¼š`Lean.Parser.Command.elab_rules`


## elab_stx_quot
å®šä¹‰äºï¼š`Lean.Elab.Term.Quotation.commandElab_stx_quot_`


## end
å®šä¹‰äºï¼š`Lean.Parser.Command.end`

`end`å…³é—­`section`æˆ–`namespace`ä½œç”¨åŸŸã€‚å¦‚æœä½œç”¨åŸŸåä¸º`<id>`ï¼Œåˆ™å¿…é¡»ä½¿ç”¨`end <id>`å…³é—­ã€‚æ–‡ä»¶æœ«å°¾çš„`end`å‘½ä»¤æ˜¯å¯é€‰çš„ã€‚

## erase_aesop_rules
å®šä¹‰äºï¼š`Aesop.Frontend.Parser.eraseRules`


## export
å®šä¹‰äºï¼š`Lean.Parser.Command.export`

å°†å…¶ä»–å‘½åç©ºé—´çš„åç§°æ·»åŠ åˆ°å½“å‰å‘½åç©ºé—´ã€‚

å‘½ä»¤`export Some.Namespace (nameâ‚ nameâ‚‚)`ä½¿`nameâ‚`å’Œ`nameâ‚‚`ï¼š

- åœ¨å½“å‰å‘½åç©ºé—´ä¸­æ— éœ€å‰ç¼€`Some.Namespace`å³å¯è§ï¼Œç±»ä¼¼`open`ï¼Œä¸”
- ä»å½“å‰å‘½åç©ºé—´`N`å¤–éƒ¨å¯è§ä¸º`N.nameâ‚`å’Œ`N.nameâ‚‚`ã€‚

ç¤ºä¾‹ï¼š

```lean
namespace Morning.Sky
  def star := "venus"
end Morning.Sky

namespace Evening.Sky
  export Morning.Sky (star)
  -- `star`ç°åœ¨åœ¨ä½œç”¨åŸŸå†…
  #check star
end Evening.Sky

-- `star`åœ¨`Evening.Sky`ä¸­å¯è§
#check Evening.Sky.star
```

## export
å®šä¹‰äºï¼š`Lean.Elab.Command.exportPrivate`

å‘½ä»¤`export private a b c in foo bar`ç±»ä¼¼äº`open private`ï¼Œä½†ä¸ä¼šåœ¨å½“å‰ä½œç”¨åŸŸå†…æ‰“å¼€å®ƒä»¬ï¼Œè€Œæ˜¯åˆ›å»ºæŒ‡å‘ç§æœ‰å®šä¹‰çš„å…¬å…±åˆ«åã€‚è¯¥å®šä¹‰å°†å­˜åœ¨äºåŸå§‹ä½ç½®å’Œåç§°ï¼Œå¦‚åŒæœ€åˆæœªä½¿ç”¨`private`å…³é”®å­—ã€‚

å®ƒè¿˜ä¼šåœ¨æä¾›çš„çŸ­åç§°ä¸‹æ‰“å¼€æ–°åˆ›å»ºçš„åˆ«åå®šä¹‰ï¼Œä¾‹å¦‚
`open private`ã€‚
ä¹Ÿå¯ä»¥æŒ‡å®šæ¨¡å—ï¼Œä¾‹å¦‚
`export private a b c from Other.Module`ã€‚

## extend_docs
å®šä¹‰äºï¼š`Mathlib.Tactic.ExtendDocs.commandExtend_docs__Before__After_`

`extend_docs <declName> before <prefix_string> after <suffix_string>` é€šè¿‡æ·»åŠ  `<prefix_string>` åœ¨å‰å’Œ `<suffix_string>` åœ¨åï¼Œæ‰©å±• `<declName>` çš„æ–‡æ¡£ã€‚

## gen_injective_theorems%
å®šä¹‰äºï¼š`Lean.Parser.Command.genInjectiveTheorems`

è¿™æ˜¯ä¸€ä¸ªç”¨äºä¸ºåœ¨ `Prelude.lean` ä¸­å®šä¹‰çš„å½’çº³ç±»å‹ç”Ÿæˆæ„é€ å‡½æ•°å¯é€†æ€§å®šç†çš„è¾…åŠ©å‘½ä»¤ã€‚ä»…ç”¨äºå¼•å¯¼ç›®çš„ã€‚

## grind_pattern
å®šä¹‰äºï¼š`Lean.Parser.Command.grindPattern`


## grind_propagator
å®šä¹‰äºï¼š`Lean.Parser.Â«command_Grind_propagator___(_):=_Â»`

ç”¨æˆ·ä¸º `grind` ç­–ç•¥å®šä¹‰çš„è‡ªå®šä¹‰ä¼ æ’­å™¨ã€‚

## guard_min_heartbeats
å®šä¹‰äºï¼š`Mathlib.CountHeartbeats.commandGuard_min_heartbeats_In__`

å®ˆæŠ¤åœ¨å°é—­å‘½ä»¤ä¸­ä½¿ç”¨çš„æœ€å°å¿ƒè·³æ•°ã€‚

è¿™åœ¨è°ƒè¯•å’Œæœ€å°åŒ–æ…¢é€Ÿå£°æ˜ç¤ºä¾‹çš„ä¸Šä¸‹æ–‡ä¸­æœ€ä¸ºæœ‰ç”¨ã€‚é€šè¿‡å®ˆæŠ¤æ…¢é€Ÿå£°æ˜ä¸­ä½¿ç”¨çš„å¿ƒè·³æ•°ï¼Œå¦‚æœæœ€å°åŒ–æ­¥éª¤æ¶ˆé™¤äº†æ…¢é€Ÿè¡Œä¸ºï¼Œå°†ç”Ÿæˆé”™è¯¯æ¶ˆæ¯ã€‚

é»˜è®¤çš„æœ€å°å¿ƒè·³æ•°æ˜¯ `maxHeartbeats` çš„å€¼ï¼ˆé€šå¸¸ä¸º 200000ï¼‰ã€‚æˆ–è€…ï¼Œå¯ä»¥ä½¿ç”¨è¯­æ³• `guard_min_heartbeats n in cmd` æŒ‡å®šè¦å®ˆæŠ¤çš„å¿ƒè·³æ•°ã€‚

## import
å®šä¹‰äºï¼š`Lean.Parser.Command.import`


## in
å®šä¹‰äºï¼š`Lean.Parser.Command.in`


## include
å®šä¹‰äºï¼š`Lean.Parser.Command.include`

`include eeny meeny` æŒ‡ç¤º Lean åœ¨å½“å‰èŠ‚å‰©ä½™çš„æ‰€æœ‰å®šç†ä¸­åŒ…å«èŠ‚ `variable`s `eeny` å’Œ `meeny`ï¼Œä¸é»˜è®¤æ ¹æ®å®šç†å¤´ä¸­çš„ä½¿ç”¨æƒ…å†µæœ‰æ¡ä»¶åŒ…å«å˜é‡çš„è¡Œä¸ºä¸åŒã€‚å…¶ä»–å‘½ä»¤ä¸å—å½±å“ã€‚`include` é€šå¸¸åè·Ÿ `in theorem ...` ä»¥å°†åŒ…å«é™åˆ¶åœ¨åç»­å£°æ˜ä¸­ã€‚

## init_grind_norm
å®šä¹‰äºï¼š`Lean.Parser.Command.initGrindNorm`


## init_quot
å®šä¹‰äºï¼š`Lean.Parser.Command.init_quot`


## initialize_simps_projections
å®šä¹‰äºï¼š`Lean.Parser.Command.initialize_simps_projections`

æ­¤å‘½ä»¤å…è®¸è‡ªå®šä¹‰ç”± `simps` ç”Ÿæˆçš„å¼•ç†ã€‚

é»˜è®¤æƒ…å†µä¸‹ï¼Œç”¨ `@[simps]` æ ‡è®°ç»“æ„ `MyStruct` çš„å…ƒç´  `myObj` çš„å®šä¹‰ä¼šä¸º `MyStruct` çš„æ¯ä¸ªæŠ•å½± `myProj` ç”Ÿæˆä¸€ä¸ª `@[simp]` å¼•ç† `myObj_myProj`ã€‚æ­¤ä¸€èˆ¬è§„åˆ™æœ‰ä¸€äº›ä¾‹å¤–ï¼š
* å¯¹äºä»£æ•°ç»“æ„ï¼Œå¦‚æœå¯ç”¨ï¼Œæˆ‘ä»¬å°†è‡ªåŠ¨ä½¿ç”¨ç¬¦å·ï¼ˆå¦‚ `Mul`ï¼‰ä½œä¸ºæŠ•å½±ã€‚
* é»˜è®¤æƒ…å†µä¸‹ï¼Œå¯¹çˆ¶ç»“æ„çš„æŠ•å½±ä¸æ˜¯é»˜è®¤æŠ•å½±ï¼Œä½†æ‰€æœ‰æºå¸¦æ•°æ®çš„å­—æ®µéƒ½æ˜¯ï¼ˆåŒ…æ‹¬çˆ¶ç»“æ„ä¸­çš„å­—æ®µï¼‰ã€‚

æ­¤é»˜è®¤è¡Œä¸ºå¯é€šè¿‡ä»¥ä¸‹æ–¹å¼è‡ªå®šä¹‰ï¼š
* é€šè¿‡è¿è¡Œ `initialize_simps_projections MulEquiv (-invFun)` é»˜è®¤ç¦ç”¨æŠ•å½±ã€‚è¿™å°†ç¡®ä¿ä¸ä¸ºè¯¥æŠ•å½±ç”Ÿæˆç®€åŒ–å¼•ç†ï¼Œé™¤éç”¨æˆ·æ˜¾å¼æŒ‡å®šæ­¤æŠ•å½±ï¼ˆå¦‚ `@[simps invFun] def myEquiv : MulEquiv _ _ := _`ï¼‰ã€‚
* åä¹‹ï¼Œé€šè¿‡è¿è¡Œ `initialize_simps_projections MulEquiv (+toEquiv)` é»˜è®¤å¯ç”¨æŠ•å½±ã€‚
* å¯ä»¥é€šè¿‡ä¾‹å¦‚ `initialize_simps_projections MulEquiv (toFun â†’ apply, invFun â†’ symm_apply)` æŒ‡å®šè‡ªå®šä¹‰åç§°ã€‚
* å¦‚æœå¸Œæœ›å°†æŠ•å½±åç§°ä½œä¸ºç”Ÿæˆå¼•ç†åç§°çš„å‰ç¼€ï¼Œå¯ä»¥ä½¿ç”¨ `as_prefix fieldName`ï¼š
  `initialize_simps_projections MulEquiv (toFun â†’ coe, as_prefix coe)`
  è¯·æ³¨æ„ï¼Œè¿™ä¸å½±å“æŠ•å½±åç§°çš„è§£æï¼šå¦‚æœæœ‰ä¸€ä¸ªå£°æ˜ `foo`ï¼Œå¹¶ä¸”å¸Œæœ›æŒ‰é¡ºåºåº”ç”¨æŠ•å½± `snd`ã€`coe`ï¼ˆä½œä¸ºå‰ç¼€ï¼‰å’Œ `fst`ï¼Œå¯ä»¥è¿è¡Œ `@[simps snd_coe_fst] def foo ...`ï¼Œè¿™å°†ç”Ÿæˆä¸€ä¸ªåä¸º `coe_foo_snd_fst` çš„å¼•ç†ã€‚

ä»¥ä¸‹æ˜¯ä¸€äº›é¢å¤–ä¿¡æ¯ï¼š
  * è¿è¡Œ `initialize_simps_projections?`ï¼ˆæˆ– `set_option trace.simps.verbose true`ï¼‰æŸ¥çœ‹ç”Ÿæˆçš„æŠ•å½±ã€‚
* ä¸å¸¦å‚æ•°è¿è¡Œ `initialize_simps_projections MyStruct` ä¸æ˜¯å¿…éœ€çš„ï¼Œå¦‚æœåœ¨å£°æ˜ç»“æ„åæ·»åŠ  `@[simps]`ï¼Œåˆ™æ•ˆæœç›¸åŒã€‚
* å»ºè®®åœ¨ä¸ç»“æ„å£°æ˜ç›¸åŒçš„æ–‡ä»¶ä¸­è°ƒç”¨ `@[simps]` æˆ– `initialize_simps_projections`ã€‚å¦åˆ™ï¼ŒæŠ•å½±å¯èƒ½åœ¨ä¸åŒæ–‡ä»¶ä¸­å¤šæ¬¡ç”Ÿæˆã€‚

ä¸€äº›å¸¸è§ç”¨é€”ï¼š
* å¦‚æœå®šä¹‰äº†ä¸€ä¸ªæ–°çš„ç±»ä¼¼åŒæ€çš„ç»“æ„ï¼ˆå¦‚ `MulHom`ï¼‰ï¼Œåªéœ€åœ¨å®šä¹‰ `DFunLike` å®ä¾‹ï¼ˆæˆ–æš—ç¤º `DFunLike` å®ä¾‹çš„å®ä¾‹ï¼‰åè¿è¡Œ `initialize_simps_projections`ã€‚
  ```
    instance {mM : Mul M} {mN : Mul N} : FunLike (MulHom M N) M N := ...
    initialize_simps_projections MulHom (toFun â†’ apply)
  ```
  è¿™å°†ä¸ºæ¯ä¸ªå£°æ˜ `foo` ç”Ÿæˆ `foo_apply` å¼•ç†ã€‚
* å¦‚æœæ›´å–œæ¬¢è¡¨ç¤ºå‡½æ•°é—´ç­‰å¼çš„ `coe_foo` å¼•ç†ï¼Œè¯·ä½¿ç”¨
  `initialize_simps_projections MulHom (toFun â†’ coe, as_prefix coe)`
  åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ¯å½“è°ƒç”¨ `@[simps]` æ—¶ï¼Œå¿…é¡»ä½¿ç”¨ `@[simps -fullyApplied]`ã€‚
* ä¹Ÿå¯ä»¥åˆå§‹åŒ–ä¸ºåŒæ—¶ä½¿ç”¨ä¸¤è€…ï¼Œæ­¤æ—¶å¿…é¡»é€šè¿‡ä»¥ä¸‹æ–¹å¼ä¹‹ä¸€é€‰æ‹©é»˜è®¤ä½¿ç”¨çš„ï¼š
  ```
    initialize_simps_projections MulHom (toFun â†’ apply, toFun â†’ coe, as_prefix coe, -coe)
    initialize_simps_projections MulHom (toFun â†’ apply, toFun â†’ coe, as_prefix coe, -apply)
  ```
  åœ¨ç¬¬ä¸€ç§æƒ…å†µä¸‹ï¼Œå¯ä»¥ä½¿ç”¨ `@[simps, simps -fullyApplied coe]` è·å–ä¸¤ä¸ªå¼•ç†ï¼Œåœ¨ç¬¬äºŒç§æƒ…å†µä¸‹ï¼Œå¯ä»¥ä½¿ç”¨ `@[simps -fullyApplied, simps apply]` è·å–ä¸¤ä¸ªå¼•ç†ã€‚
* å¦‚æœå£°æ˜äº†ä¸€ä¸ªæ–°çš„ç±»ä¼¼åŒæ€çš„ç»“æ„ï¼ˆå¦‚ `RelEmbedding`ï¼‰ï¼Œåˆ™ `initialize_simps_projections` å°†è‡ªåŠ¨æ‰¾åˆ°ä»»ä½•å°†ç”¨ä½œ `toFun` å­—æ®µé»˜è®¤æŠ•å½±çš„ `DFunLike` å¼ºåˆ¶è½¬æ¢ã€‚
  ```
    initialize_simps_projections relEmbedding (toFun â†’ apply)
  ```
* å¦‚æœæœ‰ä¸€ä¸ªç±»ä¼¼åŒæ„çš„ç»“æ„ï¼ˆå¦‚ `Equiv`ï¼‰ï¼Œé€šå¸¸å¸Œæœ›ä¸ºé€†å®šä¹‰è‡ªå®šä¹‰æŠ•å½±ï¼š
  ```
    def Equiv.Simps.symm_apply (e : Î± â‰ƒ Î²) : Î² â†’ Î± := e.symm
    initialize_simps_projections Equiv (toFun â†’ apply, invFun â†’ symm_apply)
  ```

## initialize_simps_projections?
å®šä¹‰äºï¼š`Lean.Parser.Command.commandInitialize_simps_projections?_`

æ­¤å‘½ä»¤å…è®¸è‡ªå®šä¹‰ç”± `simps` ç”Ÿæˆçš„å¼•ç†ã€‚

é»˜è®¤æƒ…å†µä¸‹ï¼Œç”¨ `@[simps]` æ ‡è®°ç»“æ„ `MyStruct` çš„å…ƒç´  `myObj` çš„å®šä¹‰ä¼šä¸º `MyStruct` çš„æ¯ä¸ªæŠ•å½± `myProj` ç”Ÿæˆä¸€ä¸ª `@[simp]` å¼•ç† `myObj_myProj`ã€‚æ­¤ä¸€èˆ¬è§„åˆ™æœ‰ä¸€äº›ä¾‹å¤–ï¼š
* å¯¹äºä»£æ•°ç»“æ„ï¼Œå¦‚æœå¯ç”¨ï¼Œæˆ‘ä»¬å°†è‡ªåŠ¨ä½¿ç”¨ç¬¦å·ï¼ˆå¦‚ `Mul`ï¼‰ä½œä¸ºæŠ•å½±ã€‚
* é»˜è®¤æƒ…å†µä¸‹ï¼Œå¯¹çˆ¶ç»“æ„çš„æŠ•å½±ä¸æ˜¯é»˜è®¤æŠ•å½±ï¼Œä½†æ‰€æœ‰æºå¸¦æ•°æ®çš„å­—æ®µéƒ½æ˜¯ï¼ˆåŒ…æ‹¬çˆ¶ç»“æ„ä¸­çš„å­—æ®µï¼‰ã€‚

æ­¤é»˜è®¤è¡Œä¸ºå¯é€šè¿‡ä»¥ä¸‹æ–¹å¼è‡ªå®šä¹‰ï¼š
* é€šè¿‡è¿è¡Œ `initialize_simps_projections MulEquiv (-invFun)` é»˜è®¤ç¦ç”¨æŠ•å½±ã€‚è¿™å°†ç¡®ä¿ä¸ä¸ºè¯¥æŠ•å½±ç”Ÿæˆç®€åŒ–å¼•ç†ï¼Œé™¤éç”¨æˆ·æ˜¾å¼æŒ‡å®šæ­¤æŠ•å½±ï¼ˆå¦‚ `@[simps invFun] def myEquiv : MulEquiv _ _ := _`ï¼‰ã€‚
* åä¹‹ï¼Œé€šè¿‡è¿è¡Œ `initialize_simps_projections MulEquiv (+toEquiv)` é»˜è®¤å¯ç”¨æŠ•å½±ã€‚
* å¯ä»¥é€šè¿‡ä¾‹å¦‚ `initialize_simps_projections MulEquiv (toFun â†’ apply, invFun â†’ symm_apply)` æŒ‡å®šè‡ªå®šä¹‰åç§°ã€‚
* å¦‚æœå¸Œæœ›å°†æŠ•å½±åç§°ä½œä¸ºç”Ÿæˆå¼•ç†åç§°çš„å‰ç¼€ï¼Œå¯ä»¥ä½¿ç”¨ `as_prefix fieldName`ï¼š
  `initialize_simps_projections MulEquiv (toFun â†’ coe, as_prefix coe)`
  è¯·æ³¨æ„ï¼Œè¿™ä¸å½±å“æŠ•å½±åç§°çš„è§£æï¼šå¦‚æœæœ‰ä¸€ä¸ªå£°æ˜ `foo`ï¼Œå¹¶ä¸”å¸Œæœ›æŒ‰é¡ºåºåº”ç”¨æŠ•å½± `snd`ã€`coe`ï¼ˆä½œä¸ºå‰ç¼€ï¼‰å’Œ `fst`ï¼Œå¯ä»¥è¿è¡Œ `@[simps snd_coe_fst] def foo ...`ï¼Œè¿™å°†ç”Ÿæˆä¸€ä¸ªåä¸º `coe_foo_snd_fst` çš„å¼•ç†ã€‚

## irreducible_def
å®šä¹‰äºï¼š`Lean.Elab.Command.command_Irreducible_def____`

å¼•å…¥ä¸€ä¸ªä¸å¯çº¦å®šä¹‰ã€‚`irreducible_def foo := 42` ç”Ÿæˆä¸€ä¸ªå¸¸é‡ `foo : Nat` ä»¥åŠä¸€ä¸ªå®šç† `foo_def : foo = 42`ã€‚

## library_note
å®šä¹‰äºï¼š`Batteries.Util.LibraryNote.commandLibrary_note___`

```
library_note "some tag" /--
... ä¸€äº›è¯´æ˜ ...
-/
```
åˆ›å»ºä¸€ä¸ªæ–°çš„â€œåº“æ³¨è®°â€ï¼Œä¹‹åå¯ä»¥åœ¨æ–‡æ¡£æ³¨é‡Šä¸­é€šè¿‡
```
-- å‚è§æ³¨è®° [some tag]
```
è¿›è¡Œäº¤å‰å¼•ç”¨ã€‚ä½¿ç”¨ `#help note "some tag"` åœ¨ä¿¡æ¯è§†å›¾ä¸­æ˜¾ç¤ºæ‰€æœ‰å¸¦æœ‰æ ‡ç­¾ `"some tag"` çš„æ³¨è®°ã€‚è¯¥å‘½ä»¤å¯ä» `Batteries.Tactic.HelpCmd` å¯¼å…¥ã€‚

## lrat_proof
å®šä¹‰äºï¼š`Mathlib.Tactic.Sat.commandLrat_proof_Example____`

ä¸€ä¸ªç”¨äºä» CNF / LRAT æ–‡ä»¶ç”Ÿæˆ SAT è¯æ˜çš„å®ã€‚è¿™äº›æ–‡ä»¶åœ¨ SAT ç¤¾åŒºä¸­å¸¸ç”¨äºç¼–å†™è¯æ˜ã€‚

`lrat_proof` å‘½ä»¤çš„è¾“å…¥æ˜¯è¦å®šä¹‰çš„å®šç†åç§°ï¼Œä»¥åŠé™ˆè¿°ï¼ˆä»¥ CNF æ ¼å¼ä¹¦å†™ï¼‰å’Œè¯æ˜ï¼ˆä»¥ LRAT æ ¼å¼ä¹¦å†™ï¼‰ã€‚ä¾‹å¦‚ï¼š
```lean
lrat_proof foo
  "p cnf 2 4  1 2 0  -1 2 0  1 -2 0  -1 -2 0"
  "5 -2 0 4 3 0  5 d 3 4 0  6 1 0 5 1 0  6 d 1 0  7 0 5 2 6 0"
```
å°†ç”Ÿæˆå®šç†ï¼š
```lean
foo : âˆ€ (a a_1 : Prop), (Â¬a âˆ§ Â¬a_1 âˆ¨ a âˆ§ Â¬a_1) âˆ¨ Â¬a âˆ§ a_1 âˆ¨ a âˆ§ a_1
```

* æ‚¬åœåœ¨ `foo` ä¸Šå¯æŸ¥çœ‹å®šç†é™ˆè¿°ã€‚
* å¯ä½¿ç”¨ `example` å…³é”®å­—æ›¿ä»£ `foo` ä»¥é¿å…ç”Ÿæˆå®šç†ã€‚
* å¯ä½¿ç”¨ `include_str` å®ä»£æ›¿å­—ç¬¦ä¸²ä»¥ä»ç£ç›˜åŠ è½½ CNF / LRAT æ–‡ä»¶ã€‚

## macro
å®šä¹‰äºï¼š`Lean.Parser.Command.macro`


## macro_rules
å®šä¹‰äºï¼š`Lean.Parser.Command.macro_rules`


## mk_iff_of_inductive_prop
å®šä¹‰äºï¼š`Mathlib.Tactic.MkIff.mkIffOfInductiveProp`

`mk_iff_of_inductive_prop i r` ä¸ºå½’çº³å®šä¹‰çš„å‘½é¢˜ `i` åˆ›å»º `iff` è§„åˆ™ã€‚æ–°è§„åˆ™ `r` çš„å½¢å¦‚ `âˆ€ps is, i as â†” â‹_j, âˆƒcs, is = cs`ï¼Œå…¶ä¸­ `ps` æ˜¯ç±»å‹å‚æ•°ï¼Œ`is` æ˜¯ç´¢å¼•ï¼Œ`j` éå†æ‰€æœ‰å¯èƒ½çš„æ„é€ å­ï¼Œ`cs` æ˜¯å„æ„é€ å­çš„å‚æ•°ï¼Œ`is = cs` æ˜¯å„æ„é€ å­å¯¹ç´¢å¼•çš„å®ä¾‹åŒ–ã€‚

åœ¨æ¯ç§æƒ…å†µä¸‹ï¼Œå½“å¯¹åº”çš„ç­‰å¼ä»…ä¸ºæŸä¸ªç´¢å¼• `i` çš„ `c = i` æ—¶ï¼Œæˆ‘ä»¬ç§»é™¤æ„é€ å­å‚æ•°ï¼ˆå³ `cs`ï¼‰ã€‚

ä¾‹å¦‚ï¼Œå¯¹ `List.Chain` ä½¿ç”¨ `mk_iff_of_inductive_prop` ç”Ÿæˆï¼š
```lean
âˆ€ { Î± : Type*} (R : Î± â†’ Î± â†’ Prop) (a : Î±) (l : List Î±),
  Chain R a l â†” l = [] âˆ¨ âˆƒ(b : Î±) (l' : List Î±), R a b âˆ§ Chain R b l âˆ§ l = b :: l'
```

å¦è§ç”¨æˆ·å±æ€§ `mk_iff`ã€‚

## mutual
å®šä¹‰äºï¼š`Lean.Parser.Command.mutual`


## namespace
å®šä¹‰äºï¼š`Lean.Parser.Command.namespace`

`namespace <id>` æ‰“å¼€ä¸€ä¸ªå¸¦æœ‰æ ‡ç­¾ `<id>` çš„åŒºæ®µï¼Œè¯¥åŒºæ®µä¼šå½±å“åŒºæ®µå†…çš„å‘½åå’Œåç§°è§£æï¼š
* å£°æ˜åç§°ä¼šè¢«å‰ç¼€åŒ–ï¼šåœ¨å‘½åç©ºé—´ `Nat` å†…éƒ¨çš„ `def seventeen : â„• := 17` ä¼šè¢«èµ‹äºˆå…¨å `Nat.seventeen`ã€‚
* ç”± `export` å£°æ˜å¼•å…¥çš„åç§°ä¹Ÿä¼šè¢«æ ‡è¯†ç¬¦å‰ç¼€åŒ–ã€‚
* æ‰€æœ‰ä»¥ `<id>.` å¼€å¤´çš„åç§°åœ¨å‘½åç©ºé—´å†…æ— éœ€å‰ç¼€å³å¯ä½¿ç”¨ã€‚è¿™äº›åç§°ä¼˜å…ˆäºç”±å¤–éƒ¨å‘½åç©ºé—´æˆ– `open` å¼•å…¥çš„åç§°ã€‚
* åœ¨å‘½åç©ºé—´å†…éƒ¨ï¼Œå£°æ˜å¯ä»¥æ˜¯ `protected` çš„ï¼Œè¿™ä¼šæ’é™¤å®ƒä»¬åœ¨æ‰“å¼€å‘½åç©ºé—´æ—¶çš„å½±å“ã€‚

ä¸ `section` ç±»ä¼¼ï¼Œå‘½åç©ºé—´å¯åµŒå¥—ï¼Œå…¶ä½œç”¨åŸŸç”±å¯¹åº”çš„ `end <id>` æˆ–æ–‡ä»¶æœ«å°¾ç»ˆæ­¢ã€‚

`namespace` ä¹Ÿåƒ `section` ä¸€æ ·ç•Œå®š `variable`ã€`open` åŠå…¶ä»–ä½œç”¨åŸŸå‘½ä»¤çš„èŒƒå›´ã€‚

## noncomputable
å®šä¹‰äºï¼š`Lean.Parser.Command.noncomputableSection`


## norm_cast_add_elim
å®šä¹‰äºï¼š`Lean.Parser.Tactic.normCastAddElim`

`norm_cast_add_elim foo` å°† `foo` æ³¨å†Œä¸º `norm_cast` ä¸­çš„æ¶ˆé™¤å¼•ç†ã€‚

## notation
å®šä¹‰äºï¼š`Lean.Parser.Command.notation`


## notation3
å®šä¹‰äºï¼š`Mathlib.Notation3.notation3`

`notation3` ä½¿ç”¨ Lean-3 é£æ ¼çš„è¯­æ³•å£°æ˜è®°æ³•ã€‚

ç¤ºä¾‹ï¼š
```lean
notation3 "âˆ€á¶  " (...) " in " f ", " r:(scoped p => Filter.eventually p f) => r
notation3 "MyList[" (x", "* => foldr (a b => MyList.cons a b) MyList.nil) "]" => x
```
é»˜è®¤æƒ…å†µä¸‹ï¼Œè®°æ³•æ— æ³•æåŠä½¿ç”¨ `variable` å®šä¹‰çš„ä»»ä½•å˜é‡ï¼Œä½† `local notation3` å¯ä½¿ç”¨æ­¤ç±»å±€éƒ¨å˜é‡ã€‚

ä½¿ç”¨ `notation3 (prettyPrint := false)` é˜»æ­¢å‘½ä»¤ä¸ºè®°æ³•ç”Ÿæˆç¾åŒ–æ‰“å°å™¨ã€‚

è¯¥å‘½ä»¤å¯ç”¨äº mathlib4ï¼Œä½†å…¶æœªæ¥ä¸ç¡®å®šï¼Œä¸»è¦ä¸ºå‘åå…¼å®¹è€Œåˆ›å»ºã€‚

## omit
å®šä¹‰äºï¼š`Lean.Parser.Command.omit`

`omit` æŒ‡ç¤º Lean ä¸åŒ…å«å…ˆå‰ `include` çš„å˜é‡ã€‚é™¤å˜é‡åå¤–ï¼Œè¿˜å¯é€šè¿‡ç±»å‹ä½¿ç”¨è¯­æ³• `omit [TypeOfInst]` å¼•ç”¨ç±»å‹ç±»å®ä¾‹å˜é‡ï¼Œæ­¤æ—¶å°†çœç•¥æ‰€æœ‰ä¸ç»™å®šç±»å‹ç»Ÿä¸€çš„å®ä¾‹å˜é‡ã€‚`omit` é€šå¸¸åº”ä¸ `in` ç»“åˆä½¿ç”¨ä»¥ä¿æŒåŒºæ®µç»“æ„ç®€å•ã€‚

## open
å®šä¹‰äºï¼š`Lean.Elab.Command.openPrivate`

å‘½ä»¤ `open private a b c in foo bar` å°†åœ¨å£°æ˜ `foo` å’Œ `bar` ä¸­æŸ¥æ‰¾åä¸º `a`ã€`b`ã€`c` çš„ç§æœ‰å®šä¹‰ï¼Œå¹¶åœ¨å½“å‰ä½œç”¨åŸŸä¸­æ‰“å¼€å®ƒä»¬ã€‚è¿™ä¸ä¼šä½¿å®šä¹‰å…¬å¼€ï¼Œè€Œæ˜¯è®©å®ƒä»¬é€šè¿‡çŸ­åç§° `a` åœ¨å½“å‰åŒºæ®µå†…å¯è®¿é—®ï¼Œè€Œéæ— æ³•ç›´æ¥è¾“å…¥çš„å†…éƒ¨åç§°ï¼ˆå¦‚ `_private.Other.Module.0.Other.Namespace.foo.a`ï¼‰ã€‚

ä¹Ÿå¯é€šè¿‡ `open private a b c from Other.Module` æŒ‡å®šæ¨¡å—ã€‚

## open
å®šä¹‰äºï¼š`Lean.Parser.Command.open`

ä½¿å…¶ä»–å‘½åç©ºé—´çš„åç§°æ— éœ€å‰ç¼€å³å¯è§ã€‚

é€šè¿‡ `open` å¯ç”¨çš„åç§°åœ¨å½“å‰ `section` æˆ– `namespace` å—å†…å¯è§ã€‚è¿™ç®€åŒ–äº†å¯¹ï¼ˆç±»å‹ï¼‰å®šä¹‰å’Œå®šç†çš„å¼•ç”¨ï¼Œä½†éœ€æ³¨æ„ï¼Œä¹Ÿå¯èƒ½ä½¿æ¥è‡ªå…¶ä»–å‘½åç©ºé—´çš„[ä½œç”¨åŸŸå®ä¾‹]ã€è®°æ³•å’Œå±æ€§å¯ç”¨ã€‚

`open` å‘½ä»¤æœ‰å‡ ç§ä¸åŒçš„ä½¿ç”¨æ–¹å¼ï¼š

* `open Some.Namespace.Path1 Some.Namespace.Path2` ä½¿å¾— `Some.Namespace.Path1` å’Œ `Some.Namespace.Path2` ä¸­çš„æ‰€æœ‰éå—ä¿æŠ¤åç§°æ— éœ€å‰ç¼€å³å¯ä½¿ç”¨ï¼Œå› æ­¤ `Some.Namespace.Path1.x` å’Œ `Some.Namespace.Path2.y` å¯ä»¥ç›´æ¥é€šè¿‡ `x` å’Œ `y` æ¥å¼•ç”¨ã€‚

* `open Some.Namespace.Path hiding def1 def2` æ‰“å¼€ `Some.Namespace.Path` ä¸­é™¤ `def1` å’Œ `def2` å¤–çš„æ‰€æœ‰éå—ä¿æŠ¤åç§°ã€‚

* `open Some.Namespace.Path (def1 def2)` ä»…ä½¿ `Some.Namespace.Path.def1` å’Œ `Some.Namespace.Path.def2` æ— éœ€å®Œæ•´å‰ç¼€å³å¯ä½¿ç”¨ï¼Œè€Œ `Some.Namespace.Path.def3` ä¸ä¼šå—åˆ°å½±å“ã€‚

  å³ä½¿ `def1` å’Œ `def2` æ˜¯ `protected` çš„ï¼Œæ­¤æ–¹æ³•ä»æœ‰æ•ˆã€‚

* `open Some.Namespace.Path renaming def1 â†’ def1', def2 â†’ def2'` ä¸ `open Some.Namespace.Path (def1 def2)` ç±»ä¼¼ï¼Œä½†å°† `def1`/`def2` çš„åç§°æ›´æ”¹ä¸º `def1'`/`def2'`ã€‚

  å³ä½¿ `def1` å’Œ `def2` æ˜¯ `protected` çš„ï¼Œæ­¤æ–¹æ³•ä»æœ‰æ•ˆã€‚

* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **ä»…** æ‰“å¼€æ¥è‡ª `Namespace1` å’Œ `Namespace2` çš„[ä½œç”¨åŸŸå®ä¾‹]ã€ç¬¦å·å’Œå±æ€§ï¼›**ä¸** æä¾›å…¶ä»–ä»»ä½•åç§°ã€‚

* `open <ä¸Šè¿°ä»»æ„ open å½¢å¼> in` ä½¿å¾— `open` çš„åç§°ä»…åœ¨ä¸‹ä¸€ä¸ªå‘½ä»¤æˆ–è¡¨è¾¾å¼ä¸­å¯è§ã€‚

[ä½œç”¨åŸŸå®ä¾‹]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances
(å®šç†è¯æ˜ä¸­çš„ä½œç”¨åŸŸå®ä¾‹)


ç¤ºä¾‹ï¼š

```lean
/-- SKIç»„åˆå­ https://zh.wikipedia.org/wiki/SKIç»„åˆå­æ¼”ç®— -/
namespace Combinator.Calculus
  def I (a : Î±) : Î± := a
  def K (a : Î±) : Î² â†’ Î± := fun _ => a
  def S (x : Î± â†’ Î² â†’ Î³) (y : Î± â†’ Î²) (z : Î±) : Î³ := x z (y z)
end Combinator.Calculus

section
  -- æ‰“å¼€ `Combinator.Calculus` ä¸‹çš„æ‰€æœ‰å†…å®¹ï¼Œå³ `I`ã€`K` å’Œ `S`ï¼Œç›´åˆ°è¯¥ section ç»“æŸ
  open Combinator.Calculus

  theorem SKx_eq_K : S K x = I := rfl
end

-- ä»…å¯¹ä¸‹ä¸€ä¸ªå‘½ä»¤ï¼ˆæ­¤å¤„ä¸ºä¸‹ä¸€ä¸ª `theorem`ï¼‰æ‰“å¼€ `Combinator.Calculus` ä¸‹çš„æ‰€æœ‰å†…å®¹
open Combinator.Calculus in
theorem SKx_eq_K' : S K x = I := rfl

section
  -- ä»…æ‰“å¼€ `Combinator.Calculus` ä¸‹çš„ `S` å’Œ `K`
  open Combinator.Calculus (S K)

  theorem SKxy_eq_y : S K x y = y := rfl

  -- `I` ä¸åœ¨ä½œç”¨åŸŸä¸­ï¼Œå¿…é¡»ä½¿ç”¨å…¶å®Œæ•´è·¯å¾„
  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl
end

section
  open Combinator.Calculus
    renaming
      I â†’ identity,
      K â†’ konstant

  #check identity
  #check konstant
end

section
  open Combinator.Calculus
    hiding S

  #check I
  #check K
end

section
  namespace Demo
    inductive MyType
    | val

    namespace N1
      scoped infix:68 " â‰‹ " => BEq.beq

      scoped instance : BEq MyType where
        beq _ _ := true

      def Alias := MyType
    end N1
  end Demo

  -- å°† `â‰‹` å’Œå®ä¾‹å¼•å…¥ä½œç”¨åŸŸï¼Œä½†ä¸å¼•å…¥ `Alias`
  open scoped Demo.N1

  #check Demo.MyType.val == Demo.MyType.val
  #check Demo.MyType.val â‰‹ Demo.MyType.val
  -- #check Alias -- æœªçŸ¥æ ‡è¯†ç¬¦ 'Alias'
end
```

## proof_wanted
å®šä¹‰äºï¼š`Â«proof_wantedÂ»`

æ­¤è¯æ˜å°†æ˜¯å¯¹åº“çš„ä¸€ä¸ªæ¬¢è¿è´¡çŒ®ï¼

`proof_wanted` å£°æ˜çš„è¯­æ³•ä¸ `theorem` ç±»ä¼¼ï¼Œä½†ä¸åŒ…å« `:=` æˆ–è¯æ˜ã€‚Lean ä¼šæ£€æŸ¥ `proof_wanted` å£°æ˜æ˜¯å¦æ ¼å¼æ­£ç¡®ï¼ˆä¾‹å¦‚ç¡®ä¿æ‰€æœ‰æåˆ°çš„åç§°éƒ½åœ¨ä½œç”¨åŸŸå†…ï¼Œä¸”å®šç†é™ˆè¿°æ˜¯æœ‰æ•ˆçš„å‘½é¢˜ï¼‰ï¼Œä½†å®ƒä»¬éšåä¼šè¢«ä¸¢å¼ƒã€‚è¿™æ„å‘³ç€å®ƒä»¬ä¸èƒ½ä½œä¸ºå…¬ç†ä½¿ç”¨ã€‚

å…¸å‹ç”¨æ³•ï¼š
```lean
@[simp] proof_wanted empty_find? [BEq Î±] [Hashable Î±] {a : Î±} :
    (âˆ… : HashMap Î± Î²).find? a = none
```

## recall
å®šä¹‰äºï¼š`Mathlib.Tactic.Recall.recall`

`recall` å‘½ä»¤é‡æ–°å£°æ˜å…ˆå‰çš„å®šä¹‰ä»¥ä½œè¯´æ˜ä¹‹ç”¨ã€‚
è¿™å¯¹äºä»¥è¯´æ˜æ€§æ–¹å¼å‘ˆç°æŸäº›ç†è®ºçš„ Lean æ–‡ä»¶éå¸¸æœ‰ç”¨ã€‚

è¯¥å‘½ä»¤çš„è¯­æ³•ä¸ `def` ç›¸åŒï¼Œå› æ­¤æ‰€æœ‰å¸¸è§„åŠŸèƒ½å‡å¯ä½¿ç”¨ã€‚
```lean
recall List.cons_append (a : Î±) (as bs : List Î±) : (a :: as) ++ bs = a :: (as ++ bs) := rfl
```
æ­¤å¤–ï¼Œå¯ä»¥çœç•¥ä¸»ä½“ã€‚
```lean
recall Nat.add_comm (n m : Nat) : n + m = m + n
```

è¯¥å‘½ä»¤éªŒè¯æ–°å®šä¹‰æ˜¯å¦ç±»å‹æ£€æŸ¥ï¼Œä»¥åŠæä¾›çš„ç±»å‹å’Œå€¼æ˜¯å¦ä¸åŸå§‹å£°æ˜åœ¨å®šä¹‰ä¸Šç›¸ç­‰ã€‚ç„¶è€Œï¼Œè¿™ä¸ä¼šæ•è·æŸäº›ç»†èŠ‚ï¼ˆå¦‚ç»‘å®šå™¨ï¼‰ï¼Œå› æ­¤ä»¥ä¸‹å†…å®¹ä¸ä¼šæŠ¥é”™ã€‚
```lean
recall Nat.add_comm {n m : Nat} : n + m = m + n
```

## recommended_spelling
å®šä¹‰äºï¼š`Lean.Parser.Command.recommended_spelling`

è®°å½•æ ‡è¯†ç¬¦ä¸­ç¬¦å·çš„æ¨èæ‹¼å†™ã€‚

å®šç†é€šå¸¸åº”æ ¹æ®å…¶é™ˆè¿°ç³»ç»Ÿå‘½åï¼Œè€Œéåˆ›é€ æ€§å‘½åã€‚éæ ‡è¯†ç¬¦ç¬¦å·åº”å§‹ç»ˆé€šè¿‡å…¶æ¨èæ‹¼å†™ä¸€è‡´å¼•ç”¨ã€‚

```
/-- ä¸€äº›é¢å¤–ä¿¡æ¯ -/
recommended_spelling "and" for "âˆ§" in [And, Â«term_âˆ§_Â»]
```

å°†æ‰§è¡Œä»¥ä¸‹æ“ä½œï¼š
* åœ¨ `And` å’Œ `âˆ§` çš„æ–‡æ¡£å­—ç¬¦ä¸²æœ«å°¾æ·»åŠ å¥å­â€œ`âˆ§` åœ¨æ ‡è¯†ç¬¦ä¸­çš„æ¨èæ‹¼å†™ä¸º `and`ï¼ˆä¸€äº›é¢å¤–ä¿¡æ¯ï¼‰â€ã€‚å¦‚æœé¢å¤–ä¿¡æ¯è¶…è¿‡ä¸€è¡Œï¼Œå®ƒå°†æ”¾ç½®åœ¨å¥å­ä¸‹æ–¹è€Œéæ‹¬å·å†…ã€‚
* å°†æ­¤ä¿¡æ¯æ³¨å†Œåˆ°ç¯å¢ƒæ‰©å±•ä¸­ï¼Œä»¥ä¾¿åç»­ç”ŸæˆåŒ…å«æ‰€æœ‰æ¨èæ‹¼å†™çš„è¡¨æ ¼ã€‚

æ‚¨å¯ä»¥å°†æ¨èæ‹¼å†™é™„åŠ åˆ°ä»»æ„å¤šä¸ªå£°æ˜ã€‚å»ºè®®å°†æ¨èæ‹¼å†™é™„åŠ åˆ°æ‰€æœ‰ç›¸å…³è§£æå™¨ä»¥åŠè§£æå™¨æ‰€æŒ‡çš„å£°æ˜ï¼ˆå¦‚æœå­˜åœ¨æ­¤ç±»å£°æ˜ï¼‰ã€‚æ³¨æ„ `inherit_doc` å±æ€§*ä¸ä¼š*å¤åˆ¶æ¨èæ‹¼å†™ï¼Œå› æ­¤å³ä½¿ `âˆ§` çš„è§£æå™¨ä½¿ç”¨ `@[inherit_doc And]`ï¼Œæˆ‘ä»¬ä¹Ÿå¿…é¡»å°†æ¨èæ‹¼å†™é™„åŠ åˆ° `And` å’Œ `Â«term_âˆ§_Â»` ä¸¤è€…ã€‚

`syntax`ã€`macro`ã€`elab` å’Œ `notation` å‘½ä»¤æ¥å— `(name := parserName)` é€‰é¡¹ä»¥å°†åç§°åˆ†é…ç»™åˆ›å»ºçš„è§£æå™¨ï¼Œä»è€Œæ— éœ€çŒœæµ‹è‡ªåŠ¨ç”Ÿæˆçš„åç§°ã€‚`syntax`ã€`macro` å’Œ `elab` å‘½ä»¤å¯æ‚¬åœä»¥æŸ¥çœ‹è§£æå™¨åç§°ã€‚

å¯¹äºåŒ…å«æ ‡è¯†ç¬¦çš„å¤æ‚ç¬¦å·ï¼Œçº¦å®šæ˜¯ä½¿ç”¨ç¤ºä¾‹æ ‡è¯†ç¬¦è€Œéå…¶ä»–å ä½ç¬¦ã€‚ä»¥ä¸‹æ˜¯éµå¾ªæ­¤çº¦å®šçš„ç¤ºä¾‹ï¼š
```lean
recommended_spelling "singleton" for "[a]" in [List.cons, Â«term[_]Â»]
```
ä½¿ç”¨ `[Â·]` æˆ– `[â‹¯]` æˆ– `[â€¦]` ä»£æ›¿ `[a]` å°†è¿åçº¦å®šã€‚å½“å°†æ¨èæ‹¼å†™é™„åŠ åˆ°å·²æœ‰ç¤ºä¾‹çš„ç¬¦å·æ–‡æ¡£æ—¶ï¼Œå°½é‡é‡ç”¨æ–‡æ¡£ä¸­é€‰æ‹©çš„æ ‡è¯†ç¬¦åç§°ä»¥ä¿æŒä¸€è‡´æ€§ã€‚

## register_builtin_option
å®šä¹‰äºï¼š`Lean.Option.registerBuiltinOption`


## register_hint
å®šä¹‰äºï¼š`Mathlib.Tactic.Hint.registerHintStx`

æ³¨å†Œä¸€ä¸ªä¸ `hint` ç­–ç•¥ä¸€èµ·ä½¿ç”¨çš„ç­–ç•¥ï¼Œä¾‹å¦‚ `register_hint simp_all`ã€‚

## register_label_attr
å®šä¹‰äºï¼š`Lean.Parser.Command.registerLabelAttr`

åˆå§‹åŒ–æ–°çš„â€œæ ‡ç­¾â€å±æ€§ã€‚
ä½¿ç”¨ `Lean.labelled` å¯æ£€ç´¢æ ‡è®°æœ‰æ­¤å±æ€§çš„å£°æ˜ã€‚

## register_option
å®šä¹‰äºï¼š`Lean.Option.registerOption`


## register_simp_attr
å®šä¹‰äºï¼š`Lean.Parser.Command.registerSimpAttr`


## register_tactic_tag
å®šä¹‰äºï¼š`Lean.Parser.Command.register_tactic_tag`

æ³¨å†Œç­–ç•¥æ ‡ç­¾ï¼Œä¿å­˜å…¶é¢å‘ç”¨æˆ·çš„åç§°å’Œæ–‡æ¡£å­—ç¬¦ä¸²ã€‚

æ–‡æ¡£ç”Ÿæˆå·¥å…·å¯ä½¿ç”¨ç­–ç•¥æ ‡ç­¾å¯¹ç›¸å…³ç­–ç•¥è¿›è¡Œåˆ†ç±»ã€‚

## run_cmd
å®šä¹‰äºï¼š`Lean.runCmd`

`run_cmd doSeq` å‘½ä»¤åœ¨ `CommandElabM Unit` ä¸­æ‰§è¡Œä»£ç ã€‚
è¿™ä¸ `#eval show CommandElabM Unit from discard do doSeq` ç›¸åŒã€‚

## run_elab
å®šä¹‰äºï¼š`Lean.runElab`

`run_elab doSeq` å‘½ä»¤åœ¨ `TermElabM Unit` ä¸­æ‰§è¡Œä»£ç ã€‚
è¿™ä¸ `#eval show TermElabM Unit from discard do doSeq` ç›¸åŒã€‚

## run_meta
å®šä¹‰äºï¼š`Lean.runMeta`

`run_meta doSeq` å‘½ä»¤åœ¨ `MetaM Unit` ä¸­æ‰§è¡Œä»£ç ã€‚
è¿™ä¸ `#eval show MetaM Unit from do discard doSeq` ç›¸åŒã€‚

ï¼ˆè¿™å®é™…ä¸Šæ˜¯ `run_elab` çš„åŒä¹‰è¯ï¼Œå› ä¸º `MetaM` å¯æå‡è‡³ `TermElabM`ã€‚ï¼‰

## scoped
å®šä¹‰äºï¼š`Mathlib.Tactic.scopedNS`

`scoped[NS]` ç±»ä¼¼äºå±æ€§å’Œç¬¦å·ä¸Šçš„ `scoped` ä¿®é¥°ç¬¦ï¼Œä½†å®ƒåœ¨æŒ‡å®šå‘½åç©ºé—´ä¸­ä½œç”¨è¯­æ³•ï¼Œè€Œéå½“å‰å‘½åç©ºé—´ã€‚
```lean
scoped[Matrix] postfix:1024 "áµ€" => Matrix.transpose
-- å£°æ˜ `áµ€` ä½œä¸ºçŸ©é˜µè½¬ç½®çš„ç¬¦å·
-- ä»…åœ¨ `open Matrix` æˆ– `open scoped Matrix` æ—¶å¯è®¿é—®ã€‚

namespace Nat

scoped[Nat.Count] attribute [instance] CountSet.fintype
-- å°†å®šä¹‰ Nat.CountSet.fintype è®¾ä¸ºå®ä¾‹ï¼Œ
-- ä½†ä»…åœ¨ `Nat.Count` æ‰“å¼€æ—¶ç”Ÿæ•ˆ
```

## seal
Defined in: `Lean.Parser.commandSeal__`

`seal foo` å‘½ä»¤ç¡®ä¿ `foo` çš„å®šä¹‰è¢«å¯†å°ï¼Œå³æ ‡è®°ä¸º `[irreducible]`ã€‚
æ­¤å‘½ä»¤åœ¨éœ€è¦é˜²æ­¢è¯æ˜è¿‡ç¨‹ä¸­å¯¹ `foo` è¿›è¡Œè§„çº¦çš„ä¸Šä¸‹æ–‡ä¸­å°¤ä¸ºæœ‰ç”¨ã€‚

åœ¨åŠŸèƒ½ä¸Šï¼Œ`seal foo` ç­‰åŒäº `attribute [local irreducible] foo`ã€‚
è¯¥å±æ€§æŒ‡å®š `foo` ä»…åœ¨å±€éƒ¨ä½œç”¨åŸŸå†…è¢«è§†ä¸ºä¸å¯è§„çº¦ï¼Œ
è¿™æœ‰åŠ©äºåœ¨ä¿æŒæ‰€éœ€æŠ½è±¡å±‚çº§çš„åŒæ—¶ä¸å½±å“å…¨å±€è®¾ç½®ã€‚

## section
Defined in: `Lean.Parser.Command.section`

`section`/`end` å¯¹ç”¨äºç•Œå®š `variable`ã€`include`ã€`open`ã€`set_option` å’Œ `local`
å‘½ä»¤çš„ä½œç”¨åŸŸã€‚èŠ‚ï¼ˆsectionï¼‰å¯åµŒå¥—ã€‚`section <id>` ä¸ºèŠ‚æä¾›æ ‡ç­¾ï¼Œéœ€ä¸åŒ¹é…çš„ `end` ä¸€èµ·å‡ºç°ã€‚
æ— è®ºæ˜¯å¦ä½¿ç”¨æ ‡ç­¾ï¼Œ`end` å‡å¯çœç•¥ï¼Œæ­¤æ—¶èŠ‚å°†åœ¨æ–‡ä»¶æœ«å°¾å…³é—­ã€‚

## set_option
Defined in: `Lean.Parser.Command.set_option`

`set_option <id> <value>` å°†é€‰é¡¹ `<id>` è®¾ä¸º `<value>`ã€‚æ ¹æ®é€‰é¡¹ç±»å‹çš„ä¸åŒï¼Œ
å€¼å¯ä¸º `true`ã€`false`ã€å­—ç¬¦ä¸²æˆ–æ•°å­—ã€‚é€‰é¡¹ç”¨äºé…ç½® Lean åŠç”¨æˆ·å®šä¹‰æ‰©å±•çš„è¡Œä¸ºã€‚
è¯¥è®¾ç½®å°†ä¿æŒæœ‰æ•ˆç›´è‡³å½“å‰ `section` æˆ– `namespace` ç»“æŸï¼Œæˆ–æ–‡ä»¶ç»“æŸã€‚
è¾“å…¥ `<id>` æ—¶å¯ä½¿ç”¨è‡ªåŠ¨è¡¥å…¨ä»¥åˆ—å‡ºå¯ç”¨é€‰é¡¹ã€‚

`set_option <id> <value> in <command>` å°†é€‰é¡¹è®¾ä¸ºä»…å¯¹å•ä¸ªå‘½ä»¤ç”Ÿæ•ˆï¼š
```lean
set_option pp.all true in
#check 1 + 1
```
ç±»ä¼¼åœ°ï¼Œ`set_option <id> <value> in` ä¹Ÿå¯åœ¨é¡¹å’Œç­–ç•¥å†…éƒ¨ä½¿ç”¨ï¼Œä»¥ä»…å¯¹å•ä¸ªé¡¹æˆ–ç­–ç•¥è®¾ç½®é€‰é¡¹ã€‚

## set_premise_selector
Defined in: `Lean.setPremiseSelectorCmd`

æŒ‡å®šå‰æé€‰æ‹©å¼•æ“ã€‚
æ³¨æ„ Lean æœªå†…ç½®é»˜è®¤å‰æé€‰æ‹©å¼•æ“ï¼Œ
å› æ­¤æ­¤å‘½ä»¤éœ€ç»“åˆæä¾›å¼•æ“çš„ä¸‹æ¸¸åŒ…ä½¿ç”¨ã€‚

## show_panel_widgets
Defined in: `Lean.Widget.showPanelWidgetsCmd`

ä½¿ç”¨ `show_panel_widgets [<widget>]` æ ‡è®°åº”å§‹ç»ˆæ˜¾ç¤º `<widget>`ï¼Œ
åŒ…æ‹¬åœ¨ä¸‹æ¸¸æ¨¡å—ä¸­ã€‚

`<widget>` çš„ç±»å‹å¿…é¡»å®ç° `Widget.ToModule`ï¼Œ
ä¸” `<props>` çš„ç±»å‹å¿…é¡»å®ç° `Server.RpcEncodable`ã€‚
ç‰¹åˆ«åœ°ï¼Œ`<props> : Json` é€‚ç”¨ã€‚

ä½¿ç”¨ `show_panel_widgets [<widget> with <props>]`
æŒ‡å®šåº”ä¼ é€’ç»™ widget çš„å‚æ•° `<props>`ã€‚

ä½¿ç”¨ `show_panel_widgets [local <widget> (with <props>)?]` æ ‡è®°ä»…åœ¨å½“å‰èŠ‚ã€å‘½åç©ºé—´æˆ–æ–‡ä»¶ä¸­æ˜¾ç¤ºã€‚

ä½¿ç”¨ `show_panel_widgets [scoped <widget> (with <props>)?]` æ ‡è®°ä»…å½“å½“å‰å‘½åç©ºé—´æ‰“å¼€æ—¶æ˜¾ç¤ºã€‚

ä½¿ç”¨ `show_panel_widgets [-<widget>]` ä¸´æ—¶éšè—å…ˆå‰æ˜¾ç¤ºçš„ widgetï¼Œ
ä»…åœ¨å½“å‰èŠ‚ã€å‘½åç©ºé—´æˆ–æ–‡ä»¶å†…æœ‰æ•ˆã€‚
æ³¨æ„æ— æ³•æ°¸ä¹…ç§»é™¤ï¼Œå³ `-<widget>` å¯¹ä¸‹æ¸¸æ¨¡å—æ— å½±å“ã€‚

## simproc
Defined in: `Lean.Parser.Â«command__Simproc__[_]_(_):=_Â»`

ç”¨æˆ·å®šä¹‰çš„ç®€åŒ–è¿‡ç¨‹ï¼Œä¾› `simp` ç­–ç•¥åŠå…¶å˜ä½“ä½¿ç”¨ã€‚ç¤ºä¾‹å¦‚ä¸‹ï¼š
```lean
theorem and_false_eq {p : Prop} (q : Prop) (h : p = False) : (p âˆ§ q) = False := by simp [*]

open Lean Meta Simp
simproc â†“ shortCircuitAnd (And _ _) := fun e => do
  let_expr And p q := e | return .continue
  let r â† simp p
  let_expr False := r.expr | return .continue
  let proof â† mkAppM ``and_false_eq #[q, (â† r.getProof)]
  return .done { expr := r.expr, proof? := some proof }
```
å½“ `simp` ç­–ç•¥å‘ç°å½¢å¦‚ `And _ _` çš„é¡¹æ—¶ï¼Œä¼šè°ƒç”¨ `shortCircuitAnd`ã€‚
ç®€åŒ–è¿‡ç¨‹å­˜å‚¨äºï¼ˆä¸å®Œç¾çš„ï¼‰åˆ¤åˆ«æ ‘ä¸­ã€‚
è¿‡ç¨‹**ä¸åº”**å‡è®¾é¡¹ `e` å®Œç¾åŒ¹é…ç»™å®šæ¨¡å¼ã€‚
ç®€åŒ–è¿‡ç¨‹ä¸»ä½“å¿…é¡»å…·æœ‰ `Simproc` ç±»å‹ï¼Œå³ `Expr â†’ SimpM Step` çš„åˆ«åã€‚
ä½¿ç”¨ä¿®é¥°ç¬¦ `â†“` åœ¨è¿‡ç¨‹åå‰å¯æŒ‡ç¤ºç®€åŒ–å™¨åœ¨å­è¡¨è¾¾å¼ç®€åŒ–å‰åº”ç”¨è¯¥è¿‡ç¨‹ã€‚
ç®€åŒ–è¿‡ç¨‹äº¦å¯è®¾ä¸ºä½œç”¨åŸŸæˆ–å±€éƒ¨ã€‚

## simproc_decl
Defined in: `Lean.Parser.Â«command_Simproc_decl_(_):=_Â»`

ç”¨æˆ·å®šä¹‰çš„ç®€åŒ–è¿‡ç¨‹å£°æ˜ã€‚éœ€é€šè¿‡æä¾›è¯¥è¿‡ç¨‹ä½œä¸ºå‚æ•°æˆ–ä½¿ç”¨ `attribute` å‘½ä»¤è®¾ç½®å…¶ `[simproc]` å±æ€§ï¼Œ
æ–¹å¯åœ¨ `simp` ç­–ç•¥ä¸­æ¿€æ´»ã€‚

## simproc_pattern%
Defined in: `Lean.Parser.simprocPattern`

ç”¨äºå°†æ¨¡å¼ä¸ç®€åŒ–è¿‡ç¨‹å…³è”çš„è¾…åŠ©å‘½ä»¤ã€‚

## sudo
Defined in: `commandSudoSet_option___`

å‘½ä»¤ `sudo set_option name val` ç±»ä¼¼ `set_option name val`ï¼Œ
ä½†å…è®¸è®¾ç½®æœªå£°æ˜çš„é€‰é¡¹ã€‚

## suppress_compilation
Defined in: `commandSuppress_compilation`

å°† `def` å’Œ `instance` æ›¿æ¢ä¸º `noncomputable def` å’Œ `noncomputable instance`ï¼Œ
ç”¨äºåœ¨ç‰¹å®šæ–‡ä»¶æˆ–èŠ‚ä¸­ç¦ç”¨ç¼–è¯‘å™¨ã€‚
æ­¤ä¸ºåº”å¯¹ https://github.com/leanprover-community/mathlib4/issues/7103 çš„ä¸´æ—¶æ–¹æ¡ˆã€‚
æ³¨æ„å…¶ä¸é€‚ç”¨äº `notation3`ã€‚è‹¥ `suppress_compilation` å¤„äºæ¿€æ´»çŠ¶æ€ï¼Œ
éœ€åœ¨å£°æ˜æ­¤ç±»è®°å·å‰ä½¿ç”¨ `unsuppress_compilation`ã€‚

## syntax
Defined in: `Lean.Parser.Command.syntax`


## syntax
Defined in: `Lean.Parser.Command.syntaxAbbrev`


## tactic_extension
Defined in: `Lean.Parser.Command.tactic_extension`

æ‰©å±•æŒ‡å®šç­–ç•¥çš„æ–‡æ¡£ã€‚

æ‰©å±•æ–‡æ¡£ç½®äºå‘½ä»¤çš„æ–‡æ¡£å­—ç¬¦ä¸²ä¸­ï¼Œä»¥é¡¹ç›®ç¬¦å·åˆ—è¡¨å½¢å¼æ˜¾ç¤ºï¼Œåº”ä¿æŒç®€æ´ã€‚

## test_extern
Defined in: `testExternCmd`


## unif_hint
Defined in: `Lean.Â«command__Unif_hint____Where_|_-âŠ¢_Â»`


## universe
Defined in: `Lean.Parser.Command.universe`

å£°æ˜ä¸€ä¸ªæˆ–å¤šä¸ªå®‡å®™å˜é‡ã€‚

`universe u v`

`Prop`ã€`Type`ã€`Type u` å’Œ `Sort u` æ˜¯åˆ†ç±»å…¶ä»–ç±»å‹çš„ç±»å‹ï¼Œäº¦ç§°*å®‡å®™*ã€‚
åœ¨ `Type u` å’Œ `Sort u` ä¸­ï¼Œå˜é‡ `u` ä»£è¡¨å®‡å®™çš„*å±‚çº§*ï¼Œå±‚çº§ä¸º `u` çš„å®‡å®™ä»…èƒ½åˆ†ç±»å±‚çº§ä½äº `u` çš„å®‡å®™ã€‚
æœ‰å…³ç±»å‹å®‡å®™çš„æ›´å¤šç»†èŠ‚ï¼Œè¯·å‚é˜… [Theorem Proving in Lean ç›¸å…³ç« èŠ‚][tpil universes]ã€‚

æ­£å¦‚ç±»å‹å‚æ•°å…è®¸å¤šæ€å®šä¹‰ç”¨äºå¤šç§ç±»å‹ï¼Œå®‡å®™å‚æ•°ï¼ˆç”±å®‡å®™å˜é‡è¡¨ç¤ºï¼‰å…è®¸å®šä¹‰ç”¨äºä»»æ„æ‰€éœ€å±‚çº§ã€‚
è™½ç„¶ Lean ä¸»è¦è‡ªåŠ¨å¤„ç†å®‡å®™å±‚çº§ï¼Œä½†æ˜¾å¼å£°æ˜å¯åœ¨ç¼–å†™ç­¾åæ—¶æä¾›æ›´å¤šæ§åˆ¶ã€‚
`universe` å…³é”®å­—å…è®¸åœ¨å®šä¹‰é›†åˆä¸­ä½¿ç”¨å£°æ˜çš„å®‡å®™å˜é‡ï¼ŒLean å°†ç¡®ä¿è¿™äº›å®šä¹‰ä¸€è‡´ä½¿ç”¨å®ƒä»¬ã€‚

[tpil universes]: https://lean-lang.org/theorem_proving_in_lean4/dependent_type_theory.html#types-as-objects
(Theorem Proving in Lean ä¸­çš„ç±»å‹å®‡å®™)

```lean
/- æ˜¾å¼ç±»å‹å®‡å®™å‚æ•° -/
def idâ‚.{u} (Î± : Type u) (a : Î±) := a

/- éšå¼ç±»å‹å®‡å®™å‚æ•°ï¼Œç­‰ä»·äº `idâ‚`ã€‚éœ€å¯ç”¨é€‰é¡¹ `autoImplicit true`ï¼ˆé»˜è®¤å¯ç”¨ï¼‰ -/
def idâ‚‚ (Î± : Type u) (a : Î±) := a

/- æ˜¾å¼ç‹¬ç«‹å®‡å®™å˜é‡å£°æ˜ï¼Œç­‰ä»·äº `idâ‚` å’Œ `idâ‚‚` -/
universe u
def idâ‚ƒ (Î± : Type u) (a : Î±) := a
```

æŠ€æœ¯ç»†èŠ‚ï¼šè‹¥å®‡å®™å˜é‡ä»…ç”¨äºå®šä¹‰çš„å³ä¾§ä¸”æœªé¢„å…ˆå£°æ˜ï¼Œå°†å¼•å‘é”™è¯¯ã€‚

```lean
def Lâ‚.{u} := List (Type u)

-- def Lâ‚‚ := List (Type u) -- é”™è¯¯ï¼š`æœªçŸ¥å®‡å®™å±‚çº§ 'u'`

universe u
def Lâ‚ƒ := List (Type u)
```

ç¤ºä¾‹ï¼š

```lean
universe u v w

structure Pair (Î± : Type u) (Î² : Type v) : Type (max u v) where
  a : Î±
  b : Î²

#check Pair.{v, w}
-- Pair : Type v â†’ Type w â†’ Type (max v w)
```

## unseal
Defined in: `Lean.Parser.commandUnseal__`

`unseal foo` å‘½ä»¤ç¡®ä¿ `foo` çš„å®šä¹‰æœªå¯†å°ï¼Œå³æ ‡è®°ä¸º `[semireducible]`ï¼ˆé»˜è®¤å¯è§„çº¦è®¾ç½®ï¼‰ã€‚
æ­¤å‘½ä»¤åœ¨éœ€è¦å…è®¸è¯æ˜ä¸­å¯¹ `foo` è¿›è¡Œä¸€å®šç¨‹åº¦çš„è§„çº¦æ—¶æœ‰ç”¨ã€‚

åœ¨åŠŸèƒ½ä¸Šï¼Œ`unseal foo` ç­‰åŒäº `attribute [local semireducible] foo`ã€‚åº”ç”¨æ­¤å±æ€§ä¼šä½¿ `foo` ä»…åœ¨å±€éƒ¨ä½œç”¨åŸŸå†…åŠå¯çº¦ã€‚

## unset_option
å®šä¹‰äºï¼š`Lean.Elab.Command.unsetOption`

å–æ¶ˆè®¾ç½®ç”¨æˆ·é€‰é¡¹

## unsuppress_compilation
å®šä¹‰äºï¼š`commandUnsuppress_compilationIn_`

å‘½ä»¤ `unsuppress_compilation in def foo : ...` ç¡®ä¿å³ä½¿ `suppress_compilation` å¤„äºæ¿€æ´»çŠ¶æ€ï¼Œè¯¥å®šä¹‰ä»ä¼šè¢«ç¼–è¯‘ä¸ºå¯æ‰§è¡Œä»£ç ã€‚

## variable
å®šä¹‰äºï¼š`Lean.Parser.Command.variable`

å£°æ˜ä¸€ä¸ªæˆ–å¤šä¸ªç±»å‹åŒ–å˜é‡ï¼Œæˆ–ä¿®æ”¹å·²å£°æ˜å˜é‡çš„éšå¼æ€§ã€‚

å¼•å…¥å¯åœ¨åŒä¸€ `namespace` æˆ– `section` å—å†…å®šä¹‰ä¸­ä½¿ç”¨çš„å˜é‡ã€‚å½“å®šä¹‰ä¸­æåŠå˜é‡æ—¶ï¼ŒLean ä¼šå°†å…¶ä½œä¸ºè¯¥å®šä¹‰çš„å‚æ•°æ·»åŠ ã€‚è¿™åœ¨ç¼–å†™è®¸å¤šå…·æœ‰å…±åŒå‚æ•°çš„å®šä¹‰æ—¶ç‰¹åˆ«æœ‰ç”¨ï¼ˆå‚è§ä¸‹é¢çš„ç¤ºä¾‹ï¼‰ã€‚

å˜é‡å£°æ˜å…·æœ‰ä¸å¸¸è§„å‡½æ•°å‚æ•°ç›¸åŒçš„çµæ´»æ€§ã€‚ç‰¹åˆ«æ˜¯å®ƒä»¬å¯ä»¥æ˜¯[æ˜¾å¼ã€éšå¼][binder docs]ï¼Œæˆ–[å®ä¾‹éšå¼][tpil classes]ï¼ˆæ­¤æ—¶å®ƒä»¬å¯ä»¥æ˜¯åŒ¿åçš„ï¼‰ã€‚ä¾‹å¦‚ï¼Œå¯ä»¥é€šè¿‡ `variable {x}` å°†æ˜¾å¼å˜é‡ `x` è½¬æ¢ä¸ºéšå¼ã€‚æ³¨æ„ï¼Œå½“å‰åº”é¿å…åŒæ—¶æ›´æ”¹å˜é‡ç»‘å®šæ–¹å¼å’Œå£°æ˜æ–°å˜é‡ï¼›æœ‰å…³æ­¤ä¸»é¢˜çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚è§[é—®é¢˜ 2789]ã€‚

åœ¨*å®šç†ä½“*ï¼ˆå³è¯æ˜ï¼‰ä¸­ï¼Œå˜é‡ä¸ä¼šåŸºäºä½¿ç”¨æƒ…å†µè¢«åŒ…å«ï¼Œä»¥ç¡®ä¿å¯¹è¯æ˜çš„æ›´æ”¹ä¸ä¼šå½±å“æ•´ä½“å®šç†çš„é™ˆè¿°ã€‚ç›¸åï¼Œå˜é‡ä»…åœ¨å®šç†å¤´éƒ¨æˆ– `include` å‘½ä»¤ä¸­æåŠè¿‡ï¼Œæˆ–è€…ä½œä¸ºå®ä¾‹éšå¼ä¸”ä»…ä¾èµ–äºæ­¤ç±»å˜é‡æ—¶ï¼Œæ‰å¯¹è¯æ˜å¯ç”¨ã€‚

æœ‰å…³æ›´è¯¦ç»†çš„è®¨è®ºï¼Œè¯·å‚é˜… [*å®šç†è¯æ˜ä¸­çš„å˜é‡ä¸èŠ‚*][tpil vars]ã€‚

[tpil vars]:
https://lean-lang.org/theorem_proving_in_lean4/dependent_type_theory.html#variables-and-sections
ï¼ˆå®šç†è¯æ˜ä¸­çš„å˜é‡ä¸èŠ‚ï¼‰[tpil classes]:
https://lean-lang.org/theorem_proving_in_lean4/type_classes.html ï¼ˆå®šç†è¯æ˜ä¸­çš„ç±»å‹ç±»ï¼‰[binder docs]:
https://leanprover-community.github.io/mathlib4_docs/Lean/Expr.html#Lean.BinderInfo ï¼ˆBinderInfo ç±»å‹çš„æ–‡æ¡£ï¼‰[issue 2789]: https://github.com/leanprover/lean4/issues/2789 ï¼ˆGitHub ä¸Šçš„é—®é¢˜ 2789ï¼‰

ç¤ºä¾‹ï¼š

```lean
section
  variable
    {Î± : Type u}      -- éšå¼
    (a : Î±)           -- æ˜¾å¼
    [instBEq : BEq Î±] -- å®ä¾‹éšå¼ï¼Œå…·å
    [Hashable Î±]      -- å®ä¾‹éšå¼ï¼ŒåŒ¿å

  def isEqual (b : Î±) : Bool :=
    a == b

  #check isEqual
  -- isEqual.{u} {Î± : Type u} (a : Î±) [instBEq : BEq Î±] (b : Î±) : Bool

  variable
    {a} -- ç°åœ¨ `a` æ˜¯éšå¼çš„

  def eqComm {b : Î±} := a == b â†” b == a

  #check eqComm
  -- eqComm.{u} {Î± : Type u} {a : Î±} [instBEq : BEq Î±] {b : Î±} : Prop
end
```

ä»¥ä¸‹å±•ç¤ºäº†ä½¿ç”¨ `variable` æå–å®šä¹‰å‚æ•°çš„å…¸å‹ç”¨æ³•ï¼š

```lean
variable (Src : Type)

structure Logger where
  trace : List (Src Ã— String)
#check Logger
-- Logger (Src : Type) : Type

namespace Logger
  -- å°† `Src : Type` åˆ‡æ¢ä¸ºéšå¼ï¼Œç›´åˆ° `end Logger`
  variable {Src}

  def empty : Logger Src where
    trace := []
  #check empty
  -- Logger.empty {Src : Type} : Logger Src

  variable (log : Logger Src)

  def len :=
    log.trace.length
  #check len
  -- Logger.len {Src : Type} (log : Logger Src) : Nat

  variable (src : Src) [BEq Src]

  -- æ­¤æ—¶æ‰€æœ‰ `log`ã€`src`ã€`Src` åŠ `BEq` å®ä¾‹å‡å¯æˆä¸ºå‚æ•°

  def filterSrc :=
    log.trace.filterMap
      fun (src', str') => if src' == src then some str' else none
  #check filterSrc
  -- Logger.filterSrc {Src : Type} (log : Logger Src) (src : Src) [instâœ : BEq Src] : List String

  def lenSrc :=
    log.filterSrc src |>.length
  #check lenSrc
  -- Logger.lenSrc {Src : Type} (log : Logger Src) (src : Src) [instâœ : BEq Src] : Nat
end Logger
```

ä»¥ä¸‹ç¤ºä¾‹å±•ç¤ºäº†å˜é‡åœ¨è¯æ˜ä¸­çš„å¯ç”¨æ€§ï¼š
```lean
variable
  {Î± : Type}    -- åœ¨è¯æ˜ä¸­å¯ç”¨ï¼Œå› é€šè¿‡ `a` é—´æ¥æåŠ
  [ToString Î±]  -- åœ¨è¯æ˜ä¸­å¯ç”¨ï¼Œå›  `Î±` è¢«åŒ…å«
  (a : Î±)       -- åœ¨è¯æ˜ä¸­å¯ç”¨ï¼Œå› åœ¨å¤´éƒ¨æåŠ
  {Î² : Type}    -- åœ¨è¯æ˜ä¸­ä¸å¯ç”¨
  [ToString Î²]  -- åœ¨è¯æ˜ä¸­ä¸å¯ç”¨

theorem ex : a = a := rfl
```
åœ¨è¯æ˜ç²¾åŒ–åï¼Œå°†ç”Ÿæˆä»¥ä¸‹è­¦å‘Šä»¥çªå‡ºæœªä½¿ç”¨çš„å‡è®¾ï¼š
```lean
åŒ…å«çš„èŠ‚å˜é‡ '[ToString Î±]' åœ¨ 'ex' ä¸­æœªä½¿ç”¨ï¼Œè¯·è€ƒè™‘æ’é™¤å®ƒ
```
åœ¨æ­¤ç±»æƒ…å†µä¸‹ï¼Œåº”å°†æœ‰é—®é¢˜çš„å˜é‡å£°æ˜ä¸‹ç§»æˆ–æ”¾å…¥èŠ‚ä¸­ï¼Œä»…è®©ä¾èµ–å®ƒçš„å®šç†è·Ÿéšè‡³èŠ‚ç»“æŸã€‚

## variable?
å®šä¹‰äºï¼š`Mathlib.Command.Variable.variable?`

`variable?` å‘½ä»¤ä¸ `variable` è¯­æ³•ç›¸åŒï¼Œä½†ä¼šè‡ªåŠ¨æ’å…¥æ‰€éœ€ä½†ç¼ºå¤±çš„å®ä¾‹å‚æ•°ã€‚å®ƒä¸ä¼šæ·»åŠ å¯ä»å½“å‰ä¸Šä¸‹æ–‡ä¸­å…¶ä»–å˜é‡æ¨å¯¼å‡ºçš„å˜é‡ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œè¯¥å‘½ä»¤æ£€æŸ¥å˜é‡æ˜¯å¦æœªè¢«ä¹‹å‰çš„å˜é‡éšå«ï¼Œä½†*ä¸*æ£€æŸ¥ä¹‹å‰çš„å˜é‡æ˜¯å¦æœªè¢«ä¹‹åçš„å˜é‡éšå«ã€‚ä¸ `variable` ä¸åŒï¼Œ`variable?` ä¸æ”¯æŒæ›´æ”¹å˜é‡ç»‘å®šç±»å‹ã€‚

`variable?` å‘½ä»¤ä¼šå»ºè®®å°†å…¶è‡ªèº«æ›¿æ¢ä¸ºå½¢å¦‚ `variable? ...binders... => ...binders...` çš„å‘½ä»¤ã€‚`=>` åçš„ç»‘å®šå™¨æ˜¯å®Œæ•´çš„ç»‘å®šå™¨åˆ—è¡¨ã€‚å½“å­˜åœ¨æ­¤ `=>` å­å¥æ—¶ï¼Œå‘½ä»¤éªŒè¯æ‰©å±•åçš„ç»‘å®šå™¨æ˜¯å¦ä¸ `=>` åçš„ç»‘å®šå™¨åŒ¹é…ã€‚æ­¤ä¸¾æ—¨åœ¨å¸®åŠ©ä½¿ç”¨ `variable?` çš„ä»£ç å¯¹ç±»å‹ç±»å±‚æ¬¡ç»“æ„çš„å˜åŒ–ä¿æŒå¼¹æ€§ï¼Œè‡³å°‘æ­¤é™„åŠ ä¿¡æ¯å¯ç”¨äºè°ƒè¯•å¯èƒ½å‡ºç°çš„é—®é¢˜ã€‚ä¹Ÿå¯å°† `variable? ...binders... =>` æ›¿æ¢ä¸º `variable`ã€‚

æ ¸å¿ƒç®—æ³•æ˜¯å°è¯•é€ä¸€ç²¾åŒ–ç»‘å®šå™¨ï¼Œæ¯å½“å‡ºç°ç±»å‹ç±»å®ä¾‹æ¨æ–­å¤±è´¥æ—¶ï¼Œåˆæˆç»‘å®šå™¨è¯­æ³•å¹¶å°†å…¶æ·»åŠ åˆ°ç»‘å®šå™¨åˆ—è¡¨å¹¶é‡è¯•ï¼Œé€’å½’è¿›è¡Œã€‚æ­¤è¿‡ç¨‹ä¸ä¿è¯ç»™å‡ºâ€œæ­£ç¡®â€çš„ç»‘å®šå™¨åˆ—è¡¨ã€‚

æ ‡æœ‰ `variable_alias` å±æ€§çš„ç»“æ„å¯ä½œä¸ºä¸€ç³»åˆ—ç±»å‹ç±»çš„åˆ«åã€‚ä¾‹å¦‚ï¼Œç»™å®š
```lean
@[variable_alias]
structure VectorSpace (k V : Type*) [Field k] [AddCommGroup V] [Module k V]
```
åˆ™ `variable? [VectorSpace k V]` ç­‰åŒäº `variable {k V : Type*} [Field k] [AddCommGroup V] [Module k V]`ï¼Œå‡è®¾å½“å‰ä½œç”¨åŸŸä¸­ `k` å’Œ `V` æ²¡æœ‰é¢„å…ˆå­˜åœ¨çš„å®ä¾‹ã€‚æ³¨æ„ï¼Œè¿™ä¸æ˜¯ç®€å•æ›¿æ¢ï¼šå®ƒä»…æ·»åŠ æ— æ³•ä»å½“å‰ä½œç”¨åŸŸä¸­å…¶ä»–å˜é‡æ¨æ–­å‡ºçš„å®ä¾‹ã€‚

è­¦å‘Šï¼šæ ¸å¿ƒç®—æ³•ä¾èµ–ç¾è§‚æ‰“å°ï¼Œå› æ­¤è‹¥ç»‘å®šå™¨ä¸­çš„é¡¹æ— æ³•å¾€è¿”ï¼Œæ­¤ç®—æ³•å¯èƒ½å¤±è´¥ã€‚ä½†è¯¥ç®—æ³•æ”¯æŒå¦‚ `[âˆ€ i, F i]` çš„é‡åŒ–ç»‘å®šå™¨ã€‚

## variables
å®šä¹‰äºï¼š`Mathlib.Tactic.variables`

`variables` å‘½ä»¤çš„è¯­æ³•ï¼šæ­¤å‘½ä»¤ä»…ä¸ºå­˜æ ¹ï¼Œä»…æç¤ºåœ¨ Lean 4 ä¸­å·²æ›´åä¸º `variable`ã€‚

## whatsnew
å®šä¹‰äºï¼š`Mathlib.WhatsNew.commandWhatsnewIn__`

`whatsnew in $command` æ‰§è¡Œå‘½ä»¤å¹¶æ‰“å°æ·»åŠ åˆ°ç¯å¢ƒä¸­çš„å£°æ˜ã€‚

## with_weak_namespace
å®šä¹‰äºï¼š`Lean.Elab.Command.commandWith_weak_namespace__`

æ›´æ”¹å½“å‰å‘½åç©ºé—´ï¼Œä½†ä¸ä¼šå¯¼è‡´ä½œç”¨åŸŸå†…äº‹ç‰©é€€å‡ºä½œç”¨åŸŸ

è¯­æ³• ... [Batteries.Tactic.Lemma.lemmaCmd]
ä¸æ”¯æŒ `lemma`ï¼Œè¯·æ”¹ç”¨ `theorem`

è¯­æ³• ... [Lean.Parser.Command.declaration]

è¯­æ³• ... [Lean.Parser.Command.initialize]

è¯­æ³• ... [Lean.Parser.Command.mixfix]

è¯­æ³• ... [Â«lemmaÂ»]
`lemma` ä¸ `theorem` å«ä¹‰ç›¸åŒï¼Œç”¨äºè¡¨ç¤ºâ€œæ¬¡è¦â€å®šç†