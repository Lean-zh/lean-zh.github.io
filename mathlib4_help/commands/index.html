<!doctype html><html lang=en class=no-js> <head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link href=https://leanprover.cn/mathlib4_help/commands/ rel=canonical><link rel=icon href=../../assets/images/favicon.png><meta name=generator content="mkdocs-1.6.1, mkdocs-material-9.6.20"><title>Commands - Lean Prover 中文文档</title><link rel=stylesheet href=../../assets/stylesheets/main.e53b48f4.min.css><link rel=stylesheet href=../../assets/stylesheets/palette.06af60db.min.css><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback"><style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style><link rel=stylesheet href=../../assets/css/admonition-custom.css><link rel=stylesheet href=../../assets/css/custom.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css><script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script></head> <body dir=ltr data-md-color-scheme=default data-md-color-primary=green data-md-color-accent=light-green> <input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off> <input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off> <label class=md-overlay for=__drawer></label> <div data-md-component=skip> <a href=#commands class=md-skip> Skip to content </a> </div> <div data-md-component=announce> </div> <div data-md-color-scheme=default data-md-component=outdated hidden> </div> <header class=md-header data-md-component=header> <nav class="md-header__inner md-grid" aria-label=Header> <a href=../.. title="Lean Prover 中文文档" class="md-header__button md-logo" aria-label="Lean Prover 中文文档" data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg> </a> <label class="md-header__button md-icon" for=__drawer> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg> </label> <div class=md-header__title data-md-component=header-title> <div class=md-header__ellipsis> <div class=md-header__topic> <span class=md-ellipsis> Lean Prover 中文文档 </span> </div> <div class=md-header__topic data-md-component=header-topic> <span class=md-ellipsis> Commands </span> </div> </div> </div> <label class="md-header__button md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg> </label> <div class=md-search data-md-component=search role=dialog> <label class=md-search__overlay for=__search></label> <div class=md-search__inner role=search> <form class=md-search__form name=search> <input type=text class=md-search__input name=query aria-label=Search placeholder=Search autocapitalize=off autocorrect=off autocomplete=off spellcheck=false data-md-component=search-query required> <label class="md-search__icon md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg> </label> <nav class=md-search__options aria-label=Search> <a href=javascript:void(0) class="md-search__icon md-icon" title=Share aria-label=Share data-clipboard data-clipboard-text data-md-component=search-share tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.15c-.05.21-.08.43-.08.66 0 1.61 1.31 2.91 2.92 2.91s2.92-1.3 2.92-2.91A2.92 2.92 0 0 0 18 16.08"/></svg> </a> <button type=reset class="md-search__icon md-icon" title=Clear aria-label=Clear tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg> </button> </nav> </form> <div class=md-search__output> <div class=md-search__scrollwrap tabindex=0 data-md-scrollfix> <div class=md-search-result data-md-component=search-result> <div class=md-search-result__meta> Initializing search </div> <ol class=md-search-result__list role=presentation></ol> </div> </div> </div> </div> </div> <div class=md-header__source> <a href=https://github.com/Lean-zh/Lean-zh.github.io title="Go to repository" class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><!-- Font Awesome Free 7.0.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M439.6 236.1 244 40.5c-5.4-5.5-12.8-8.5-20.4-8.5s-15 3-20.4 8.4L162.5 81l51.5 51.5c27.1-9.1 52.7 16.8 43.4 43.7l49.7 49.7c34.2-11.8 61.2 31 35.5 56.7-26.5 26.5-70.2-2.9-56-37.3L240.3 199v121.9c25.3 12.5 22.3 41.8 9.1 55-6.4 6.4-15.2 10.1-24.3 10.1s-17.8-3.6-24.3-10.1c-17.6-17.6-11.1-46.9 11.2-56v-123c-20.8-8.5-24.6-30.7-18.6-45L142.6 101 8.5 235.1C3 240.6 0 247.9 0 255.5s3 15 8.5 20.4l195.6 195.7c5.4 5.4 12.7 8.4 20.4 8.4s15-3 20.4-8.4l194.7-194.7c5.4-5.4 8.4-12.8 8.4-20.4s-3-15-8.4-20.4"/></svg> </div> <div class=md-source__repository> Lean-zh </div> </a> </div> </nav> </header> <div class=md-container data-md-component=container> <nav class=md-tabs aria-label=Tabs data-md-component=tabs> <div class=md-grid> <ul class=md-tabs__list> <li class=md-tabs__item> <a href=../.. class=md-tabs__link> 主页 </a> </li> <li class=md-tabs__item> <a href=../../projects/verso/ class=md-tabs__link> 项目教程 </a> </li> </ul> </div> </nav> <main class=md-main data-md-component=main> <div class="md-main__inner md-grid"> <div class="md-sidebar md-sidebar--primary" data-md-component=sidebar data-md-type=navigation> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--primary md-nav--lifted" aria-label=Navigation data-md-level=0> <label class=md-nav__title for=__drawer> <a href=../.. title="Lean Prover 中文文档" class="md-nav__button md-logo" aria-label="Lean Prover 中文文档" data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg> </a> Lean Prover 中文文档 </label> <div class=md-nav__source> <a href=https://github.com/Lean-zh/Lean-zh.github.io title="Go to repository" class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><!-- Font Awesome Free 7.0.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M439.6 236.1 244 40.5c-5.4-5.5-12.8-8.5-20.4-8.5s-15 3-20.4 8.4L162.5 81l51.5 51.5c27.1-9.1 52.7 16.8 43.4 43.7l49.7 49.7c34.2-11.8 61.2 31 35.5 56.7-26.5 26.5-70.2-2.9-56-37.3L240.3 199v121.9c25.3 12.5 22.3 41.8 9.1 55-6.4 6.4-15.2 10.1-24.3 10.1s-17.8-3.6-24.3-10.1c-17.6-17.6-11.1-46.9 11.2-56v-123c-20.8-8.5-24.6-30.7-18.6-45L142.6 101 8.5 235.1C3 240.6 0 247.9 0 255.5s3 15 8.5 20.4l195.6 195.7c5.4 5.4 12.7 8.4 20.4 8.4s15-3 20.4-8.4l194.7-194.7c5.4-5.4 8.4-12.8 8.4-20.4s-3-15-8.4-20.4"/></svg> </div> <div class=md-source__repository> Lean-zh </div> </a> </div> <ul class=md-nav__list data-md-scrollfix> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_1> <label class=md-nav__link for=__nav_1 id=__nav_1_label tabindex=0> <span class=md-ellipsis> 主页 </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_1_label aria-expanded=false> <label class=md-nav__title for=__nav_1> <span class="md-nav__icon md-icon"></span> 主页 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../.. class=md-nav__link> <span class=md-ellipsis> Lean-zh </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_2> <label class=md-nav__link for=__nav_2 id=__nav_2_label tabindex=0> <span class=md-ellipsis> 项目教程 </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_2_label aria-expanded=false> <label class=md-nav__title for=__nav_2> <span class="md-nav__icon md-icon"></span> 项目教程 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../projects/verso/ class=md-nav__link> <span class=md-ellipsis> Verso 教程 </span> </a> </li> </ul> </nav> </li> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component=sidebar data-md-type=toc> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--secondary" aria-label="Table of contents"> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> Table of contents </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#adaptation_note class=md-nav__link> <span class=md-ellipsis> #adaptation_note </span> </a> </li> <li class=md-nav__item> <a href=#aesop_rules class=md-nav__link> <span class=md-ellipsis> #aesop_rules </span> </a> </li> <li class=md-nav__item> <a href=#aesop_stats class=md-nav__link> <span class=md-ellipsis> #aesop_stats </span> </a> </li> <li class=md-nav__item> <a href=#allow_unused_tactic class=md-nav__link> <span class=md-ellipsis> #allow_unused_tactic </span> </a> </li> <li class=md-nav__item> <a href=#check class=md-nav__link> <span class=md-ellipsis> #check </span> </a> </li> <li class=md-nav__item> <a href=#check_assertions class=md-nav__link> <span class=md-ellipsis> #check_assertions </span> </a> </li> <li class=md-nav__item> <a href=#check_failure class=md-nav__link> <span class=md-ellipsis> #check_failure </span> </a> </li> <li class=md-nav__item> <a href=#check_simp class=md-nav__link> <span class=md-ellipsis> #check_simp </span> </a> </li> <li class=md-nav__item> <a href=#check_simp_1 class=md-nav__link> <span class=md-ellipsis> #check_simp </span> </a> </li> <li class=md-nav__item> <a href=#check_tactic class=md-nav__link> <span class=md-ellipsis> #check_tactic </span> </a> </li> <li class=md-nav__item> <a href=#check_tactic_failure class=md-nav__link> <span class=md-ellipsis> #check_tactic_failure </span> </a> </li> <li class=md-nav__item> <a href=#conv class=md-nav__link> <span class=md-ellipsis> #conv </span> </a> </li> <li class=md-nav__item> <a href=#count_heartbeats class=md-nav__link> <span class=md-ellipsis> #count_heartbeats </span> </a> </li> <li class=md-nav__item> <a href=#count_heartbeats_1 class=md-nav__link> <span class=md-ellipsis> #count_heartbeats </span> </a> </li> <li class=md-nav__item> <a href=#count_heartbeats_2 class=md-nav__link> <span class=md-ellipsis> #count_heartbeats! </span> </a> </li> <li class=md-nav__item> <a href=#discr_tree_key class=md-nav__link> <span class=md-ellipsis> #discr_tree_key </span> </a> </li> <li class=md-nav__item> <a href=#discr_tree_simp_key class=md-nav__link> <span class=md-ellipsis> #discr_tree_simp_key </span> </a> </li> <li class=md-nav__item> <a href=#eval class=md-nav__link> <span class=md-ellipsis> #eval! </span> </a> </li> <li class=md-nav__item> <a href=#exit class=md-nav__link> <span class=md-ellipsis> #exit </span> </a> </li> <li class=md-nav__item> <a href=#explode class=md-nav__link> <span class=md-ellipsis> #explode </span> </a> </li> <li class=md-nav__item> <a href=#_1 class=md-nav__link> <span class=md-ellipsis> 概述 </span> </a> </li> <li class=md-nav__item> <a href=#_2 class=md-nav__link> <span class=md-ellipsis> 详细说明 </span> </a> </li> <li class=md-nav__item> <a href=#find class=md-nav__link> <span class=md-ellipsis> #find </span> </a> </li> <li class=md-nav__item> <a href=#find_home class=md-nav__link> <span class=md-ellipsis> #find_home </span> </a> </li> <li class=md-nav__item> <a href=#find_syntax class=md-nav__link> <span class=md-ellipsis> #find_syntax </span> </a> </li> <li class=md-nav__item> <a href=#guard class=md-nav__link> <span class=md-ellipsis> #guard </span> </a> </li> <li class=md-nav__item> <a href=#guard_expr class=md-nav__link> <span class=md-ellipsis> #guard_expr </span> </a> </li> <li class=md-nav__item> <a href=#guard_msgs class=md-nav__link> <span class=md-ellipsis> #guard_msgs </span> </a> </li> <li class=md-nav__item> <a href=#help class=md-nav__link> <span class=md-ellipsis> #help </span> </a> </li> <li class=md-nav__item> <a href=#help_1 class=md-nav__link> <span class=md-ellipsis> #help </span> </a> </li> <li class=md-nav__item> <a href=#help_2 class=md-nav__link> <span class=md-ellipsis> #help </span> </a> </li> <li class=md-nav__item> <a href=#help_3 class=md-nav__link> <span class=md-ellipsis> #help </span> </a> </li> <li class=md-nav__item> <a href=#help_4 class=md-nav__link> <span class=md-ellipsis> #help </span> </a> </li> <li class=md-nav__item> <a href=#help_5 class=md-nav__link> <span class=md-ellipsis> #help </span> </a> </li> <li class=md-nav__item> <a href=#help_6 class=md-nav__link> <span class=md-ellipsis> #help </span> </a> </li> <li class=md-nav__item> <a href=#help_7 class=md-nav__link> <span class=md-ellipsis> #help </span> </a> </li> <li class=md-nav__item> <a href=#help_8 class=md-nav__link> <span class=md-ellipsis> #help </span> </a> </li> <li class=md-nav__item> <a href=#html class=md-nav__link> <span class=md-ellipsis> #html </span> </a> </li> <li class=md-nav__item> <a href=#import_bumps class=md-nav__link> <span class=md-ellipsis> #import_bumps </span> </a> </li> <li class=md-nav__item> <a href=#info_trees class=md-nav__link> <span class=md-ellipsis> #info_trees </span> </a> </li> <li class=md-nav__item> <a href=#instances class=md-nav__link> <span class=md-ellipsis> #instances </span> </a> </li> <li class=md-nav__item> <a href=#instances_1 class=md-nav__link> <span class=md-ellipsis> #instances </span> </a> </li> <li class=md-nav__item> <a href=#kerodon_tags class=md-nav__link> <span class=md-ellipsis> #kerodon_tags </span> </a> </li> <li class=md-nav__item> <a href=#leansearch class=md-nav__link> <span class=md-ellipsis> #leansearch </span> </a> </li> <li class=md-nav__item> <a href=#lint class=md-nav__link> <span class=md-ellipsis> #lint </span> </a> </li> <li class=md-nav__item> <a href=#list_linters class=md-nav__link> <span class=md-ellipsis> #list_linters </span> </a> </li> <li class=md-nav__item> <a href=#long_instances class=md-nav__link> <span class=md-ellipsis> #long_instances </span> </a> </li> <li class=md-nav__item> <a href=#long_names class=md-nav__link> <span class=md-ellipsis> #long_names </span> </a> </li> <li class=md-nav__item> <a href=#loogle class=md-nav__link> <span class=md-ellipsis> #loogle </span> </a> </li> <li class=md-nav__item> <a href=#loogle_1 class=md-nav__link> <span class=md-ellipsis> Loogle 使用方式 </span> </a> </li> <li class=md-nav__item> <a href=#loogle_2 class=md-nav__link> <span class=md-ellipsis> #loogle </span> </a> </li> <li class=md-nav__item> <a href=#loogle_3 class=md-nav__link> <span class=md-ellipsis> Loogle 使用方式 </span> </a> </li> <li class=md-nav__item> <a href=#min_imports class=md-nav__link> <span class=md-ellipsis> #min_imports </span> </a> </li> <li class=md-nav__item> <a href=#min_imports_1 class=md-nav__link> <span class=md-ellipsis> #min_imports </span> </a> </li> <li class=md-nav__item> <a href=#min_imports_2 class=md-nav__link> <span class=md-ellipsis> #min_imports </span> </a> </li> <li class=md-nav__item> <a href=#minimize_imports class=md-nav__link> <span class=md-ellipsis> #minimize_imports </span> </a> </li> <li class=md-nav__item> <a href=#moogle class=md-nav__link> <span class=md-ellipsis> #moogle </span> </a> </li> <li class=md-nav__item> <a href=#norm_num class=md-nav__link> <span class=md-ellipsis> #norm_num </span> </a> </li> <li class=md-nav__item> <a href=#parse class=md-nav__link> <span class=md-ellipsis> #parse </span> </a> </li> <li class=md-nav__item> <a href=#print class=md-nav__link> <span class=md-ellipsis> #print </span> </a> </li> <li class=md-nav__item> <a href=#print_1 class=md-nav__link> <span class=md-ellipsis> #print </span> </a> </li> <li class=md-nav__item> <a href=#print_2 class=md-nav__link> <span class=md-ellipsis> #print </span> </a> </li> <li class=md-nav__item> <a href=#print_3 class=md-nav__link> <span class=md-ellipsis> #print </span> </a> </li> <li class=md-nav__item> <a href=#print_4 class=md-nav__link> <span class=md-ellipsis> #print </span> </a> </li> <li class=md-nav__item> <a href=#print_5 class=md-nav__link> <span class=md-ellipsis> #print </span> </a> </li> <li class=md-nav__item> <a href=#print_6 class=md-nav__link> <span class=md-ellipsis> #print </span> </a> </li> <li class=md-nav__item> <a href=#print_fun_prop_theorems class=md-nav__link> <span class=md-ellipsis> #print_fun_prop_theorems </span> </a> </li> <li class=md-nav__item> <a href=#push_neg class=md-nav__link> <span class=md-ellipsis> #push_neg </span> </a> </li> <li class=md-nav__item> <a href=#reduce class=md-nav__link> <span class=md-ellipsis> #reduce </span> </a> </li> <li class=md-nav__item> <a href=#reset_min_imports class=md-nav__link> <span class=md-ellipsis> #reset_min_imports </span> </a> </li> <li class=md-nav__item> <a href=#sample class=md-nav__link> <span class=md-ellipsis> #sample </span> </a> </li> <li class=md-nav__item> <a href=#search class=md-nav__link> <span class=md-ellipsis> #search </span> </a> </li> <li class=md-nav__item> <a href=#show_kind class=md-nav__link> <span class=md-ellipsis> #show_kind </span> </a> </li> <li class=md-nav__item> <a href=#show_unused class=md-nav__link> <span class=md-ellipsis> #show_unused </span> </a> </li> <li class=md-nav__item> <a href=#simp class=md-nav__link> <span class=md-ellipsis> #simp </span> </a> </li> <li class=md-nav__item> <a href=#stacks_tags class=md-nav__link> <span class=md-ellipsis> #stacks_tags </span> </a> </li> <li class=md-nav__item> <a href=#string_diagram class=md-nav__link> <span class=md-ellipsis> #string_diagram </span> </a> </li> <li class=md-nav__item> <a href=#synth class=md-nav__link> <span class=md-ellipsis> #synth </span> </a> </li> <li class=md-nav__item> <a href=#test class=md-nav__link> <span class=md-ellipsis> #test </span> </a> </li> <li class=md-nav__item> <a href=#time class=md-nav__link> <span class=md-ellipsis> #time </span> </a> </li> <li class=md-nav__item> <a href=#trans_imports class=md-nav__link> <span class=md-ellipsis> #trans_imports </span> </a> </li> <li class=md-nav__item> <a href=#unfold class=md-nav__link> <span class=md-ellipsis> #unfold? </span> </a> </li> <li class=md-nav__item> <a href=#version class=md-nav__link> <span class=md-ellipsis> #version </span> </a> </li> <li class=md-nav__item> <a href=#where class=md-nav__link> <span class=md-ellipsis> #where </span> </a> </li> <li class=md-nav__item> <a href=#whnf class=md-nav__link> <span class=md-ellipsis> #whnf </span> </a> </li> <li class=md-nav__item> <a href=#whnfr class=md-nav__link> <span class=md-ellipsis> #whnfR </span> </a> </li> <li class=md-nav__item> <a href=#widget class=md-nav__link> <span class=md-ellipsis> #widget </span> </a> </li> <li class=md-nav__item> <a href=#reset_grind_attrs class=md-nav__link> <span class=md-ellipsis> %reset_grind_attrs </span> </a> </li> <li class=md-nav__item> <a href=#- class=md-nav__link> <span class=md-ellipsis> /-! </span> </a> </li> <li class=md-nav__item> <a href=#add_aesop_rules class=md-nav__link> <span class=md-ellipsis> add_aesop_rules </span> </a> </li> <li class=md-nav__item> <a href=#add_decl_doc class=md-nav__link> <span class=md-ellipsis> add_decl_doc </span> </a> </li> <li class=md-nav__item> <a href=#alias class=md-nav__link> <span class=md-ellipsis> alias </span> </a> </li> <li class=md-nav__item> <a href=#alias_1 class=md-nav__link> <span class=md-ellipsis> alias </span> </a> </li> <li class=md-nav__item> <a href=#assert_exists class=md-nav__link> <span class=md-ellipsis> assert_exists </span> </a> </li> <li class=md-nav__item> <a href=#assert_no_sorry class=md-nav__link> <span class=md-ellipsis> assert_no_sorry </span> </a> </li> <li class=md-nav__item> <a href=#assert_not_exists class=md-nav__link> <span class=md-ellipsis> assert_not_exists </span> </a> </li> <li class=md-nav__item> <a href=#assert_not_imported class=md-nav__link> <span class=md-ellipsis> assert_not_imported </span> </a> </li> <li class=md-nav__item> <a href=#attribute class=md-nav__link> <span class=md-ellipsis> attribute </span> </a> </li> <li class=md-nav__item> <a href=#binder_predicate class=md-nav__link> <span class=md-ellipsis> binder_predicate </span> </a> </li> <li class=md-nav__item> <a href=#builtin_dsimproc class=md-nav__link> <span class=md-ellipsis> builtin_dsimproc </span> </a> </li> <li class=md-nav__item> <a href=#builtin_dsimproc_decl class=md-nav__link> <span class=md-ellipsis> builtin_dsimproc_decl </span> </a> </li> <li class=md-nav__item> <a href=#builtin_grind_propagator class=md-nav__link> <span class=md-ellipsis> builtin_grind_propagator </span> </a> </li> <li class=md-nav__item> <a href=#builtin_simproc class=md-nav__link> <span class=md-ellipsis> builtin_simproc </span> </a> </li> <li class=md-nav__item> <a href=#builtin_simproc_decl class=md-nav__link> <span class=md-ellipsis> builtin_simproc_decl </span> </a> </li> <li class=md-nav__item> <a href=#builtin_simproc_pattern class=md-nav__link> <span class=md-ellipsis> builtin_simproc_pattern% </span> </a> </li> <li class=md-nav__item> <a href=#class class=md-nav__link> <span class=md-ellipsis> class </span> </a> </li> <li class=md-nav__item> <a href=#compile_def class=md-nav__link> <span class=md-ellipsis> compile_def% </span> </a> </li> <li class=md-nav__item> <a href=#compile_inductive class=md-nav__link> <span class=md-ellipsis> compile_inductive% </span> </a> </li> <li class=md-nav__item> <a href=#count_heartbeats_3 class=md-nav__link> <span class=md-ellipsis> count_heartbeats </span> </a> </li> <li class=md-nav__item> <a href=#declare_aesop_rule_sets class=md-nav__link> <span class=md-ellipsis> declare_aesop_rule_sets </span> </a> </li> <li class=md-nav__item> <a href=#declare_bitwise_int_theorems class=md-nav__link> <span class=md-ellipsis> declare_bitwise_int_theorems </span> </a> </li> <li class=md-nav__item> <a href=#declare_bitwise_uint_theorems class=md-nav__link> <span class=md-ellipsis> declare_bitwise_uint_theorems </span> </a> </li> <li class=md-nav__item> <a href=#declare_command_config_elab class=md-nav__link> <span class=md-ellipsis> declare_command_config_elab </span> </a> </li> <li class=md-nav__item> <a href=#declare_config_elab class=md-nav__link> <span class=md-ellipsis> declare_config_elab </span> </a> </li> <li class=md-nav__item> <a href=#declare_int_theorems class=md-nav__link> <span class=md-ellipsis> declare_int_theorems </span> </a> </li> <li class=md-nav__item> <a href=#declare_simp_like_tactic class=md-nav__link> <span class=md-ellipsis> declare_simp_like_tactic </span> </a> </li> <li class=md-nav__item> <a href=#declare_syntax_cat class=md-nav__link> <span class=md-ellipsis> declare_syntax_cat </span> </a> </li> <li class=md-nav__item> <a href=#declare_uint_simprocs class=md-nav__link> <span class=md-ellipsis> declare_uint_simprocs </span> </a> </li> <li class=md-nav__item> <a href=#declare_uint_theorems class=md-nav__link> <span class=md-ellipsis> declare_uint_theorems </span> </a> </li> <li class=md-nav__item> <a href=#deprecate class=md-nav__link> <span class=md-ellipsis> deprecate </span> </a> </li> <li class=md-nav__item> <a href=#deriving class=md-nav__link> <span class=md-ellipsis> deriving </span> </a> </li> <li class=md-nav__item> <a href=#dsimproc class=md-nav__link> <span class=md-ellipsis> dsimproc </span> </a> </li> <li class=md-nav__item> <a href=#dsimproc_decl class=md-nav__link> <span class=md-ellipsis> dsimproc_decl </span> </a> </li> <li class=md-nav__item> <a href=#elab class=md-nav__link> <span class=md-ellipsis> elab </span> </a> </li> <li class=md-nav__item> <a href=#elab_rules class=md-nav__link> <span class=md-ellipsis> elab_rules </span> </a> </li> <li class=md-nav__item> <a href=#elab_stx_quot class=md-nav__link> <span class=md-ellipsis> elab_stx_quot </span> </a> </li> <li class=md-nav__item> <a href=#end class=md-nav__link> <span class=md-ellipsis> end </span> </a> </li> <li class=md-nav__item> <a href=#erase_aesop_rules class=md-nav__link> <span class=md-ellipsis> erase_aesop_rules </span> </a> </li> <li class=md-nav__item> <a href=#export class=md-nav__link> <span class=md-ellipsis> export </span> </a> </li> <li class=md-nav__item> <a href=#export_1 class=md-nav__link> <span class=md-ellipsis> export </span> </a> </li> <li class=md-nav__item> <a href=#extend_docs class=md-nav__link> <span class=md-ellipsis> extend_docs </span> </a> </li> <li class=md-nav__item> <a href=#gen_injective_theorems class=md-nav__link> <span class=md-ellipsis> gen_injective_theorems% </span> </a> </li> <li class=md-nav__item> <a href=#grind_pattern class=md-nav__link> <span class=md-ellipsis> grind_pattern </span> </a> </li> <li class=md-nav__item> <a href=#grind_propagator class=md-nav__link> <span class=md-ellipsis> grind_propagator </span> </a> </li> <li class=md-nav__item> <a href=#guard_min_heartbeats class=md-nav__link> <span class=md-ellipsis> guard_min_heartbeats </span> </a> </li> <li class=md-nav__item> <a href=#import class=md-nav__link> <span class=md-ellipsis> import </span> </a> </li> <li class=md-nav__item> <a href=#in class=md-nav__link> <span class=md-ellipsis> in </span> </a> </li> <li class=md-nav__item> <a href=#include class=md-nav__link> <span class=md-ellipsis> include </span> </a> </li> <li class=md-nav__item> <a href=#init_grind_norm class=md-nav__link> <span class=md-ellipsis> init_grind_norm </span> </a> </li> <li class=md-nav__item> <a href=#init_quot class=md-nav__link> <span class=md-ellipsis> init_quot </span> </a> </li> <li class=md-nav__item> <a href=#initialize_simps_projections class=md-nav__link> <span class=md-ellipsis> initialize_simps_projections </span> </a> </li> <li class=md-nav__item> <a href=#initialize_simps_projections_1 class=md-nav__link> <span class=md-ellipsis> initialize_simps_projections? </span> </a> </li> <li class=md-nav__item> <a href=#irreducible_def class=md-nav__link> <span class=md-ellipsis> irreducible_def </span> </a> </li> <li class=md-nav__item> <a href=#library_note class=md-nav__link> <span class=md-ellipsis> library_note </span> </a> </li> <li class=md-nav__item> <a href=#lrat_proof class=md-nav__link> <span class=md-ellipsis> lrat_proof </span> </a> </li> <li class=md-nav__item> <a href=#macro class=md-nav__link> <span class=md-ellipsis> macro </span> </a> </li> <li class=md-nav__item> <a href=#macro_rules class=md-nav__link> <span class=md-ellipsis> macro_rules </span> </a> </li> <li class=md-nav__item> <a href=#mk_iff_of_inductive_prop class=md-nav__link> <span class=md-ellipsis> mk_iff_of_inductive_prop </span> </a> </li> <li class=md-nav__item> <a href=#mutual class=md-nav__link> <span class=md-ellipsis> mutual </span> </a> </li> <li class=md-nav__item> <a href=#namespace class=md-nav__link> <span class=md-ellipsis> namespace </span> </a> </li> <li class=md-nav__item> <a href=#noncomputable class=md-nav__link> <span class=md-ellipsis> noncomputable </span> </a> </li> <li class=md-nav__item> <a href=#norm_cast_add_elim class=md-nav__link> <span class=md-ellipsis> norm_cast_add_elim </span> </a> </li> <li class=md-nav__item> <a href=#notation class=md-nav__link> <span class=md-ellipsis> notation </span> </a> </li> <li class=md-nav__item> <a href=#notation3 class=md-nav__link> <span class=md-ellipsis> notation3 </span> </a> </li> <li class=md-nav__item> <a href=#omit class=md-nav__link> <span class=md-ellipsis> omit </span> </a> </li> <li class=md-nav__item> <a href=#open class=md-nav__link> <span class=md-ellipsis> open </span> </a> </li> <li class=md-nav__item> <a href=#open_1 class=md-nav__link> <span class=md-ellipsis> open </span> </a> </li> <li class=md-nav__item> <a href=#proof_wanted class=md-nav__link> <span class=md-ellipsis> proof_wanted </span> </a> </li> <li class=md-nav__item> <a href=#recall class=md-nav__link> <span class=md-ellipsis> recall </span> </a> </li> <li class=md-nav__item> <a href=#recommended_spelling class=md-nav__link> <span class=md-ellipsis> recommended_spelling </span> </a> </li> <li class=md-nav__item> <a href=#register_builtin_option class=md-nav__link> <span class=md-ellipsis> register_builtin_option </span> </a> </li> <li class=md-nav__item> <a href=#register_hint class=md-nav__link> <span class=md-ellipsis> register_hint </span> </a> </li> <li class=md-nav__item> <a href=#register_label_attr class=md-nav__link> <span class=md-ellipsis> register_label_attr </span> </a> </li> <li class=md-nav__item> <a href=#register_option class=md-nav__link> <span class=md-ellipsis> register_option </span> </a> </li> <li class=md-nav__item> <a href=#register_simp_attr class=md-nav__link> <span class=md-ellipsis> register_simp_attr </span> </a> </li> <li class=md-nav__item> <a href=#register_tactic_tag class=md-nav__link> <span class=md-ellipsis> register_tactic_tag </span> </a> </li> <li class=md-nav__item> <a href=#run_cmd class=md-nav__link> <span class=md-ellipsis> run_cmd </span> </a> </li> <li class=md-nav__item> <a href=#run_elab class=md-nav__link> <span class=md-ellipsis> run_elab </span> </a> </li> <li class=md-nav__item> <a href=#run_meta class=md-nav__link> <span class=md-ellipsis> run_meta </span> </a> </li> <li class=md-nav__item> <a href=#scoped class=md-nav__link> <span class=md-ellipsis> scoped </span> </a> </li> <li class=md-nav__item> <a href=#seal class=md-nav__link> <span class=md-ellipsis> seal </span> </a> </li> <li class=md-nav__item> <a href=#section class=md-nav__link> <span class=md-ellipsis> section </span> </a> </li> <li class=md-nav__item> <a href=#set_option class=md-nav__link> <span class=md-ellipsis> set_option </span> </a> </li> <li class=md-nav__item> <a href=#set_premise_selector class=md-nav__link> <span class=md-ellipsis> set_premise_selector </span> </a> </li> <li class=md-nav__item> <a href=#show_panel_widgets class=md-nav__link> <span class=md-ellipsis> show_panel_widgets </span> </a> </li> <li class=md-nav__item> <a href=#simproc class=md-nav__link> <span class=md-ellipsis> simproc </span> </a> </li> <li class=md-nav__item> <a href=#simproc_decl class=md-nav__link> <span class=md-ellipsis> simproc_decl </span> </a> </li> <li class=md-nav__item> <a href=#simproc_pattern class=md-nav__link> <span class=md-ellipsis> simproc_pattern% </span> </a> </li> <li class=md-nav__item> <a href=#sudo class=md-nav__link> <span class=md-ellipsis> sudo </span> </a> </li> <li class=md-nav__item> <a href=#suppress_compilation class=md-nav__link> <span class=md-ellipsis> suppress_compilation </span> </a> </li> <li class=md-nav__item> <a href=#syntax class=md-nav__link> <span class=md-ellipsis> syntax </span> </a> </li> <li class=md-nav__item> <a href=#syntax_1 class=md-nav__link> <span class=md-ellipsis> syntax </span> </a> </li> <li class=md-nav__item> <a href=#tactic_extension class=md-nav__link> <span class=md-ellipsis> tactic_extension </span> </a> </li> <li class=md-nav__item> <a href=#test_extern class=md-nav__link> <span class=md-ellipsis> test_extern </span> </a> </li> <li class=md-nav__item> <a href=#unif_hint class=md-nav__link> <span class=md-ellipsis> unif_hint </span> </a> </li> <li class=md-nav__item> <a href=#universe class=md-nav__link> <span class=md-ellipsis> universe </span> </a> </li> <li class=md-nav__item> <a href=#unseal class=md-nav__link> <span class=md-ellipsis> unseal </span> </a> </li> <li class=md-nav__item> <a href=#unset_option class=md-nav__link> <span class=md-ellipsis> unset_option </span> </a> </li> <li class=md-nav__item> <a href=#unsuppress_compilation class=md-nav__link> <span class=md-ellipsis> unsuppress_compilation </span> </a> </li> <li class=md-nav__item> <a href=#variable class=md-nav__link> <span class=md-ellipsis> variable </span> </a> </li> <li class=md-nav__item> <a href=#variable_1 class=md-nav__link> <span class=md-ellipsis> variable? </span> </a> </li> <li class=md-nav__item> <a href=#variables class=md-nav__link> <span class=md-ellipsis> variables </span> </a> </li> <li class=md-nav__item> <a href=#whatsnew class=md-nav__link> <span class=md-ellipsis> whatsnew </span> </a> </li> <li class=md-nav__item> <a href=#with_weak_namespace class=md-nav__link> <span class=md-ellipsis> with_weak_namespace </span> </a> </li> </ul> </nav> </div> </div> </div> <div class=md-content data-md-component=content> <article class="md-content__inner md-typeset"> <h1 id=commands>Commands<a class=headerlink href=#commands title="Permanent link">&para;</a></h1> <p>Mathlib 版本：<code>e4cf8333e0be712392567e370eead57e05d636a7</code></p> <h2 id=adaptation_note>#adaptation_note<a class=headerlink href=#adaptation_note title="Permanent link">&para;</a></h2> <p>定义于：<code>adaptationNoteCmd</code></p> <p>适配注释（adaptation notes）是用于指示某段代码已因 Lean 核心变动而修改的注释。这类注释通常需要未来采取进一步的维护措施。</p> <h2 id=aesop_rules>#aesop_rules<a class=headerlink href=#aesop_rules title="Permanent link">&para;</a></h2> <p>定义于：<code>Aesop.Frontend.Parser.showRules</code></p> <h2 id=aesop_stats>#aesop_stats<a class=headerlink href=#aesop_stats title="Permanent link">&para;</a></h2> <p>定义于：<code>Aesop.Frontend.Parser.showStats</code></p> <h2 id=allow_unused_tactic>#allow_unused_tactic<a class=headerlink href=#allow_unused_tactic title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Linter.UnusedTactic.«command#allow_unused_tactic!___»</code></p> <p><code>#allow_unused_tactic</code> 接受以空格分隔的标识符列表。这些标识符将被未使用策略检查器（unused tactic linter）允许：即使这些策略不修改目标，也不会触发警告。</p> <p>注意：为此，这些标识符应为各策略的 <code>SyntaxNodeKind</code>。</p> <p>例如，允许 <code>done</code> 和 <code>skip</code> 策略可使用： <div class=highlight><pre><span></span><code><span class=bp>#</span><span class=n>allow_unused_tactic</span><span class=w> </span><span class=n>Lean.Parser.Tactic.done</span><span class=w> </span><span class=n>Lean.Parser.Tactic.skip</span>
</code></pre></div></p> <p>此变更仅作用于当前文件。若需**持久性**变更，请使用 <code>!</code> 标志：命令 <code>#allow_unused_tactic! ids</code> 将使检查器在导入该文件的文件中继续忽略这些策略。</p> <p>命令 <code>#show_kind tac</code> 可辅助查找 <code>SyntaxNodeKind</code>。</p> <h2 id=check>#check<a class=headerlink href=#check title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Command.check</code></p> <h2 id=check_assertions>#check_assertions<a class=headerlink href=#check_assertions title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.AssertNotExist.«command#check_assertions!»</code></p> <p><code>#check_assertions</code> 检索所有声明及声明不存在（包括间接导入文件中的）的导入项，并报告其当前状态： * ✓ 表示声明或导入存在， * × 表示声明或导入不存在。</p> <p>这意味着预期所有检查在 <code>#check_assertions</code> 使用时（通常在构建完整 <code>Mathlib</code> 后）均**成功**。</p> <p>若所有声明及导入在 <code>#check_assertions</code> 使用时均存在，则命令记录信息。否则，发出警告。</p> <p>变体 <code>#check_assertions!</code> 仅打印环境中不存在的声明/导入项。特别地，若一切已导入，则静默，便于测试。</p> <h2 id=check_failure>#check_failure<a class=headerlink href=#check_failure title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Command.check_failure</code></p> <h2 id=check_simp>#check_simp<a class=headerlink href=#check_simp title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.checkSimp</code></p> <p><code>#check_simp t ~&gt; r</code> 检查 <code>simp</code> 是否将 <code>t</code> 规约为 <code>r</code>。</p> <h2 id=check_simp_1>#check_simp<a class=headerlink href=#check_simp_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.checkSimpFailure</code></p> <p><code>#check_simp t !~&gt;</code> 检查 <code>simp</code> 是否规约 <code>t</code> 失败。</p> <h2 id=check_tactic>#check_tactic<a class=headerlink href=#check_tactic title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.checkTactic</code></p> <p><code>#check_tactic t ~&gt; r by commands</code> 在目标为 <code>t</code> 时运行策略序列 <code>commands</code>，并验证结果表达式是否规约为 <code>r</code>。</p> <h2 id=check_tactic_failure>#check_tactic_failure<a class=headerlink href=#check_tactic_failure title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.checkTacticFailure</code></p> <p><code>#check_tactic_failure t by tac</code> 在目标为 <code>t</code> 时运行策略 <code>tac</code>，并验证其是否失败。</p> <h2 id=conv>#conv<a class=headerlink href=#conv title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.Conv.«command#conv_=&gt;_»</code></p> <p>命令 <code>#conv tac =&gt; e</code> 将对 <code>e</code> 运行转换策略 <code>tac</code>，并显示结果表达式（舍弃证明）。例如，<code>#conv rw [true_and_iff] =&gt; True ∧ False</code> 显示 <code>False</code>。另有多个常用转换策略的简写命令：</p> <ul> <li><code>#whnf e</code> 是 <code>#conv whnf =&gt; e</code> 的简写</li> <li><code>#simp e</code> 是 <code>#conv simp =&gt; e</code> 的简写</li> <li><code>#norm_num e</code> 是 <code>#conv norm_num =&gt; e</code> 的简写</li> <li><code>#push_neg e</code> 是 <code>#conv push_neg =&gt; e</code> 的简写</li> </ul> <h2 id=count_heartbeats>#count_heartbeats<a class=headerlink href=#count_heartbeats title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.CountHeartbeats.«command#count_heartbeatsApproximatelyIn__»</code></p> <p><code>#count_heartbeats in cmd</code> 统计封闭命令 <code>cmd</code> 使用的心跳次数。使用 <code>#count_heartbeats</code> 统计后续所有声明的心跳次数。</p> <p>此命令最适用于通过 <code>set_option maxHeartbeats</code> 为长运行声明设置充足但合理的限制。</p> <p>若如此操作，请勿将限制设至最低。随着 <code>simp</code> 集及库其他功能的演进，其他贡献者可能发现其（可能无关的）变更导致声明超出限制。<code>count_heartbearts in</code> 将通过“Try this:”自动建议使用满足条件的最小 <code>2^k * 200000</code> 形式的 <code>set_option maxHeartbeats</code>。</p> <p>注意，通过 <code>IO.getNumHeartbeats</code> 访问的内部心跳计数器粒度比 <code>set_option maxHeartbeats</code> 设置的限制精细 1000 倍。因本命令面向用户，故除以 1000。</p> <p>可选关键字 <code>approximately</code> 将心跳次数向下舍入至最接近的千位。此功能有助于提升测试对心跳次数小变更的稳定性。使用 <code>#count_heartbeats approximately in cmd</code> 启用此功能。</p> <h2 id=count_heartbeats_1>#count_heartbeats<a class=headerlink href=#count_heartbeats_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Linter.CountHeartbeats.«command#count_heartbeatsApproximately»</code></p> <p>“countHeartbeats”检查器统计每个声明的心跳次数。</p> <p>其效果类似于 <code>#count_heartbeats in xxx</code>，但应用于所有声明。</p> <p>注意，检查器仅统计“顶层”声明的心跳次数：其查看 <code>set_option ... in</code> 内部，但不查看如 <code>mutual</code> 块内部。</p> <p>便捷符号 <code>#count_heartbeats</code> 仅将检查器选项设为 true。</p> <h2 id=count_heartbeats_2>#count_heartbeats!<a class=headerlink href=#count_heartbeats_2 title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.CountHeartbeats.«command#count_heartbeats!_In__»</code></p> <p><code>#count_heartbeats! in cmd</code> 运行命令 <code>10</code> 次，报告心跳次数范围及标准差。命令 <code>#count_heartbeats! n in cmd</code> 运行 <code>n</code> 次。</p> <p>示例： <div class=highlight><pre><span></span><code><span class=bp>#</span><span class=n>count_heartbeats</span><span class=bp>!</span><span class=w> </span><span class=k>in</span>
<span class=kd>def</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=mi>37</span>
</code></pre></div> 显示信息 <code>Min: 7 Max: 8 StdDev: 14%</code>。</p> <h2 id=discr_tree_key>#discr_tree_key<a class=headerlink href=#discr_tree_key title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.discrTreeKeyCmd</code></p> <p><code>#discr_tree_key t</code> 打印项 <code>t</code> 的歧视树键（若为单个标识符，则为该常量的类型）。使用默认键生成配置。</p> <p>例如： <div class=highlight><pre><span></span><code>#discr_tree_key (∀ {a n : Nat}, bar a (OfNat.ofNat n))
-- bar _ (@OfNat.ofNat Nat _ _)

#discr_tree_simp_key Nat.add_assoc
-- @HAdd.hAdd Nat Nat Nat _ (@HAdd.hAdd Nat Nat Nat _ _ _) _
</code></pre></div></p> <p><code>#discr_tree_simp_key</code> 类似 <code>#discr_tree_key</code>，但将底层类型视为 simp 引理，即转换为等式并生成左侧键。</p> <h2 id=discr_tree_simp_key>#discr_tree_simp_key<a class=headerlink href=#discr_tree_simp_key title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.discrTreeSimpKeyCmd</code></p> <p><code>#discr_tree_key t</code> 打印项 <code>t</code> 的歧视树键（若为单个标识符，则为该常量的类型）。使用默认键生成配置。</p> <p>例如： <div class=highlight><pre><span></span><code><span class=bp>#</span><span class=n>discr_tree_key</span><span class=w> </span><span class=o>(</span><span class=bp>∀</span><span class=w> </span><span class=o>{</span><span class=n>a</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Nat</span><span class=o>},</span><span class=w> </span><span class=n>bar</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>(</span><span class=n>OfNat.ofNat</span><span class=w> </span><span class=n>n</span><span class=o>))</span>
<span class=c1>-- bar _ (@OfNat.ofNat Nat _ _)</span>

<span class=bp>#</span><span class=n>discr_tree_simp_key</span><span class=w> </span><span class=n>Nat.add_assoc</span>
<span class=c1>-- @HAdd.hAdd Nat Nat Nat _ (@HAdd.hAdd Nat Nat Nat _ _ _) _</span>
</code></pre></div></p> <p><code>#discr_tree_simp_key</code> 类似 <code>#discr_tree_key</code>，但将底层类型视为 simp 引理，即转换为等式并生成左侧键。</p> <h2 id=eval>#eval!<a class=headerlink href=#eval title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Command.evalBang</code></p> <p><code>#eval e</code> 通过编译和求值来评估表达式 <code>e</code>。</p> <ul> <li>该命令尝试使用 <code>ToExpr</code>、<code>Repr</code> 或 <code>ToString</code> 实例来打印结果。</li> <li>如果 <code>e</code> 是类型为 <code>m ty</code> 的单子值，则命令会尝试将单子 <code>m</code> 适配到 <code>#eval</code> 支持的单子之一，包括 <code>IO</code>、<code>CoreM</code>、<code>MetaM</code>、<code>TermElabM</code> 和 <code>CommandElabM</code>。用户可通过定义 <code>MonadEval</code> 实例来扩展支持的单子列表。</li> </ul> <p>由于不健全性，<code>#eval</code> 拒绝评估依赖于 <code>sorry</code> 的表达式（即使间接依赖），因为 <code>sorry</code> 的存在可能导致运行时不稳定和崩溃。可使用 <code>#eval! e</code> 命令覆盖此检查。</p> <p>选项： * 若 <code>eval.pp</code> 为 true（默认：true），则尝试使用 <code>ToExpr</code> 实例以利用常规的漂亮打印机。否则，仅尝试使用 <code>Repr</code> 和 <code>ToString</code> 实例。 * 若 <code>eval.type</code> 为 true（默认：false），则漂亮打印求值值的类型。 * 若 <code>eval.derive.repr</code> 为 true（默认：true），则当无其他方式打印结果时，尝试自动派生 <code>Repr</code> 实例。</p> <p>另见：<code>#reduce e</code> 用于通过项归约进行求值。</p> <h2 id=exit>#exit<a class=headerlink href=#exit title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Command.exit</code></p> <h2 id=explode>#explode<a class=headerlink href=#explode title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Explode.«command#explode_»</code></p> <p><code>#explode expr</code> 以逐行格式显示证明项，类似于Fitch风格证明或Metamath证明风格。</p> <p>例如，分解以下定理：</p> <div class=highlight><pre><span></span><code><span class=bp>#</span><span class=n>explode</span><span class=w> </span><span class=n>iff_of_true</span>
</code></pre></div> <p>生成：</p> <div class=highlight><pre><span></span><code><span class=n>iff_of_true</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=bp>∀</span><span class=w> </span><span class=o>{</span><span class=n>a</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=kt>Prop</span><span class=o>},</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=bp>↔</span><span class=w> </span><span class=n>b</span><span class=o>)</span>

<span class=mi>0</span><span class=bp>│</span><span class=w>         </span><span class=bp>│</span><span class=w> </span><span class=n>a</span><span class=w>         </span><span class=bp>├</span><span class=w> </span><span class=kt>Prop</span>
<span class=mi>1</span><span class=bp>│</span><span class=w>         </span><span class=bp>│</span><span class=w> </span><span class=n>b</span><span class=w>         </span><span class=bp>├</span><span class=w> </span><span class=kt>Prop</span>
<span class=mi>2</span><span class=bp>│</span><span class=w>         </span><span class=bp>│</span><span class=w> </span><span class=n>ha</span><span class=w>        </span><span class=bp>├</span><span class=w> </span><span class=n>a</span>
<span class=mi>3</span><span class=bp>│</span><span class=w>         </span><span class=bp>│</span><span class=w> </span><span class=n>hb</span><span class=w>        </span><span class=bp>├</span><span class=w> </span><span class=n>b</span>
<span class=mi>4</span><span class=bp>│</span><span class=w>         </span><span class=bp>│</span><span class=w> </span><span class=n>x</span><span class=bp>✝</span><span class=w>        </span><span class=bp>│</span><span class=w> </span><span class=bp>┌</span><span class=w> </span><span class=n>a</span>
<span class=mi>5</span><span class=bp>│</span><span class=mi>4</span><span class=o>,</span><span class=mi>3</span><span class=w>      </span><span class=bp>│</span><span class=w> </span><span class=bp>∀</span><span class=n>I</span><span class=w>        </span><span class=bp>│</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>b</span>
<span class=mi>6</span><span class=bp>│</span><span class=w>         </span><span class=bp>│</span><span class=w> </span><span class=n>x</span><span class=bp>✝</span><span class=w>        </span><span class=bp>│</span><span class=w> </span><span class=bp>┌</span><span class=w> </span><span class=n>b</span>
<span class=mi>7</span><span class=bp>│</span><span class=mi>6</span><span class=o>,</span><span class=mi>2</span><span class=w>      </span><span class=bp>│</span><span class=w> </span><span class=bp>∀</span><span class=n>I</span><span class=w>        </span><span class=bp>│</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>a</span>
<span class=mi>8</span><span class=bp>│</span><span class=mi>5</span><span class=o>,</span><span class=mi>7</span><span class=w>      </span><span class=bp>│</span><span class=w> </span><span class=n>Iff.intro</span><span class=w> </span><span class=bp>│</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>↔</span><span class=w> </span><span class=n>b</span>
<span class=mi>9</span><span class=bp>│</span><span class=mi>0</span><span class=o>,</span><span class=mi>1</span><span class=o>,</span><span class=mi>2</span><span class=o>,</span><span class=mi>3</span><span class=o>,</span><span class=mi>8</span><span class=bp>│</span><span class=w> </span><span class=bp>∀</span><span class=n>I</span><span class=w>        </span><span class=bp>│</span><span class=w> </span><span class=bp>∀</span><span class=w> </span><span class=o>{</span><span class=n>a</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=kt>Prop</span><span class=o>},</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=bp>↔</span><span class=w> </span><span class=n>b</span><span class=o>)</span>
</code></pre></div> <h2 id=_1>概述<a class=headerlink href=#_1 title="Permanent link">&para;</a></h2> <p><code>#explode</code> 命令将定理的主体分解为其组成部分，逐行显示每个表达式构造子。构造子在第三列以某种方式指示，其依赖关系记录在第二列。</p> <p>主要构造子类型包括：</p> <ul> <li> <p>Lambda表达式（<code>Expr.lam</code>）。表达式 <code>fun (h : p) =&gt; s</code> 显示为： <div class=highlight><pre><span></span><code><span class=w> </span><span class=mi>0</span><span class=bp>│</span><span class=w>    </span><span class=bp>│</span><span class=w> </span><span class=n>h</span><span class=w>   </span><span class=bp>│</span><span class=w> </span><span class=bp>┌</span><span class=w> </span><span class=n>p</span>
<span class=w> </span><span class=mi>1</span><span class=bp>│**</span><span class=w>  </span><span class=bp>│</span><span class=w> </span><span class=bp>**</span><span class=w>  </span><span class=bp>│</span><span class=w> </span><span class=bp>│</span><span class=w> </span><span class=n>q</span>
<span class=w> </span><span class=mi>2</span><span class=bp>│</span><span class=mi>1</span><span class=o>,</span><span class=mi>2</span><span class=w> </span><span class=bp>│</span><span class=w> </span><span class=bp>∀</span><span class=n>I</span><span class=w>  </span><span class=bp>│</span><span class=w> </span><span class=bp>∀</span><span class=w> </span><span class=o>(</span><span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>p</span><span class=o>),</span><span class=w> </span><span class=n>q</span>
</code></pre></div> 其中 <code>**</code> 为通配符，且步骤0到1之间可能有中间步骤。嵌套的lambda表达式可合并，<code>∀I</code> 可依赖一系列参数。</p> </li> <li> <p>应用（<code>Expr.app</code>）。表达式 <code>f a b c</code> 显示为： <div class=highlight><pre><span></span><code><span class=mi>0</span><span class=bp>│**</span><span class=w>      </span><span class=bp>│</span><span class=w> </span><span class=n>f</span><span class=w>  </span><span class=bp>│</span><span class=w> </span><span class=n>A</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>B</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>C</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>D</span>
<span class=mi>1</span><span class=bp>│**</span><span class=w>      </span><span class=bp>│</span><span class=w> </span><span class=n>a</span><span class=w>  </span><span class=bp>│</span><span class=w> </span><span class=n>A</span>
<span class=mi>2</span><span class=bp>│**</span><span class=w>      </span><span class=bp>│</span><span class=w> </span><span class=n>b</span><span class=w>  </span><span class=bp>│</span><span class=w> </span><span class=n>B</span>
<span class=mi>3</span><span class=bp>│**</span><span class=w>      </span><span class=bp>│</span><span class=w> </span><span class=n>c</span><span class=w>  </span><span class=bp>│</span><span class=w> </span><span class=n>C</span>
<span class=mi>1</span><span class=bp>│</span><span class=mi>0</span><span class=o>,</span><span class=mi>1</span><span class=o>,</span><span class=mi>2</span><span class=o>,</span><span class=mi>3</span><span class=w> </span><span class=bp>│</span><span class=w> </span><span class=bp>∀</span><span class=n>E</span><span class=w> </span><span class=bp>│</span><span class=w> </span><span class=n>D</span>
</code></pre></div> 各步骤间可能有中间步骤。特殊情况下，若 <code>f</code> 为常量，可省略，显示为： <div class=highlight><pre><span></span><code><span class=mi>0</span><span class=bp>│**</span><span class=w>    </span><span class=bp>│</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>│</span><span class=w> </span><span class=n>A</span>
<span class=mi>1</span><span class=bp>│**</span><span class=w>    </span><span class=bp>│</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=bp>│</span><span class=w> </span><span class=n>B</span>
<span class=mi>2</span><span class=bp>│**</span><span class=w>    </span><span class=bp>│</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=bp>│</span><span class=w> </span><span class=n>C</span>
<span class=mi>3</span><span class=bp>│</span><span class=mi>1</span><span class=o>,</span><span class=mi>2</span><span class=o>,</span><span class=mi>3</span><span class=w> </span><span class=bp>│</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=bp>│</span><span class=w> </span><span class=n>D</span>
</code></pre></div></p> </li> <li> <p>Let表达式（<code>Expr.letE</code>）无特殊显示方式，但确保在 <code>let x := v; b</code> 中先处理 <code>v</code> 再处理 <code>b</code>，而非先进行zeta归约。这避免lambda合并和应用合并使含 <code>let</code> 的证明难以解释。</p> </li> <li> <p>其他内容（常量、fvars等）显示 <code>x : X</code> 为： <div class=highlight><pre><span></span><code><span class=mi>0</span><span class=bp>│</span><span class=w>  </span><span class=bp>│</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>│</span><span class=w> </span><span class=n>X</span>
</code></pre></div></p> </li> </ul> <h2 id=_2>详细说明<a class=headerlink href=#_2 title="Permanent link">&para;</a></h2> <p><code>#explode</code> 的输出为四列Fitch风格证明图，模仿Metamath的<a href=http://us.metamath.org/mpeuni/ru.html>此类显示</a>。列头为“步骤”、“假设”、“引用”、“类型”（或Metamath中的“表达式”）： * <strong>步骤</strong>：证明中每行的递增序号，用于假设字段。 * <strong>假设</strong>：当前步骤的直接子项。这些是当前步骤表达式的子表达式步骤号。对于定理应用，为定理参数；对于全称量词，为所有绑定变量及结论。 * <strong>引用</strong>：应用的定理名称。这在Metamath中明确，但Lean中某些特殊步骤可能因证明项结构不完全匹配而有长名称。 * 若定理为 <code>foo (x y : Z) : A x -&gt; B y -&gt; C x y</code>： * 引用字段为 <code>foo</code>， * <code>x</code> 和 <code>y</code> 被抑制，因项构造不具趣味， * 假设字段引用证明 <code>A x</code> 和 <code>B y</code> 的步骤。对应证明项如 <code>@foo x y pA pB</code>，其中 <code>pA</code> 和 <code>pB</code> 为子证明。 * 假设列中，被抑制项被省略，包括应被抑制但未被抑制的项（尤其是lambda参数）。 TODO：实现配置选项以使用 <code>_</code> 而非步骤号表示被抑制项。 * 若证明项头部为局部常量或lambda，则引用字段显示 <code>∀E</code>（全称消除）。例如，<code>h : A -&gt; B</code> 和 <code>ha : A</code> 通过 <code>h ha</code> 证明 <code>b</code>，则重新解释为 <code>∀E h ha</code>，其中 <code>∀E</code> 为（n元）假言推理。 * 若证明项为lambda，则使用 <code>∀I</code>（全称引入）引用lambda体。缩进级别增加，括号包围lambda体的证明，起始于标有lambda变量名及其类型的步骤，终止于 <code>∀I</code> 步骤。Metamath无此类步骤，但风格基于一阶逻辑的Fitch证明。</p> <h2 id=find>#find<a class=headerlink href=#find title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.Find.«command#find_»</code></p> <h2 id=find_home>#find_home<a class=headerlink href=#find_home title="Permanent link">&para;</a></h2> <p>定义于：<code>«command#find_home!_»</code></p> <p>尽可能在导入层次结构的高处找到命名声明可能存在的位置。 使用 <code>#find_home!</code> 将强制移除当前文件。注意，在含 <code>import Mathlib</code> 的文件中使用效果最佳。</p> <p>即使使用 <code>#find_home! lemma</code>，当前文件仍可能为唯一建议。原因是 <code>#find_home!</code> 扫描当前文件下方的导入图，选择包含出现在 <code>lemma</code> 中的声明的文件（排除当前文件本身），并寻找这些文件的所有最小上界。</p> <p>简单示例，若 <code>lemma</code> 在仅导入 <code>A.lean</code> 和 <code>B.lean</code> 的文件中，且各使用一个引理，则 <code>#find_home! lemma</code> 返回当前文件。</p> <h2 id=find_syntax>#find_syntax<a class=headerlink href=#find_syntax title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.FindSyntax.«command#find_syntax_Approx»</code></p> <p><code>#find_syntax</code> 命令接受字符串 <code>str</code>，并从环境中检索所有包含 <code>str</code> 的 <code>syntax</code> 项候选。</p> <p>其还粗略尝试重新生成语法外观：仅为示意语法可能形式，不保证正确性。</p> <p>可选尾随 <code>approx</code>（如 <code>#find_syntax "∘" approx</code>）仅意图使测试更稳定：不输出现有语法声明的精确总数，而是返回其向下取整至前一个100的倍数。</p> <h2 id=guard>#guard<a class=headerlink href=#guard title="Permanent link">&para;</a></h2> <p>定义于: <code>Lean.Parser.Command.guardCmd</code></p> <p>用于检查表达式求值结果为 <code>true</code> 的命令。</p> <p><code>#guard e</code> 对 <code>e</code> 进行细部化，确保其类型为 <code>Bool</code> 后求值，并检查结果是否为 <code>true</code>。该表达式在细部化时*不会*包含使用 <code>variable</code> 声明的变量，因为这些变量无法被求值。</p> <p>由于使用了强制转换，只要命题 <code>p</code> 是可判定的，即可直接书写 <code>#guard p</code> 而无需写成 <code>#guard decide p</code>。一个推论是，若存在可判定的等式，则可直接书写 <code>#guard a = b</code>。需注意这与直接检查 <code>a</code> 和 <code>b</code> 是否求值为相同对象并不完全相同，因为它使用了 <code>DecidableEq</code> 实例来进行求值。</p> <p>注意：此命令使用非受信任的求值器，因此 <code>#guard</code> 通过*并不*代表表达式等于 <code>true</code> 的证明。</p> <h2 id=guard_expr>#guard_expr<a class=headerlink href=#guard_expr title="Permanent link">&para;</a></h2> <p>定义于: <code>Lean.Parser.Command.guardExprCmd</code></p> <p>用于检查两个表达式相等性的命令。 * <code>#guard_expr e = e'</code> 检查 <code>e</code> 和 <code>e'</code> 在可约透明度下是否定义等价。 * <code>#guard_expr e =~ e'</code> 检查 <code>e</code> 和 <code>e'</code> 在默认透明度下是否定义等价。 * <code>#guard_expr e =ₛ e'</code> 检查 <code>e</code> 和 <code>e'</code> 是否语法等价。 * <code>#guard_expr e =ₐ e'</code> 检查 <code>e</code> 和 <code>e'</code> 是否 α 等价。</p> <p>此为 <code>guard_expr</code> 策略的命令版本。</p> <h2 id=guard_msgs>#guard_msgs<a class=headerlink href=#guard_msgs title="Permanent link">&para;</a></h2> <p>定义于: <code>Lean.guardMsgsCmd</code></p> <p><code>/-- ... -/ #guard_msgs in cmd</code> 捕获命令 <code>cmd</code> 生成的消息并检查其是否与文档字符串内容匹配。</p> <p>基础示例： <div class=highlight><pre><span></span><code><span class=sd>/--</span>
<span class=sd>error: 未知标识符 &#39;x&#39;</span>
<span class=sd>-/</span>
<span class=bp>#</span><span class=n>guard_msgs</span><span class=w> </span><span class=k>in</span>
<span class=kd>example</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>α</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=n>x</span>
</code></pre></div> 此示例检查是否存在该错误并消费该消息。</p> <p>默认情况下，该命令捕获所有消息，但可调整过滤条件。例如，仅选择警告： <div class=highlight><pre><span></span><code><span class=sd>/--</span>
<span class=sd>warning: 声明使用了 &#39;sorry&#39;</span>
<span class=sd>-/</span>
<span class=bp>#</span><span class=n>guard_msgs</span><span class=o>(</span><span class=n>warning</span><span class=o>)</span><span class=w> </span><span class=k>in</span>
<span class=kd>example</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>α</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=gr>sorry</span>
</code></pre></div> 或仅选择错误： <div class=highlight><pre><span></span><code><span class=bp>#</span><span class=n>guard_msgs</span><span class=o>(</span><span class=n>error</span><span class=o>)</span><span class=w> </span><span class=k>in</span>
<span class=kd>example</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>α</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=gr>sorry</span>
</code></pre></div> 在前例中，由于未捕获警告，<code>sorry</code> 处会产生警告。若需完全丢弃警告，可使用： <div class=highlight><pre><span></span><code><span class=bp>#</span><span class=n>guard_msgs</span><span class=o>(</span><span class=n>error</span><span class=o>,</span><span class=w> </span><span class=n>drop</span><span class=w> </span><span class=n>warning</span><span class=o>)</span><span class=w> </span><span class=k>in</span>
<span class=kd>example</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>α</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=gr>sorry</span>
</code></pre></div></p> <p>一般情况下，<code>#guard_msgs</code> 接受括号内的逗号分隔配置项列表： <div class=highlight><pre><span></span><code><span class=bp>#</span><span class=n>guard_msgs</span><span class=w> </span><span class=o>(</span><span class=n>configElt</span><span class=o>,</span><span class=bp>*</span><span class=o>)</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>cmd</span>
</code></pre></div> 默认配置列表为 <code>(all, whitespace := normalized, ordering := exact)</code>。</p> <p>消息过滤器（按从左到右顺序处理）： - <code>info</code>、<code>warning</code>、<code>error</code>：捕获指定严重级别的消息。 - <code>all</code>：捕获所有消息（默认）。 - <code>drop info</code>、<code>drop warning</code>、<code>drop error</code>：丢弃指定严重级别的消息。 - <code>drop all</code>：丢弃所有消息。</p> <p>空白处理（在修剪首尾空白后）： - <code>whitespace := exact</code> 要求空白完全匹配。 - <code>whitespace := normalized</code> 在匹配前将所有换行符转换为空格（默认）。允许折行。 - <code>whitespace := lax</code> 在匹配前将空白合并为单个空格。</p> <p>消息顺序： - <code>ordering := exact</code> 使用消息的精确顺序（默认）。 - <code>ordering := sorted</code> 按字典序排序消息。适用于测试命令消息顺序不确定的情况。</p> <p>例如，<code>#guard_msgs (error, drop all) in cmd</code> 表示检查错误并丢弃其他所有消息。</p> <p>命令细部化器对 <code>#guard_msgs</code> 的静态检查有特殊支持。<code>#guard_msgs</code> 自身希望捕获静态检查警告，因此将其附加的命令视为顶层命令进行细部化。然而，命令细部化器会为*所有*顶层命令运行静态检查，包括 <code>#guard_msgs</code> 自身，这会导致重复或未捕获的静态检查警告。顶层命令细部化器仅在 <code>#guard_msgs</code> 不存在时运行静态检查。</p> <h2 id=help>#help<a class=headerlink href=#help title="Permanent link">&para;</a></h2> <p>定义于: <code>Batteries.Tactic.«command#help_Term+____»</code></p> <p>命令 <code>#help term</code> 显示当前环境中定义的所有项语法。详见 <code>#help cat</code>。</p> <h2 id=help_1>#help<a class=headerlink href=#help_1 title="Permanent link">&para;</a></h2> <p>定义于: <code>Batteries.Tactic.«command#help_Cat+______»</code></p> <p>命令 <code>#help cat C</code> 显示当前环境中语法类别 <code>C</code> 定义的所有语法。 每个语法的格式如下： <div class=highlight><pre><span></span><code><span class=bp>##</span><span class=w> </span><span class=n>first</span>
<span class=bp>定义于</span><span class=o>:</span><span class=w> </span><span class=ss>`Parser.tactic.first</span><span class=bp>`</span>

<span class=w>  </span><span class=ss>`first</span><span class=w> </span><span class=bp>|</span><span class=w> </span><span class=n>tac</span><span class=w> </span><span class=bp>|</span><span class=w> </span><span class=bp>...`</span><span class=w> </span><span class=bp>依次运行每个</span><span class=w> </span><span class=ss>`tac</span><span class=bp>`</span><span class=w> </span><span class=bp>直至成功，否则失败。</span>
</code></pre></div> 引号内为语法的前导标记（如适用），后跟语法的全名（可点击跳转至定义）及文档。</p> <ul> <li><code>#help cat C id</code> 形式仅显示以 <code>id</code> 开头的语法。</li> <li><code>#help cat+ C</code> 形式额外显示与所列语法相关联的 <code>macro</code> 和 <code>elab</code> 信息。</li> </ul> <h2 id=help_2>#help<a class=headerlink href=#help_2 title="Permanent link">&para;</a></h2> <p>定义于: <code>Batteries.Tactic.«command#help_Command+____»</code></p> <p>命令 <code>#help command</code> 显示当前环境中定义的所有命令。详见 <code>#help cat</code>。</p> <h2 id=help_3>#help<a class=headerlink href=#help_3 title="Permanent link">&para;</a></h2> <p>定义于: <code>Batteries.Tactic.«command#help_AttrAttribute___»</code></p> <p>命令 <code>#help attribute</code>（或简写 <code>#help attr</code>）显示当前环境中定义的所有属性。 每个属性的格式如下： <div class=highlight><pre><span></span><code><span class=o>[</span><span class=n>inline</span><span class=o>]:</span><span class=w> </span><span class=bp>标记定义以始终内联</span>
</code></pre></div> 表示 <code>inline</code> 是可应用于定义的属性，如 <code>@[inline] def foo := 1</code>。（个别属性可能有应用位置限制，详见属性文档。）此处显示属性的 <code>descr</code> 字段及文档字符串。</p> <p><code>#help attr id</code> 形式仅显示以 <code>id</code> 开头的属性。</p> <h2 id=help_4>#help<a class=headerlink href=#help_4 title="Permanent link">&para;</a></h2> <p>定义于: <code>Batteries.Tactic.«command#help_Note___»</code></p> <p><code>#help note "foo"</code> 搜索标签以 "foo" 开头的所有库注，并按标签字母顺序分组显示。该命令仅显示在导入文件或同一文件中该命令行上方声明的库注。</p> <h2 id=help_5>#help<a class=headerlink href=#help_5 title="Permanent link">&para;</a></h2> <p>定义于: <code>Batteries.Tactic.«command#help_Cats___»</code></p> <p>命令 <code>#help cats</code> 显示当前环境中定义的所有语法类别。 每个语法的格式如下： <div class=highlight><pre><span></span><code><span class=n>category</span><span class=w> </span><span class=n>command</span><span class=w> </span><span class=o>[</span><span class=n>Lean.Parser.initFn</span><span class=bp>✝</span><span class=o>]</span>
</code></pre></div> 此处语法类别名为 <code>command</code>，<code>Lean.Parser.initFn✝</code> 为引入该类别声明的名称（常为匿名声明，但可点击跳转至定义）。若存在文档字符串，亦会显示。</p> <p><code>#help cats id</code> 形式仅显示以 <code>id</code> 开头的语法类别。</p> <h2 id=help_6>#help<a class=headerlink href=#help_6 title="Permanent link">&para;</a></h2> <p>定义于: <code>Batteries.Tactic.«command#help_Tactic+____»</code></p> <p>命令 <code>#help tactic</code> 显示当前环境中定义的所有策略。详见 <code>#help cat</code>。</p> <h2 id=help_7>#help<a class=headerlink href=#help_7 title="Permanent link">&para;</a></h2> <p>定义于: <code>Batteries.Tactic.«command#help_Conv+____»</code></p> <p>命令 <code>#help conv</code> 显示当前环境中定义的所有转换策略。详见 <code>#help cat</code>。</p> <h2 id=help_8>#help<a class=headerlink href=#help_8 title="Permanent link">&para;</a></h2> <p>定义于: <code>Batteries.Tactic.«command#help_Option___»</code></p> <p>命令 <code>#help option</code> 显示当前环境中定义的所有选项。 每个选项的格式如下： <div class=highlight><pre><span></span><code><span class=n>option</span><span class=w> </span><span class=n>pp.all</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Bool</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=n>false</span>
<span class=w>  </span><span class=bp>（美观打印器）显示强制转换、隐式参数、证明项、全限定名、宇宙，并在美观打印时禁用</span><span class=w> </span><span class=n>β</span><span class=w> </span><span class=bp>归约和记法</span>
</code></pre></div> 表示 <code>pp.all</code> 为可设置为 <code>Bool</code> 值的选项，默认值为 <code>false</code>。若选项已通过如 <code>set_option pp.all true</code> 修改默认值，将显示 <code>（当前值：true）</code> 的注释。</p> <p><code>#help option id</code> 形式仅显示以 <code>id</code> 开头的选项。</p> <h2 id=html>#html<a class=headerlink href=#html title="Permanent link">&para;</a></h2> <p>定义于: <code>ProofWidgets.HtmlCommand.htmlCmd</code></p> <p>在信息视图中显示 <code>Html</code> 类型的值。</p> <p>输入可为纯值或任何 Lean 元编程单子中的计算（如 <code>CommandElabM Html</code>）。</p> <h2 id=import_bumps>#import_bumps<a class=headerlink href=#import_bumps title="Permanent link">&para;</a></h2> <p>定义于: <code>Mathlib.Linter.MinImports.«command#import_bumps»</code></p> <p><code>minImports</code> 代码检查工具会逐步计算每个文件构建所需的最小导入集。每当检测到新命令需要增加其已计算的（传递）导入时，该工具会发出警告，指出更大的最小导入集。</p> <p>与相关的 <code>#min_imports</code> 命令不同，此检查工具会考虑符号和策略信息。它以增量方式工作，提供更适合拆分文件等信息。</p> <p>另一重要区别是，<code>minImports</code> <em>检查工具</em> 从设置选项为 <code>true</code> 的位置开始向下计算导入，而 <code>#min_imports</code> <em>命令</em> 则从命令所在位置向上查看所需的导入。</p> <h2 id=info_trees>#info_trees<a class=headerlink href=#info_trees title="Permanent link">&para;</a></h2> <p>定义于: <code>Lean.infoTreesCmd</code></p> <p>格式化并打印指定命令的信息树。此功能主要用于调试信息树。</p> <h2 id=instances>#instances<a class=headerlink href=#instances title="Permanent link">&para;</a></h2> <p>定义于: <code>Batteries.Tactic.Instances.instancesCmd</code></p> <p><code>#instances 项</code> 打印给定类的所有实例。例如，<code>#instances Add _</code> 给出所有 <code>Add</code> 实例，<code>#instances Add Nat</code> 给出 <code>Nat</code> 实例。<code>项</code> 可以是出现在 <code>[...]</code> 绑定器中的任何类型。</p> <p>末尾的下划线可省略，<code>#instances Add</code> 与 <code>#instances Add _</code> 等效；该命令会添加元变量，直至参数不再是函数。</p> <p><code>#instances</code> 命令与 <code>#synth</code> 密切相关，但 <code>#synth</code> 执行完整的实例合成算法，而 <code>#instances</code> 仅执行查找潜在实例的第一步。</p> <h2 id=instances_1>#instances<a class=headerlink href=#instances_1 title="Permanent link">&para;</a></h2> <p>定义于: <code>Batteries.Tactic.Instances.«command#instances__:_»</code></p> <p><code>#instances 项</code> 打印给定类的所有实例。例如，<code>#instances Add _</code> 给出所有 <code>Add</code> 实例，<code>#instances Add Nat</code> 给出 <code>Nat</code> 实例。<code>项</code> 可以是出现在 <code>[...]</code> 绑定器中的任何类型。</p> <p>末尾的下划线可省略，<code>#instances Add</code> 与 <code>#instances Add _</code> 等效；该命令会添加元变量，直至参数不再是函数。</p> <p><code>#instances</code> 命令与 <code>#synth</code> 密切相关，但 <code>#synth</code> 执行完整的实例合成算法，而 <code>#instances</code> 仅执行查找潜在实例的第一步。</p> <h2 id=kerodon_tags>#kerodon_tags<a class=headerlink href=#kerodon_tags title="Permanent link">&para;</a></h2> <p>定义于: <code>Mathlib.StacksTag.kerodonTags</code></p> <p><code>#kerodon_tags</code> 命令检索所有具有 <code>kerodon</code> 属性的声明。</p> <p>对每个找到的声明，打印一行： <div class=highlight><pre><span></span><code>&#39;declaration_name&#39; 对应于标签 &#39;declaration_tag&#39;。
</code></pre></div> 变体 <code>#kerodon_tags!</code> 还会在每个摘要行后添加定理陈述。</p> <h2 id=leansearch>#leansearch<a class=headerlink href=#leansearch title="Permanent link">&para;</a></h2> <p>定义于: <code>LeanSearchClient.leansearch_search_cmd</code></p> <p>在 Lean 内搜索 <a href=https://leansearch.net/ >LeanSearch</a>。查询应为以 <code>.</code> 或 <code>?</code> 结尾的字符串。该命令可作为命令、术语或策略使用，如下例所示。在策略模式下，仅显示有效策略。</p> <div class=highlight><pre><span></span><code><span class=bp>#</span><span class=n>leansearch</span><span class=w> </span><span class=s2>&quot;若自然数 n 小于 m，则 n 的后继小于 m 的后继。&quot;</span>

<span class=kd>example</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=bp>#</span><span class=n>leansearch</span><span class=w> </span><span class=s2>&quot;若自然数 n 小于 m，则 n 的后继小于 m 的后继。&quot;</span>

<span class=kd>example</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=mi>3</span><span class=w> </span><span class=bp>≤</span><span class=w> </span><span class=mi>5</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=bp>#</span><span class=n>leansearch</span><span class=w> </span><span class=s2>&quot;若自然数 n 小于 m，则 n 的后继小于 m 的后继。&quot;</span>
<span class=w>  </span><span class=gr>sorry</span>
</code></pre></div> <h2 id=lint>#lint<a class=headerlink href=#lint title="Permanent link">&para;</a></h2> <p>定义于: <code>Batteries.Tactic.Lint.«command#lint+-*Only___»</code></p> <p>命令 <code>#lint</code> 在当前文件运行代码检查工具（默认情况下）。</p> <p><code>#lint only 某检查工具</code> 可用于仅运行单个检查工具。</p> <h2 id=list_linters>#list_linters<a class=headerlink href=#list_linters title="Permanent link">&para;</a></h2> <p>定义于: <code>Batteries.Tactic.Lint.«command#list_linters»</code></p> <p>命令 <code>#list_linters</code> 打印所有可用检查工具的列表。</p> <h2 id=long_instances>#long_instances<a class=headerlink href=#long_instances title="Permanent link">&para;</a></h2> <p>定义于: <code>«command#long_instances_»</code></p> <p>列出所有以 <code>inst</code> 开头的长名称实例，按定义它们的模块分组。此功能有助于查找具有荒谬名称的自动命名实例。</p> <p>使用方式为 <code>#long_names</code> 或 <code>#long_names 100</code> 指定长度。</p> <h2 id=long_names>#long_names<a class=headerlink href=#long_names title="Permanent link">&para;</a></h2> <p>定义于: <code>«command#long_names_»</code></p> <p>列出所有具有长名称的声明，按定义它们的模块分组。使用方式为 <code>#long_names</code> 或 <code>#long_names 100</code> 指定长度。</p> <h2 id=loogle>#loogle<a class=headerlink href=#loogle title="Permanent link">&para;</a></h2> <p>定义于: <code>LeanSearchClient.loogle_cmd</code></p> <p>在 Lean 内搜索 <a href=https://loogle.lean-lang.org/json>Loogle</a>。该命令可作为命令、术语或策略使用，如下例所示。在策略模式下，仅显示有效策略。</p> <div class=highlight><pre><span></span><code><span class=bp>#</span><span class=n>loogle</span><span class=w> </span><span class=n>List</span><span class=w> </span><span class=bp>?</span><span class=n>a</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=bp>?</span><span class=n>a</span>

<span class=kd>example</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=bp>#</span><span class=n>loogle</span><span class=w> </span><span class=n>List</span><span class=w> </span><span class=bp>?</span><span class=n>a</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=bp>?</span><span class=n>a</span>

<span class=kd>example</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=mi>3</span><span class=w> </span><span class=bp>≤</span><span class=w> </span><span class=mi>5</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=bp>#</span><span class=n>loogle</span><span class=w> </span><span class=n>Nat.succ_le_succ</span>
<span class=w>  </span><span class=gr>sorry</span>
</code></pre></div> <h2 id=loogle_1>Loogle 使用方式<a class=headerlink href=#loogle_1 title="Permanent link">&para;</a></h2> <p>Loogle 通过多种方式查找定义和引理：</p> <p>通过常量： 🔍 Real.sin 查找所有陈述中提及正弦函数的引理。</p> <p>通过引理名称子串： 🔍 "differ" 查找所有名称中包含 "differ" 的引理。</p> <p>通过子表达式： 🔍 _ * (_ ^ _) 查找所有陈述中某处包含乘积且第二个参数为某次幂的引理。</p> <p>模式也可非线性，如： 🔍 Real.sqrt ?a * Real.sqrt ?a</p> <p>若模式含有参数，则参数以任意顺序匹配。以下两者均会找到 List.map： 🔍 (?a -&gt; ?b) -&gt; List ?a -&gt; List ?b 🔍 List ?a -&gt; (?a -&gt; ?b) -&gt; List ?b</p> <p>通过主要结论： 🔍 |- tsum _ = _ * tsum _ 查找所有结论（所有 → 和 ∀ 右侧的子表达式）具有给定形状的引理。</p> <p>如前所述，若模式含有参数，则参数以任意顺序匹配引理的假设；例如， 🔍 |- _ &lt; _ → tsum _ &lt; tsum _ 将找到 tsum_lt_tsum，即使假设 f i &lt; g i 并非最后。</p> <p>若传递多个搜索过滤器（以逗号分隔），Loogle 将返回匹配所有过滤器的引理。搜索 🔍 Real.sin, "two", tsum, _ * _, _ ^ _, |- _ &lt; _ → _ 将查找所有提及常量 Real.sin 和 tsum、名称包含 "two" 子串、类型某处包含乘积和幂，并具有 _ &lt; _ 形式假设的引理（若存在此类引理）。元变量（?a）在每个过滤器中独立分配。</p> <h2 id=loogle_2>#loogle<a class=headerlink href=#loogle_2 title="Permanent link">&para;</a></h2> <p>定义于: <code>LeanSearchClient.just_loogle_cmd</code></p> <p>在 Lean 内搜索 <a href=https://loogle.lean-lang.org/json>Loogle</a>。该命令可作为命令、术语或策略使用，如下例所示。在策略模式下，仅显示有效策略。</p> <div class=highlight><pre><span></span><code><span class=bp>#</span><span class=n>loogle</span><span class=w> </span><span class=n>List</span><span class=w> </span><span class=bp>?</span><span class=n>a</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=bp>?</span><span class=n>a</span>

<span class=kd>example</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=bp>#</span><span class=n>loogle</span><span class=w> </span><span class=n>List</span><span class=w> </span><span class=bp>?</span><span class=n>a</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=bp>?</span><span class=n>a</span>

<span class=kd>example</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=mi>3</span><span class=w> </span><span class=bp>≤</span><span class=w> </span><span class=mi>5</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=bp>#</span><span class=n>loogle</span><span class=w> </span><span class=n>Nat.succ_le_succ</span>
<span class=w>  </span><span class=gr>sorry</span>
</code></pre></div> <h2 id=loogle_3>Loogle 使用方式<a class=headerlink href=#loogle_3 title="Permanent link">&para;</a></h2> <p>Loogle 通过多种方式查找定义和引理：</p> <p>通过常量： 🔍 Real.sin 查找所有陈述中提及正弦函数的引理。</p> <p>通过引理名称子串： 🔍 "differ" 查找所有名称中包含 "differ" 的引理。</p> <p>通过子表达式： 🔍 _ * (_ ^ _) 查找所有陈述中某处包含乘积且第二个参数为某次幂的引理。</p> <p>模式也可非线性，如： 🔍 Real.sqrt ?a * Real.sqrt ?a</p> <p>若模式含有参数，则参数以任意顺序匹配。以下两者均会找到 List.map： 🔍 (?a -&gt; ?b) -&gt; List ?a -&gt; List ?b 🔍 List ?a -&gt; (?a -&gt; ?b) -&gt; List ?b</p> <p>通过主要结论： 🔍 |- tsum _ = _ * tsum _ 查找所有结论（所有 → 和 ∀ 右侧的子表达式）具有给定形状的引理。</p> <p>如前所述，若模式含有参数，则参数以任意顺序匹配引理的假设；例如， 🔍 |- _ &lt; _ → tsum _ &lt; tsum _ 将找到 tsum_lt_tsum，即使假设 f i &lt; g i 并非最后。</p> <p>若传递多个搜索过滤器（以逗号分隔），Loogle 将返回匹配所有过滤器的引理。搜索 🔍 Real.sin, "two", tsum, _ * _, _ ^ _, |- _ &lt; _ → _ 将查找所有提及常量 Real.sin 和 tsum、名称包含 "two" 子串、类型某处包含乘积和幂，并具有 _ &lt; _ 形式假设的引理（若存在此类引理）。元变量（?a）在每个过滤器中独立分配。</p> <h2 id=min_imports>#min_imports<a class=headerlink href=#min_imports title="Permanent link">&para;</a></h2> <p>定义于: <code>Mathlib.Command.MinImports.minImpsStx</code></p> <p><code>#min_imports in cmd</code> 扫描语法 <code>cmd</code> 及其经详细阐述后得到的声明，以寻找一组足以使 <code>cmd</code> 正常工作的最小导入集合。</p> <h2 id=min_imports_1>#min_imports<a class=headerlink href=#min_imports_1 title="Permanent link">&para;</a></h2> <p>定义于: <code>Mathlib.Command.MinImports.«command#min_importsIn_»</code></p> <p><code>#min_imports in cmd</code> 扫描语法 <code>cmd</code> 及其经详细阐述后得到的声明，以寻找一组足以使 <code>cmd</code> 正常工作的最小导入集合。</p> <h2 id=min_imports_2>#min_imports<a class=headerlink href=#min_imports_2 title="Permanent link">&para;</a></h2> <p>定义于: <code>«command#min_imports»</code></p> <p>尝试通过分析声明计算此文件所需的最小导入集合。</p> <p>此命令需在文件末尾运行，且不感知语法与策略，因此结果可能仍需手动调整。</p> <h2 id=minimize_imports>#minimize_imports<a class=headerlink href=#minimize_imports title="Permanent link">&para;</a></h2> <p>定义于: <code>«command#minimize_imports»</code></p> <h2 id=moogle>#moogle<a class=headerlink href=#moogle title="Permanent link">&para;</a></h2> <p>定义于: <code>LeanSearchClient.moogle_search_cmd</code></p> <p>在 Lean 内部搜索 <a href=https://www.moogle.ai/api/search>Moogle</a>。<br> 查询应为以 <code>.</code> 或 <code>?</code> 结尾的字符串。该命令可作为命令、项或策略使用，如下例所示。在策略模式下，仅显示有效策略。</p> <div class=highlight><pre><span></span><code><span class=bp>#</span><span class=n>moogle</span><span class=w> </span><span class=s2>&quot;若自然数 n 小于 m，则 n 的后继小于 m 的后继。&quot;</span>

<span class=kd>example</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=bp>#</span><span class=n>moogle</span><span class=w> </span><span class=s2>&quot;若自然数 n 小于 m，则 n 的后继小于 m 的后继。&quot;</span>

<span class=kd>example</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=mi>3</span><span class=w> </span><span class=bp>≤</span><span class=w> </span><span class=mi>5</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=bp>#</span><span class=n>moogle</span><span class=w> </span><span class=s2>&quot;若自然数 n 小于 m，则 n 的后继小于 m 的后继。&quot;</span>
<span class=w>  </span><span class=gr>sorry</span>
</code></pre></div> <h2 id=norm_num>#norm_num<a class=headerlink href=#norm_num title="Permanent link">&para;</a></h2> <p>定义于: <code>Mathlib.Tactic.normNumCmd</code></p> <p>基础用法为 <code>#norm_num e</code>，其中 <code>e</code> 为表达式，将打印 <code>e</code> 的 <code>norm_num</code> 形式。</p> <p>语法：<code>#norm_num</code> (<code>only</code>)? (<code>[</code> 化简引理列表 <code>]</code>)? <code>:</code>? 表达式</p> <p>此命令接受与 <code>#simp</code> 相同的选项。例如可使用 <code>#norm_num [f, g] : e</code> 指定额外化简引理（冒号可选但有助于解析）。<code>only</code> 限制 <code>norm_num</code> 仅使用提供的引理，因此 <code>#norm_num only : e</code> 行为类似于 <code>norm_num1</code>。</p> <p>与 <code>norm_num</code> 不同，此命令在未进行任何化简时不会失败。</p> <p><code>#norm_num</code> 理解局部变量，因此可利用其引入参数。</p> <h2 id=parse>#parse<a class=headerlink href=#parse title="Permanent link">&para;</a></h2> <p>定义于: <code>Mathlib.GuardExceptions.parseCmd</code></p> <p><code>#parse parserFnId =&gt; str</code> 允许捕获解析异常。<br> <code>parserFnId</code> 为 <code>ParserFn</code> 的标识符，<code>str</code> 为 <code>parserFnId</code> 应解析的字符串。</p> <p>若解析成功，则输出被记录；若解析失败，则输出被捕获为异常。</p> <p>无论结果如何，均可使用 <code>#guard_msgs</code> 捕获解析错误。</p> <p>例如，<code>#parse</code> 可如下使用： <div class=highlight><pre><span></span><code><span class=sd>/-- error: &lt;input&gt;:1:3: Stacks 标签必须为 4 个字符 -/</span>
<span class=bp>#</span><span class=n>guard_msgs</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=bp>#</span><span class=n>parse</span><span class=w> </span><span class=n>Mathlib.Stacks.stacksTagFn</span><span class=w> </span><span class=bp>=&gt;</span><span class=w> </span><span class=s2>&quot;A05&quot;</span>
</code></pre></div></p> <h2 id=print>#print<a class=headerlink href=#print title="Permanent link">&para;</a></h2> <p>定义于: <code>Batteries.Tactic.printPrefix</code></p> <p>命令 <code>#print prefix foo</code> 将打印所有以命名空间 <code>foo</code> 开头的定义。</p> <p>例如，以下命令将打印 <code>List</code> 命名空间中的定义：</p> <div class=highlight><pre><span></span><code><span class=k>#print</span><span class=w> </span><span class=kd>prefix</span><span class=w> </span><span class=n>List</span>
</code></pre></div> <p><code>#print prefix</code> 可通过 <code>PrintPrefixConfig</code> 中的标志进行控制，这些标志提供筛选名称与格式化的选项。例如，默认排除内部名称，但可通过配置调整： <div class=highlight><pre><span></span><code><span class=k>#print</span><span class=w> </span><span class=kd>prefix</span><span class=w> </span><span class=o>(</span><span class=n>config</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=o>{</span><span class=n>internals</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=n>true</span><span class=o>})</span><span class=w> </span><span class=n>List</span>
</code></pre></div></p> <p>默认情况下，<code>#print prefix</code> 在每个名称后打印类型。可通过设置 <code>showTypes</code> 为 <code>false</code> 关闭： <div class=highlight><pre><span></span><code><span class=k>#print</span><span class=w> </span><span class=kd>prefix</span><span class=w> </span><span class=o>(</span><span class=n>config</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=o>{</span><span class=n>showTypes</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=n>false</span><span class=o>})</span><span class=w> </span><span class=n>List</span>
</code></pre></div></p> <p>完整标志集可查阅 <code>Lean.Elab.Command.PrintPrefixConfig</code> 文档。</p> <h2 id=print_1>#print<a class=headerlink href=#print_1 title="Permanent link">&para;</a></h2> <p>定义于: <code>Lean.Parser.Command.printAxioms</code></p> <h2 id=print_2>#print<a class=headerlink href=#print_2 title="Permanent link">&para;</a></h2> <p>定义于: <code>Lean.Parser.Command.printTacTags</code></p> <p>显示所有可用策略标签及其文档。</p> <h2 id=print_3>#print<a class=headerlink href=#print_3 title="Permanent link">&para;</a></h2> <p>定义于: <code>Batteries.Tactic.«command#printOpaques_»</code></p> <p>命令 <code>#print opaques X</code> 打印 <code>X</code> 依赖的所有不透明定义。</p> <p>不透明定义包括部分定义与公理。仅列出计算相关上下文中出现的依赖项，证明项内的出现被忽略。此命令有助于判断定义是否可能依赖平台、可能部分或可能不可计算。</p> <p>例如，<code>#print opaques Std.HashMap.insert</code> 显示 <code>Std.HashMap.insert</code> 依赖于不透明定义 <code>System.Platform.getNumBits</code> 与 <code>UInt64.toUSize</code>。因此 <code>Std.HashMap.insert</code> 在 32 位或 64 位平台编译时可能有不同行为。</p> <p><code>#print opaques Stream.forIn</code> 显示 <code>Stream.forIn</code> 可能部分，因其依赖部分定义 <code>Stream.forIn.visit</code>。若输入流无界，<code>Stream.forIn</code> 可能不终止。</p> <p><code>#print opaques Classical.choice</code> 显示 <code>Classical.choice</code> 自身为不透明定义（公理）。而 <code>#print opaques Classical.axiomOfChoice</code> 无输出，因其为命题故计算无关（<code>#print axioms</code> 显示 <code>Classical.axiomOfChoice</code> 依赖 <code>Classical.choice</code> 公理）。</p> <h2 id=print_4>#print<a class=headerlink href=#print_4 title="Permanent link">&para;</a></h2> <p>定义于: <code>Lean.Parser.Command.printEqns</code></p> <h2 id=print_5>#print<a class=headerlink href=#print_5 title="Permanent link">&para;</a></h2> <p>定义于: <code>Batteries.Tactic.«command#printDependents___»</code></p> <p>命令 <code>#print dependents X Y</code> 打印文件中所有传递依赖于 <code>X</code> 或 <code>Y</code> 的声明列表。每个声明后显示其体中直接引用且同样依赖 <code>X</code> 或 <code>Y</code> 的声明列表。</p> <p>例如，下方 <code>#print axioms bar'</code> 显示 <code>bar'</code> 依赖 <code>Classical.choice</code>，但未说明原因。<code>#print dependents Classical.choice</code> 指出 <code>bar'</code> 依赖 <code>Classical.choice</code> 因其使用 <code>foo</code>，而 <code>foo</code> 使用 <code>Classical.em</code>。<code>bar</code> 未被列出因其证明未使用 <code>Classical.choice</code>。 <div class=highlight><pre><span></span><code>import Batteries.Tactic.PrintDependents

theorem foo : x = y ∨ x ≠ y := Classical.em _
theorem bar : 1 = 1 ∨ 1 ≠ 1 := by simp
theorem bar&#39; : 1 = 1 ∨ 1 ≠ 1 := foo

#print axioms bar&#39;
-- &#39;bar&#39;&#39; 依赖公理: [Classical.choice, Quot.sound, propext]

#print dependents Classical.choice
-- foo: Classical.em
-- bar&#39;: foo
</code></pre></div></p> <h2 id=print_6>#print<a class=headerlink href=#print_6 title="Permanent link">&para;</a></h2> <p>定义于: <code>Lean.Parser.Command.print</code></p> <h2 id=print_fun_prop_theorems>#print_fun_prop_theorems<a class=headerlink href=#print_fun_prop_theorems title="Permanent link">&para;</a></h2> <p>定义于: <code>Mathlib.Meta.FunProp.«command#print_fun_prop_theorems__»</code></p> <p>打印附加于某函数的所有函数属性的命令。</p> <p>例如： <div class=highlight><pre><span></span><code>#print_fun_prop_theorems HAdd.hAdd
</code></pre></div> 可能输出： <div class=highlight><pre><span></span><code>Continuous
  continuous_add, 参数: [4,5], 优先级: 1000
  continuous_add_left, 参数: [5], 优先级: 1000
  continuous_add_right, 参数 [4], 优先级: 1000
  ...
Diferentiable
  Differentiable.add, 参数: [4,5], 优先级: 1000
  Differentiable.add_const, 参数: [4], 优先级: 1000
  Differentiable.const_add, 参数: [5], 优先级: 1000
  ...
</code></pre></div></p> <p>也可仅查看特定函数属性的定理： <div class=highlight><pre><span></span><code>#print_fun_prop_theorems HAdd.hAdd Continuous
</code></pre></div></p> <h2 id=push_neg>#push_neg<a class=headerlink href=#push_neg title="Permanent link">&para;</a></h2> <p>定义于: <code>Mathlib.Tactic.PushNeg.pushNeg</code></p> <p>语法为 <code>#push_neg e</code>，其中 <code>e</code> 为表达式，将打印 <code>e</code> 的 <code>push_neg</code> 形式。</p> <p><code>#push_neg</code> 理解局部变量，因此可利用其引入参数。</p> <h2 id=reduce>#reduce<a class=headerlink href=#reduce title="Permanent link">&para;</a></h2> <p>定义于: <code>Lean.reduceCmd</code></p> <p><code>#reduce &lt;表达式&gt;</code> 将表达式 <code>&lt;表达式&gt;</code> 规约至其正规形式。此过程涉及应用规约规则直至无法继续规约。</p> <p>默认情况下，表达式中的证明与类型不被规约。使用修饰符 <code>(proofs := true)</code> 与 <code>(types := true)</code> 可规约之。注意命题在 Lean 中为类型。</p> <p><strong>警告：</strong> 此操作可能计算量较大，尤其对于复杂表达式。</p> <p>建议对简单表达式使用 <code>#eval &lt;表达式&gt;</code> 进行求值/执行。</p> <h2 id=reset_min_imports>#reset_min_imports<a class=headerlink href=#reset_min_imports title="Permanent link">&para;</a></h2> <p>定义于: <code>Mathlib.Linter.«command#reset_min_imports»</code></p> <p><code>#reset_min_imports</code> 将当前累积的导入列表设置为空。</p> <h2 id=sample>#sample<a class=headerlink href=#sample title="Permanent link">&para;</a></h2> <p>定义于: <code>Plausible.«command#sample_»</code></p> <p><code>#sample type</code>，其中 <code>type</code> 具有 <code>SampleableExt</code> 的实例，使用递增的大小参数打印十次 <code>type</code> 类型的随机值。</p> <div class=highlight><pre><span></span><code><span class=bp>#</span><span class=n>sample</span><span class=w> </span><span class=n>Nat</span>
<span class=c1>-- 输出</span>
<span class=c1>-- 0</span>
<span class=c1>-- 0</span>
<span class=c1>-- 2</span>
<span class=c1>-- 24</span>
<span class=c1>-- 64</span>
<span class=c1>-- 76</span>
<span class=c1>-- 5</span>
<span class=c1>-- 132</span>
<span class=c1>-- 8</span>
<span class=c1>-- 449</span>
<span class=c1>-- 或其他数字序列</span>

<span class=bp>#</span><span class=n>sample</span><span class=w> </span><span class=n>List</span><span class=w> </span><span class=n>Int</span>
<span class=c1>-- 输出</span>
<span class=c1>-- []</span>
<span class=c1>-- [1, 1]</span>
<span class=c1>-- [-7, 9, -6]</span>
<span class=c1>-- [36]</span>
<span class=c1>-- [-500, 105, 260]</span>
<span class=c1>-- [-290]</span>
<span class=c1>-- [17, 156]</span>
<span class=c1>-- [-2364, -7599, 661, -2411, -3576, 5517, -3823, -968]</span>
<span class=c1>-- [-643]</span>
<span class=c1>-- [11892, 16329, -15095, -15461]</span>
<span class=c1>-- 或其他内容</span>
</code></pre></div> <h2 id=search>#search<a class=headerlink href=#search title="Permanent link">&para;</a></h2> <p>定义于: <code>LeanSearchClient.search_cmd</code></p> <p>根据选项 <code>leansearchclient.backend</code> 的设置，在 Lean 中搜索 <a href=https://www.moogle.ai/api/search>Moogle</a> 或 <a href=https://leansearch.net/ >LeanSearch</a>。查询应为以 <code>.</code> 或 <code>?</code> 结尾的字符串。该命令可作为命令、项和策略使用，如下例所示。在策略模式下，仅显示有效的策略。</p> <p><div class=highlight><pre><span></span><code><span class=bp>#</span><span class=n>search</span><span class=w> </span><span class=s2>&quot;若自然数 n 小于 m，则 n 的后继小于 m 的后继。&quot;</span>

<span class=kd>example</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=bp>#</span><span class=n>search</span><span class=w> </span><span class=s2>&quot;若自然数 n 小于 m，则 n 的后继小于 m 的后继。&quot;</span>

<span class=kd>example</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=mi>3</span><span class=w> </span><span class=bp>≤</span><span class=w> </span><span class=mi>5</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=bp>#</span><span class=n>search</span><span class=w> </span><span class=s2>&quot;若自然数 n 小于 m，则 n 的后继小于 m 的后继。&quot;</span>
<span class=w>  </span><span class=gr>sorry</span>
</code></pre></div> 在策略模式下，若未提供查询字符串，则基于目标状态查询 <a href=https://premise-search.com>LeanStateSearch</a>。</p> <h2 id=show_kind>#show_kind<a class=headerlink href=#show_kind title="Permanent link">&para;</a></h2> <p>定义于: <code>Mathlib.Linter.UnusedTactic.«command#show_kind_»</code></p> <p><code>#show_kind tac</code> 接受一个策略的语法作为输入，并返回该策略语法树头部的 <code>SyntaxNodeKind</code>。</p> <p>输入的语法需要可解析，但可以*极其*简略。例如，要查看 <code>refine</code> 策略的 <code>SyntaxNodeKind</code>，可以使用： <div class=highlight><pre><span></span><code><span class=bp>#</span><span class=n>show_kind</span><span class=w> </span><span class=n>refine</span><span class=w> </span><span class=n>_</span>
</code></pre></div> 尾随的下划线 <code>_</code> 使语法有效，因为 <code>refine</code> 预期有其他内容。</p> <h2 id=show_unused>#show_unused<a class=headerlink href=#show_unused title="Permanent link">&para;</a></h2> <p>定义于: <code>Batteries.Tactic.ShowUnused.«command#show_unused___»</code></p> <p><code>#show_unused decl1 decl2 ..</code> 将高亮当前文件中未参与声明 <code>decl1</code>、<code>decl2</code> 等定义的所有定理或定义。结果既显示在 <code>#show_unused</code> 的消息中，也显示在声明本身上。 <div class=highlight><pre><span></span><code><span class=kd>def</span><span class=w> </span><span class=n>foo</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=mi>1</span>
<span class=kd>def</span><span class=w> </span><span class=n>baz</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=mi>2</span>
<span class=kd>def</span><span class=w> </span><span class=n>bar</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=n>foo</span>
<span class=bp>#</span><span class=n>show_unused</span><span class=w> </span><span class=n>bar</span><span class=w> </span><span class=c1>-- 高亮 `baz`</span>
</code></pre></div></p> <h2 id=simp>#simp<a class=headerlink href=#simp title="Permanent link">&para;</a></h2> <p>定义于: <code>Mathlib.Tactic.Conv.«command#simpOnly_=&gt;__»</code></p> <ul> <li><code>#simp =&gt; e</code> 对表达式 <code>e</code> 运行 <code>simp</code>，并显示简化后的结果表达式。</li> <li><code>#simp only [lems] =&gt; e</code> 对 <code>e</code> 运行 <code>simp only [lems]</code>。</li> <li><code>=&gt;</code> 是可选的，因此 <code>#simp e</code> 和 <code>#simp only [lems] e</code> 行为相同。主要用于消除表达式 <code>e</code> 与引理之间的歧义。</li> </ul> <h2 id=stacks_tags>#stacks_tags<a class=headerlink href=#stacks_tags title="Permanent link">&para;</a></h2> <p>定义于: <code>Mathlib.StacksTag.stacksTags</code></p> <p><code>#stacks_tags</code> 检索所有具有 <code>stacks</code> 属性的声明。</p> <p>对于每个找到的声明，打印一行： <div class=highlight><pre><span></span><code>&#39;declaration_name&#39; 对应于标签 &#39;declaration_tag&#39;。
</code></pre></div> 变体 <code>#stacks_tags!</code> 在每个摘要行后添加定理陈述。</p> <h2 id=string_diagram>#string_diagram<a class=headerlink href=#string_diagram title="Permanent link">&para;</a></h2> <p>定义于: <code>Mathlib.Tactic.Widget.stringDiagram</code></p> <p>显示给定项的弦图。</p> <p>示例用法： <div class=highlight><pre><span></span><code><span class=c>/-</span><span class=cm> 等式定理的弦图。 -/</span>
<span class=bp>#</span><span class=n>string_diagram</span><span class=w> </span><span class=n>MonoidalCategory.whisker_exchange</span>

<span class=c>/-</span><span class=cm> 态射的弦图。 -/</span>
<span class=kd>variable</span><span class=w> </span><span class=o>{</span><span class=n>C</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=kt>Type</span><span class=w> </span><span class=n>u</span><span class=o>}</span><span class=w> </span><span class=o>[</span><span class=n>Category</span><span class=bp>.</span><span class=o>{</span><span class=n>v</span><span class=o>}</span><span class=w> </span><span class=n>C</span><span class=o>]</span><span class=w> </span><span class=o>[</span><span class=n>MonoidalCategory</span><span class=w> </span><span class=n>C</span><span class=o>]</span><span class=w> </span><span class=o>{</span><span class=n>X</span><span class=w> </span><span class=n>Y</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>C</span><span class=o>}</span><span class=w> </span><span class=o>(</span><span class=n>f</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=mi>𝟙</span><span class=n>_</span><span class=w> </span><span class=n>C</span><span class=w> </span><span class=bp>⟶</span><span class=w> </span><span class=n>X</span><span class=w> </span><span class=bp>⊗</span><span class=w> </span><span class=n>Y</span><span class=o>)</span><span class=w> </span><span class=k>in</span>
<span class=bp>#</span><span class=n>string_diagram</span><span class=w> </span><span class=n>f</span>
</code></pre></div></p> <h2 id=synth>#synth<a class=headerlink href=#synth title="Permanent link">&para;</a></h2> <p>定义于: <code>Lean.Parser.Command.synth</code></p> <h2 id=test>#test<a class=headerlink href=#test title="Permanent link">&para;</a></h2> <p>定义于: <code>Plausible.«command#test_»</code></p> <h2 id=time>#time<a class=headerlink href=#time title="Permanent link">&para;</a></h2> <p>定义于: <code>Lean.Parser.timeCmd</code></p> <p>计时命令的详细阐述，并打印结果（以毫秒为单位）。</p> <p>示例用法： <div class=highlight><pre><span></span><code><span class=kd>set_option</span><span class=w> </span><span class=n>maxRecDepth</span><span class=w> </span><span class=mi>100000</span><span class=w> </span><span class=k>in</span>
<span class=bp>#</span><span class=n>time</span><span class=w> </span><span class=kd>example</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=o>(</span><span class=n>List.range</span><span class=w> </span><span class=mi>500</span><span class=o>)</span><span class=bp>.</span><span class=n>length</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=mi>500</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=n>rfl</span>
</code></pre></div></p> <h2 id=trans_imports>#trans_imports<a class=headerlink href=#trans_imports title="Permanent link">&para;</a></h2> <p>定义于: <code>transImportsStx</code></p> <p><code>#trans_imports</code> 报告当前模块有多少个传递性导入。该命令接受可选的字符串输入：<code>#trans_imports str</code> 还显示名称以 <code>str</code> 开头的传递性导入模块。</p> <p>主要用于测试，该命令还接受可选的 <code>at_most x</code> 输入：若导入数量不超过 <code>x</code>，则消息涉及 <code>x</code>，而非实际可能变化的导入数量。</p> <h2 id=unfold>#unfold?<a class=headerlink href=#unfold title="Permanent link">&para;</a></h2> <p>定义于: <code>Mathlib.Tactic.InteractiveUnfold.unfoldCommand</code></p> <p><code>#unfold? e</code> 显示 <code>e</code> 的所有展开。在策略模式下，请使用 <code>unfold?</code>。</p> <h2 id=version>#version<a class=headerlink href=#version title="Permanent link">&para;</a></h2> <p>定义于: <code>Lean.Parser.Command.version</code></p> <p>显示当前 Lean 版本。打印 <code>Lean.versionString</code>。</p> <h2 id=where>#where<a class=headerlink href=#where title="Permanent link">&para;</a></h2> <p>定义于: <code>Lean.Parser.Command.where</code></p> <p><code>#where</code> 描述当前作用域的状态。包括当前命名空间、<code>open</code> 的命名空间、<code>universe</code> 和 <code>variable</code> 命令，以及通过 <code>set_option</code> 设置的选项。</p> <h2 id=whnf>#whnf<a class=headerlink href=#whnf title="Permanent link">&para;</a></h2> <p>定义于: <code>Mathlib.Tactic.Conv.«command#whnf_»</code></p> <p>命令 <code>#whnf e</code> 将 <code>e</code> 求值至弱头范式（WHNF），即表达式的“头”被约简至原语——lambda 或 forall，或公理或归纳类型。类似于 <code>#reduce e</code>，但不会完全约简表达式，仅暴露第一个构造子。例如： <div class=highlight><pre><span></span><code><span class=kn>open</span><span class=w> </span><span class=n>Nat</span><span class=w> </span><span class=n>List</span>
<span class=kd>set_option</span><span class=w> </span><span class=n>pp.notation</span><span class=w> </span><span class=n>false</span>
<span class=bp>#</span><span class=n>whnf</span><span class=w> </span><span class=o>[</span><span class=mi>1</span><span class=o>,</span><span class=w> </span><span class=mi>2</span><span class=o>,</span><span class=w> </span><span class=mi>3</span><span class=o>]</span><span class=bp>.</span><span class=n>map</span><span class=w> </span><span class=n>succ</span>
<span class=c1>-- cons (succ 1) (map succ (cons 2 (cons 3 nil)))</span>
<span class=k>#reduce</span><span class=w> </span><span class=o>[</span><span class=mi>1</span><span class=o>,</span><span class=w> </span><span class=mi>2</span><span class=o>,</span><span class=w> </span><span class=mi>3</span><span class=o>]</span><span class=bp>.</span><span class=n>map</span><span class=w> </span><span class=n>succ</span>
<span class=c1>-- cons 2 (cons 3 (cons 4 nil))</span>
</code></pre></div> 该表达式的头为 <code>List.cons</code> 构造子，因此可看出列表非空，但子项 <code>Nat.succ 1</code> 和 <code>List.map Nat.succ (List.cons 2 (List.cons 3 List.nil))</code> 仍未被求值。<code>#reduce</code> 等效于对所有子项使用 <code>#whnf</code>。</p> <h2 id=whnfr>#whnfR<a class=headerlink href=#whnfr title="Permanent link">&para;</a></h2> <p>定义于: <code>Mathlib.Tactic.Conv.«command#whnfR_»</code></p> <p>命令 <code>#whnfR e</code> 以可约透明性将 <code>e</code> 求值至弱头范式，即使用 <code>whnf</code> 但仅展开可约定义。</p> <h2 id=widget>#widget<a class=headerlink href=#widget title="Permanent link">&para;</a></h2> <p>定义于: <code>Lean.Widget.widgetCmd</code></p> <p>使用 <code>#widget &lt;widget&gt;</code> 显示面板小部件，使用 <code>#widget &lt;widget&gt; with &lt;props&gt;</code> 显示带有给定属性（props）的小部件。用于调试小部件。</p> <p><code>&lt;widget&gt;</code> 的类型必须实现 <code>Widget.ToModule</code>，<code>&lt;props&gt;</code> 的类型必须实现 <code>Server.RpcEncodable</code>。特别是，<code>&lt;props&gt; : Json</code> 有效。</p> <h2 id=reset_grind_attrs>%reset_grind_attrs<a class=headerlink href=#reset_grind_attrs title="Permanent link">&para;</a></h2> <p>定义于: <code>Lean.Parser.resetGrindAttrs</code></p> <p>重置所有 <code>grind</code> 属性。此命令仅供测试使用，不应用于应用程序。</p> <h2 id=->/-!<a class=headerlink href=#- title="Permanent link">&para;</a></h2> <p>定义于: <code>Lean.Parser.Command.moduleDoc</code></p> <p><code>/-! &lt;text&gt; -/</code> 定义可被文档生成工具显示的*模块文档字符串*。该字符串与文件中的对应位置关联。可在同一文件中多次使用。</p> <h2 id=add_aesop_rules>add_aesop_rules<a class=headerlink href=#add_aesop_rules title="Permanent link">&para;</a></h2> <p>定义于: <code>Aesop.Frontend.Parser.addRules</code></p> <h2 id=add_decl_doc>add_decl_doc<a class=headerlink href=#add_decl_doc title="Permanent link">&para;</a></h2> <p>定义于: <code>Lean.Parser.Command.addDocString</code></p> <p>向现有声明添加文档字符串，替换任何现有文档字符串。提供的文档字符串应作为 <code>add_decl_doc</code> 命令的文档字符串编写，如： <div class=highlight><pre><span></span><code>/-- 我的新文档字符串 -/
add_decl_doc oldDeclaration
</code></pre></div></p> <p>这适用于自动生成的声明，其源代码中无处编写文档字符串。</p> <p>结构中的父投影即为一例： <div class=highlight><pre><span></span><code><span class=kd>structure</span><span class=w> </span><span class=n>Triple</span><span class=w> </span><span class=o>(</span><span class=n>α</span><span class=w> </span><span class=n>β</span><span class=w> </span><span class=n>γ</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=kt>Type</span><span class=o>)</span><span class=w> </span><span class=kd>extends</span><span class=w> </span><span class=n>Prod</span><span class=w> </span><span class=n>α</span><span class=w> </span><span class=n>β</span><span class=w> </span><span class=n>where</span>
<span class=w>  </span><span class=n>thrd</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>γ</span>

<span class=sd>/-- 提取三元组的前两个投影。 -/</span>
<span class=n>add_decl_doc</span><span class=w> </span><span class=n>Triple.toProd</span>
</code></pre></div></p> <p>文档仅可添加至同一模块中的声明。</p> <h2 id=alias>alias<a class=headerlink href=#alias title="Permanent link">&para;</a></h2> <p>定义于: <code>Batteries.Tactic.Alias.alias</code></p> <p>命令 <code>alias name := target</code> 创建 <code>target</code> 的同义词，使用给定名称。</p> <p>命令 <code>alias ⟨fwd, rev⟩ := target</code> 为 iff 定理的正向和反向创建同义词。若仅需一个方向，使用 <code>_</code>。</p> <p>这些命令接受所有与<code>def</code>和<code>theorem</code>相同的修饰符和属性。</p> <h2 id=alias_1>alias<a class=headerlink href=#alias_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Batteries.Tactic.Alias.aliasLR</code></p> <p>命令<code>alias name := target</code>创建<code>target</code>的同义词<code>name</code>。</p> <p>命令<code>alias ⟨fwd, rev⟩ := target</code>为iff定理的正向和反向创建同义词。如果只需要一个方向，使用<code>_</code>。</p> <p>这些命令接受所有与<code>def</code>和<code>theorem</code>相同的修饰符和属性。</p> <h2 id=assert_exists>assert_exists<a class=headerlink href=#assert_exists title="Permanent link">&para;</a></h2> <p>定义于：<code>commandAssert_exists_</code></p> <p><code>assert_exists n</code>是一个用户命令，用于断言当前导入作用域中存在名为<code>n</code>的声明。</p> <p>注意使用名称（如<code>Rat</code>）而非符号（如<code>ℚ</code>）。</p> <h2 id=assert_no_sorry>assert_no_sorry<a class=headerlink href=#assert_no_sorry title="Permanent link">&para;</a></h2> <p>定义于：<code>commandAssert_no_sorry_</code></p> <p>如果给定标识符使用了<code>sorryAx</code>，则抛出错误。</p> <h2 id=assert_not_exists>assert_not_exists<a class=headerlink href=#assert_not_exists title="Permanent link">&para;</a></h2> <p>定义于：<code>commandAssert_not_exists_</code></p> <p><code>assert_not_exists d₁ d₂ ... dₙ</code>是一个用户命令，用于断言当前导入作用域中*不存在*名为<code>d₁ d₂ ... dₙ</code>的声明。</p> <p>注意使用名称（如<code>Rat</code>）而非符号（如<code>ℚ</code>）。</p> <p>在mathlib中可能（谨慎地！）用于强制执行某些文件相互独立的计划。</p> <p>如果在开发mathlib时遇到<code>assert_not_exists</code>命令的错误，可能是因为您向文件引入了新的导入依赖项。</p> <p>在这种情况下，您应重构您的工作（例如通过创建新文件而非向现有文件添加导入）。您*不应*未经事先仔细讨论就删除<code>assert_not_exists</code>语句。</p> <p><code>assert_not_exists</code>语句通常应位于文件顶部，模块文档之后。</p> <h2 id=assert_not_imported>assert_not_imported<a class=headerlink href=#assert_not_imported title="Permanent link">&para;</a></h2> <p>定义于：<code>commandAssert_not_imported_</code></p> <p><code>assert_not_imported m₁ m₂ ... mₙ</code>检查模块<code>m₁ m₂ ... mₙ</code>中的每一个都不在当前文件的传递导入中。</p> <p>该命令当前不检查模块<code>m₁ m₂ ... mₙ</code>是否实际存在。</p> <h2 id=attribute>attribute<a class=headerlink href=#attribute title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Command.attribute</code></p> <h2 id=binder_predicate>binder_predicate<a class=headerlink href=#binder_predicate title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Command.binderPredicate</code></p> <p>声明一个绑定器谓词。例如： <div class=highlight><pre><span></span><code><span class=n>binder_predicate</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=s2>&quot; &gt; &quot;</span><span class=w> </span><span class=n>y</span><span class=o>:</span><span class=n>term</span><span class=w> </span><span class=bp>=&gt;</span><span class=w> </span><span class=bp>`</span><span class=o>(</span><span class=bp>$</span><span class=n>x</span><span class=w> </span><span class=bp>&gt;</span><span class=w> </span><span class=bp>$</span><span class=n>y</span><span class=o>)</span>
</code></pre></div></p> <h2 id=builtin_dsimproc>builtin_dsimproc<a class=headerlink href=#builtin_dsimproc title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.«command__Builtin_dsimproc__[_]_(_):=_»</code></p> <p>一个内置的defeq简化过程。</p> <h2 id=builtin_dsimproc_decl>builtin_dsimproc_decl<a class=headerlink href=#builtin_dsimproc_decl title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.«command_Builtin_dsimproc_decl_(_):=_»</code></p> <p>一个内置的defeq简化过程声明。</p> <h2 id=builtin_grind_propagator>builtin_grind_propagator<a class=headerlink href=#builtin_grind_propagator title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.«command_Builtin_grind_propagator____:=_»</code></p> <p>一个为<code>grind</code>策略设计的内置传播器。</p> <h2 id=builtin_simproc>builtin_simproc<a class=headerlink href=#builtin_simproc title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.«command__Builtin_simproc__[_]_(_):=_»</code></p> <p>一个内置的简化过程。</p> <h2 id=builtin_simproc_decl>builtin_simproc_decl<a class=headerlink href=#builtin_simproc_decl title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.«command_Builtin_simproc_decl_(_):=_»</code></p> <p>一个内置的简化过程声明。</p> <h2 id=builtin_simproc_pattern>builtin_simproc_pattern%<a class=headerlink href=#builtin_simproc_pattern title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.simprocPatternBuiltin</code></p> <p>将模式与内置简化过程关联的辅助命令。</p> <h2 id=class>class<a class=headerlink href=#class title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Command.classAbbrev</code></p> <p>将 <div class=highlight><pre><span></span><code>class abbrev C &lt;params&gt; := D_1, ..., D_n
</code></pre></div> 扩展为 <div class=highlight><pre><span></span><code>class C &lt;params&gt; extends D_1, ..., D_n
attribute [instance] C.mk
</code></pre></div></p> <h2 id=compile_def>compile_def%<a class=headerlink href=#compile_def title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Util.«commandCompile_def%_»</code></p> <p><code>compile_def% Foo.foo</code>为定义<code>Foo.foo</code>添加编译代码。这可用于类型类投影或像<code>List._sizeOf_1</code>这样的定义，默认情况下Lean不会为这些生成编译代码（因为99%的时间不会使用它们）。</p> <h2 id=compile_inductive>compile_inductive%<a class=headerlink href=#compile_inductive title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Util.«commandCompile_inductive%_»</code></p> <p><code>compile_inductive% Foo</code>为递归器<code>Foo.rec</code>创建编译代码，以便在定义中使用<code>Foo.rec</code>而无需将定义标记为<code>noncomputable</code>。</p> <h2 id=count_heartbeats_3>count_heartbeats<a class=headerlink href=#count_heartbeats_3 title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.CountHeartbeats.commandCount_heartbeats</code></p> <p><code>count_heartbeats</code>自"2025-01-12"起已弃用，推荐使用<code>#count_heartbeats</code></p> <h2 id=declare_aesop_rule_sets>declare_aesop_rule_sets<a class=headerlink href=#declare_aesop_rule_sets title="Permanent link">&para;</a></h2> <p>定义于：<code>Aesop.Frontend.Parser.declareRuleSets</code></p> <h2 id=declare_bitwise_int_theorems>declare_bitwise_int_theorems<a class=headerlink href=#declare_bitwise_int_theorems title="Permanent link">&para;</a></h2> <p>定义于：<code>commandDeclare_bitwise_int_theorems__</code></p> <h2 id=declare_bitwise_uint_theorems>declare_bitwise_uint_theorems<a class=headerlink href=#declare_bitwise_uint_theorems title="Permanent link">&para;</a></h2> <p>定义于：<code>commandDeclare_bitwise_uint_theorems__</code></p> <h2 id=declare_command_config_elab>declare_command_config_elab<a class=headerlink href=#declare_command_config_elab title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Elab.Tactic.commandConfigElab</code></p> <h2 id=declare_config_elab>declare_config_elab<a class=headerlink href=#declare_config_elab title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Elab.Tactic.configElab</code></p> <h2 id=declare_int_theorems>declare_int_theorems<a class=headerlink href=#declare_int_theorems title="Permanent link">&para;</a></h2> <p>定义于：<code>commandDeclare_int_theorems__</code></p> <h2 id=declare_simp_like_tactic>declare_simp_like_tactic<a class=headerlink href=#declare_simp_like_tactic title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.declareSimpLikeTactic</code></p> <h2 id=declare_syntax_cat>declare_syntax_cat<a class=headerlink href=#declare_syntax_cat title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Command.syntaxCat</code></p> <h2 id=declare_uint_simprocs>declare_uint_simprocs<a class=headerlink href=#declare_uint_simprocs title="Permanent link">&para;</a></h2> <p>定义于：<code>commandDeclare_uint_simprocs_</code></p> <h2 id=declare_uint_theorems>declare_uint_theorems<a class=headerlink href=#declare_uint_theorems title="Permanent link">&para;</a></h2> <p>定义于：<code>commandDeclare_uint_theorems__</code></p> <h2 id=deprecate>deprecate<a class=headerlink href=#deprecate title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.DeprecateTo.commandDeprecateTo______</code></p> <p>编写 <div class=highlight><pre><span></span><code><span class=n>deprecate</span><span class=w> </span><span class=n>to</span><span class=w> </span><span class=n>new_name</span><span class=w> </span><span class=n>new_name₂</span><span class=w> </span><span class=bp>...</span><span class=w> </span><span class=n>new_nameₙ</span>
<span class=kd>theorem</span><span class=w> </span><span class=n>old_name</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>True</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=bp>.</span><span class=n>intro</span>
</code></pre></div> 其中<code>new_name new_name₂ ... new_nameₙ</code>是一系列标识符，生成<code>Try this</code>建议： <div class=highlight><pre><span></span><code><span class=kd>theorem</span><span class=w> </span><span class=n>new_name</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>True</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=bp>.</span><span class=n>intro</span>

<span class=kd>@[</span><span class=n>deprecated</span><span class=w> </span><span class=o>(</span><span class=n>since</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=s2>&quot;YYYY-MM-DD&quot;</span><span class=o>)</span><span class=kd>]</span><span class=w> </span><span class=n>alias</span><span class=w> </span><span class=n>old_name</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=n>new_name</span>

<span class=kd>@[</span><span class=n>deprecated</span><span class=w> </span><span class=o>(</span><span class=n>since</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=s2>&quot;YYYY-MM-DD&quot;</span><span class=o>)</span><span class=kd>]</span><span class=w> </span><span class=n>alias</span><span class=w> </span><span class=n>old_name₂</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=n>new_name₂</span>
<span class=bp>...</span>

<span class=kd>@[</span><span class=n>deprecated</span><span class=w> </span><span class=o>(</span><span class=n>since</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=s2>&quot;YYYY-MM-DD&quot;</span><span class=o>)</span><span class=kd>]</span><span class=w> </span><span class=n>alias</span><span class=w> </span><span class=n>old_nameₙ</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=n>new_nameₙ</span>
</code></pre></div> 其中<code>old_name old_name₂ ... old_nameₙ</code>是初始命令生成的未黑名单声明。</p> <p>"YYYY-MM-DD"条目是今天的日期，自动填充。</p> <p><code>deprecate to</code>努力将<code>old_name</code>（“可见”名称）与用户生成的第一个标识符<code>new_name</code>匹配。旧的自动生成声明<code>old_name₂ ... old_nameₙ</code>按字母顺序检索。在初始声明最多生成一个非黑名单声明的情况下，字母排序无关紧要。</p> <p>技术上，该命令还接受一个可选的<code>String</code>参数来填充<code>since</code>中的日期。但主要用于调试目的，因为变量日期会导致测试时间依赖。</p> <h2 id=deriving>deriving<a class=headerlink href=#deriving title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Command.deriving</code></p> <h2 id=dsimproc>dsimproc<a class=headerlink href=#dsimproc title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.«command__Dsimproc__[_]_(_):=_»</code></p> <p>类似于<code>simproc</code>，但结果表达式必须与输入表达式在定义上相等。</p> <h2 id=dsimproc_decl>dsimproc_decl<a class=headerlink href=#dsimproc_decl title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.«command_Dsimproc_decl_(_):=_»</code></p> <p>用户定义的defeq简化过程声明。要在<code>simp</code>策略中激活此过程，必须将其作为参数提供，或使用<code>attribute</code>命令设置其<code>[simproc]</code>属性。</p> <h2 id=elab>elab<a class=headerlink href=#elab title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Command.elab</code></p> <h2 id=elab_rules>elab_rules<a class=headerlink href=#elab_rules title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Command.elab_rules</code></p> <h2 id=elab_stx_quot>elab_stx_quot<a class=headerlink href=#elab_stx_quot title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Elab.Term.Quotation.commandElab_stx_quot_</code></p> <h2 id=end>end<a class=headerlink href=#end title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Command.end</code></p> <p><code>end</code>关闭<code>section</code>或<code>namespace</code>作用域。如果作用域名为<code>&lt;id&gt;</code>，则必须使用<code>end &lt;id&gt;</code>关闭。文件末尾的<code>end</code>命令是可选的。</p> <h2 id=erase_aesop_rules>erase_aesop_rules<a class=headerlink href=#erase_aesop_rules title="Permanent link">&para;</a></h2> <p>定义于：<code>Aesop.Frontend.Parser.eraseRules</code></p> <h2 id=export>export<a class=headerlink href=#export title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Command.export</code></p> <p>将其他命名空间的名称添加到当前命名空间。</p> <p>命令<code>export Some.Namespace (name₁ name₂)</code>使<code>name₁</code>和<code>name₂</code>：</p> <ul> <li>在当前命名空间中无需前缀<code>Some.Namespace</code>即可见，类似<code>open</code>，且</li> <li>从当前命名空间<code>N</code>外部可见为<code>N.name₁</code>和<code>N.name₂</code>。</li> </ul> <p>示例：</p> <div class=highlight><pre><span></span><code><span class=kn>namespace</span><span class=w> </span><span class=n>Morning.Sky</span>
<span class=w>  </span><span class=kd>def</span><span class=w> </span><span class=n>star</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=s2>&quot;venus&quot;</span>
<span class=kd>end</span><span class=w> </span><span class=n>Morning.Sky</span>

<span class=kn>namespace</span><span class=w> </span><span class=n>Evening.Sky</span>
<span class=w>  </span><span class=kn>export</span><span class=w> </span><span class=n>Morning.Sky</span><span class=w> </span><span class=o>(</span><span class=n>star</span><span class=o>)</span>
<span class=w>  </span><span class=c1>-- `star`现在在作用域内</span>
<span class=w>  </span><span class=k>#check</span><span class=w> </span><span class=n>star</span>
<span class=kd>end</span><span class=w> </span><span class=n>Evening.Sky</span>

<span class=c1>-- `star`在`Evening.Sky`中可见</span>
<span class=k>#check</span><span class=w> </span><span class=n>Evening.Sky.star</span>
</code></pre></div> <h2 id=export_1>export<a class=headerlink href=#export_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Elab.Command.exportPrivate</code></p> <p>命令<code>export private a b c in foo bar</code>类似于<code>open private</code>，但不会在当前作用域内打开它们，而是创建指向私有定义的公共别名。该定义将存在于原始位置和名称，如同最初未使用<code>private</code>关键字。</p> <p>它还会在提供的短名称下打开新创建的别名定义，例如 <code>open private</code>。 也可以指定模块，例如 <code>export private a b c from Other.Module</code>。</p> <h2 id=extend_docs>extend_docs<a class=headerlink href=#extend_docs title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.ExtendDocs.commandExtend_docs__Before__After_</code></p> <p><code>extend_docs &lt;declName&gt; before &lt;prefix_string&gt; after &lt;suffix_string&gt;</code> 通过添加 <code>&lt;prefix_string&gt;</code> 在前和 <code>&lt;suffix_string&gt;</code> 在后，扩展 <code>&lt;declName&gt;</code> 的文档。</p> <h2 id=gen_injective_theorems>gen_injective_theorems%<a class=headerlink href=#gen_injective_theorems title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Command.genInjectiveTheorems</code></p> <p>这是一个用于为在 <code>Prelude.lean</code> 中定义的归纳类型生成构造函数可逆性定理的辅助命令。仅用于引导目的。</p> <h2 id=grind_pattern>grind_pattern<a class=headerlink href=#grind_pattern title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Command.grindPattern</code></p> <h2 id=grind_propagator>grind_propagator<a class=headerlink href=#grind_propagator title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.«command_Grind_propagator___(_):=_»</code></p> <p>用户为 <code>grind</code> 策略定义的自定义传播器。</p> <h2 id=guard_min_heartbeats>guard_min_heartbeats<a class=headerlink href=#guard_min_heartbeats title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.CountHeartbeats.commandGuard_min_heartbeats_In__</code></p> <p>守护在封闭命令中使用的最小心跳数。</p> <p>这在调试和最小化慢速声明示例的上下文中最为有用。通过守护慢速声明中使用的心跳数，如果最小化步骤消除了慢速行为，将生成错误消息。</p> <p>默认的最小心跳数是 <code>maxHeartbeats</code> 的值（通常为 200000）。或者，可以使用语法 <code>guard_min_heartbeats n in cmd</code> 指定要守护的心跳数。</p> <h2 id=import>import<a class=headerlink href=#import title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Command.import</code></p> <h2 id=in>in<a class=headerlink href=#in title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Command.in</code></p> <h2 id=include>include<a class=headerlink href=#include title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Command.include</code></p> <p><code>include eeny meeny</code> 指示 Lean 在当前节剩余的所有定理中包含节 <code>variable</code>s <code>eeny</code> 和 <code>meeny</code>，与默认根据定理头中的使用情况有条件包含变量的行为不同。其他命令不受影响。<code>include</code> 通常后跟 <code>in theorem ...</code> 以将包含限制在后续声明中。</p> <h2 id=init_grind_norm>init_grind_norm<a class=headerlink href=#init_grind_norm title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Command.initGrindNorm</code></p> <h2 id=init_quot>init_quot<a class=headerlink href=#init_quot title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Command.init_quot</code></p> <h2 id=initialize_simps_projections>initialize_simps_projections<a class=headerlink href=#initialize_simps_projections title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Command.initialize_simps_projections</code></p> <p>此命令允许自定义由 <code>simps</code> 生成的引理。</p> <p>默认情况下，用 <code>@[simps]</code> 标记结构 <code>MyStruct</code> 的元素 <code>myObj</code> 的定义会为 <code>MyStruct</code> 的每个投影 <code>myProj</code> 生成一个 <code>@[simp]</code> 引理 <code>myObj_myProj</code>。此一般规则有一些例外： * 对于代数结构，如果可用，我们将自动使用符号（如 <code>Mul</code>）作为投影。 * 默认情况下，对父结构的投影不是默认投影，但所有携带数据的字段都是（包括父结构中的字段）。</p> <p>此默认行为可通过以下方式自定义： * 通过运行 <code>initialize_simps_projections MulEquiv (-invFun)</code> 默认禁用投影。这将确保不为该投影生成简化引理，除非用户显式指定此投影（如 <code>@[simps invFun] def myEquiv : MulEquiv _ _ := _</code>）。 * 反之，通过运行 <code>initialize_simps_projections MulEquiv (+toEquiv)</code> 默认启用投影。 * 可以通过例如 <code>initialize_simps_projections MulEquiv (toFun → apply, invFun → symm_apply)</code> 指定自定义名称。 * 如果希望将投影名称作为生成引理名称的前缀，可以使用 <code>as_prefix fieldName</code>： <code>initialize_simps_projections MulEquiv (toFun → coe, as_prefix coe)</code> 请注意，这不影响投影名称的解析：如果有一个声明 <code>foo</code>，并且希望按顺序应用投影 <code>snd</code>、<code>coe</code>（作为前缀）和 <code>fst</code>，可以运行 <code>@[simps snd_coe_fst] def foo ...</code>，这将生成一个名为 <code>coe_foo_snd_fst</code> 的引理。</p> <p>以下是一些额外信息： * 运行 <code>initialize_simps_projections?</code>（或 <code>set_option trace.simps.verbose true</code>）查看生成的投影。 * 不带参数运行 <code>initialize_simps_projections MyStruct</code> 不是必需的，如果在声明结构后添加 <code>@[simps]</code>，则效果相同。 * 建议在与结构声明相同的文件中调用 <code>@[simps]</code> 或 <code>initialize_simps_projections</code>。否则，投影可能在不同文件中多次生成。</p> <p>一些常见用途： * 如果定义了一个新的类似同态的结构（如 <code>MulHom</code>），只需在定义 <code>DFunLike</code> 实例（或暗示 <code>DFunLike</code> 实例的实例）后运行 <code>initialize_simps_projections</code>。 <div class=highlight><pre><span></span><code>  instance {mM : Mul M} {mN : Mul N} : FunLike (MulHom M N) M N := ...
  initialize_simps_projections MulHom (toFun → apply)
</code></pre></div> 这将为每个声明 <code>foo</code> 生成 <code>foo_apply</code> 引理。 * 如果更喜欢表示函数间等式的 <code>coe_foo</code> 引理，请使用 <code>initialize_simps_projections MulHom (toFun → coe, as_prefix coe)</code> 在这种情况下，每当调用 <code>@[simps]</code> 时，必须使用 <code>@[simps -fullyApplied]</code>。 * 也可以初始化为同时使用两者，此时必须通过以下方式之一选择默认使用的： <div class=highlight><pre><span></span><code>  initialize_simps_projections MulHom (toFun → apply, toFun → coe, as_prefix coe, -coe)
  initialize_simps_projections MulHom (toFun → apply, toFun → coe, as_prefix coe, -apply)
</code></pre></div> 在第一种情况下，可以使用 <code>@[simps, simps -fullyApplied coe]</code> 获取两个引理，在第二种情况下，可以使用 <code>@[simps -fullyApplied, simps apply]</code> 获取两个引理。 * 如果声明了一个新的类似同态的结构（如 <code>RelEmbedding</code>），则 <code>initialize_simps_projections</code> 将自动找到任何将用作 <code>toFun</code> 字段默认投影的 <code>DFunLike</code> 强制转换。 <div class=highlight><pre><span></span><code>  initialize_simps_projections relEmbedding (toFun → apply)
</code></pre></div> * 如果有一个类似同构的结构（如 <code>Equiv</code>），通常希望为逆定义自定义投影： <div class=highlight><pre><span></span><code>  def Equiv.Simps.symm_apply (e : α ≃ β) : β → α := e.symm
  initialize_simps_projections Equiv (toFun → apply, invFun → symm_apply)
</code></pre></div></p> <h2 id=initialize_simps_projections_1>initialize_simps_projections?<a class=headerlink href=#initialize_simps_projections_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Command.commandInitialize_simps_projections?_</code></p> <p>此命令允许自定义由 <code>simps</code> 生成的引理。</p> <p>默认情况下，用 <code>@[simps]</code> 标记结构 <code>MyStruct</code> 的元素 <code>myObj</code> 的定义会为 <code>MyStruct</code> 的每个投影 <code>myProj</code> 生成一个 <code>@[simp]</code> 引理 <code>myObj_myProj</code>。此一般规则有一些例外： * 对于代数结构，如果可用，我们将自动使用符号（如 <code>Mul</code>）作为投影。 * 默认情况下，对父结构的投影不是默认投影，但所有携带数据的字段都是（包括父结构中的字段）。</p> <p>此默认行为可通过以下方式自定义： * 通过运行 <code>initialize_simps_projections MulEquiv (-invFun)</code> 默认禁用投影。这将确保不为该投影生成简化引理，除非用户显式指定此投影（如 <code>@[simps invFun] def myEquiv : MulEquiv _ _ := _</code>）。 * 反之，通过运行 <code>initialize_simps_projections MulEquiv (+toEquiv)</code> 默认启用投影。 * 可以通过例如 <code>initialize_simps_projections MulEquiv (toFun → apply, invFun → symm_apply)</code> 指定自定义名称。 * 如果希望将投影名称作为生成引理名称的前缀，可以使用 <code>as_prefix fieldName</code>： <code>initialize_simps_projections MulEquiv (toFun → coe, as_prefix coe)</code> 请注意，这不影响投影名称的解析：如果有一个声明 <code>foo</code>，并且希望按顺序应用投影 <code>snd</code>、<code>coe</code>（作为前缀）和 <code>fst</code>，可以运行 <code>@[simps snd_coe_fst] def foo ...</code>，这将生成一个名为 <code>coe_foo_snd_fst</code> 的引理。</p> <h2 id=irreducible_def>irreducible_def<a class=headerlink href=#irreducible_def title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Elab.Command.command_Irreducible_def____</code></p> <p>引入一个不可约定义。<code>irreducible_def foo := 42</code> 生成一个常量 <code>foo : Nat</code> 以及一个定理 <code>foo_def : foo = 42</code>。</p> <h2 id=library_note>library_note<a class=headerlink href=#library_note title="Permanent link">&para;</a></h2> <p>定义于：<code>Batteries.Util.LibraryNote.commandLibrary_note___</code></p> <p><div class=highlight><pre><span></span><code>library_note &quot;some tag&quot; /--
... 一些说明 ...
-/
</code></pre></div> 创建一个新的“库注记”，之后可以在文档注释中通过 <div class=highlight><pre><span></span><code>-- 参见注记 [some tag]
</code></pre></div> 进行交叉引用。使用 <code>#help note "some tag"</code> 在信息视图中显示所有带有标签 <code>"some tag"</code> 的注记。该命令可从 <code>Batteries.Tactic.HelpCmd</code> 导入。</p> <h2 id=lrat_proof>lrat_proof<a class=headerlink href=#lrat_proof title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.Sat.commandLrat_proof_Example____</code></p> <p>一个用于从 CNF / LRAT 文件生成 SAT 证明的宏。这些文件在 SAT 社区中常用于编写证明。</p> <p><code>lrat_proof</code> 命令的输入是要定义的定理名称，以及陈述（以 CNF 格式书写）和证明（以 LRAT 格式书写）。例如： <div class=highlight><pre><span></span><code><span class=n>lrat_proof</span><span class=w> </span><span class=n>foo</span>
<span class=w>  </span><span class=s2>&quot;p cnf 2 4  1 2 0  -1 2 0  1 -2 0  -1 -2 0&quot;</span>
<span class=w>  </span><span class=s2>&quot;5 -2 0 4 3 0  5 d 3 4 0  6 1 0 5 1 0  6 d 1 0  7 0 5 2 6 0&quot;</span>
</code></pre></div> 将生成定理： <div class=highlight><pre><span></span><code><span class=n>foo</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=bp>∀</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=n>a_1</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=kt>Prop</span><span class=o>),</span><span class=w> </span><span class=o>(</span><span class=bp>¬</span><span class=n>a</span><span class=w> </span><span class=bp>∧</span><span class=w> </span><span class=bp>¬</span><span class=n>a_1</span><span class=w> </span><span class=bp>∨</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>∧</span><span class=w> </span><span class=bp>¬</span><span class=n>a_1</span><span class=o>)</span><span class=w> </span><span class=bp>∨</span><span class=w> </span><span class=bp>¬</span><span class=n>a</span><span class=w> </span><span class=bp>∧</span><span class=w> </span><span class=n>a_1</span><span class=w> </span><span class=bp>∨</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>∧</span><span class=w> </span><span class=n>a_1</span>
</code></pre></div></p> <ul> <li>悬停在 <code>foo</code> 上可查看定理陈述。</li> <li>可使用 <code>example</code> 关键字替代 <code>foo</code> 以避免生成定理。</li> <li>可使用 <code>include_str</code> 宏代替字符串以从磁盘加载 CNF / LRAT 文件。</li> </ul> <h2 id=macro>macro<a class=headerlink href=#macro title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Command.macro</code></p> <h2 id=macro_rules>macro_rules<a class=headerlink href=#macro_rules title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Command.macro_rules</code></p> <h2 id=mk_iff_of_inductive_prop>mk_iff_of_inductive_prop<a class=headerlink href=#mk_iff_of_inductive_prop title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.MkIff.mkIffOfInductiveProp</code></p> <p><code>mk_iff_of_inductive_prop i r</code> 为归纳定义的命题 <code>i</code> 创建 <code>iff</code> 规则。新规则 <code>r</code> 的形如 <code>∀ps is, i as ↔ ⋁_j, ∃cs, is = cs</code>，其中 <code>ps</code> 是类型参数，<code>is</code> 是索引，<code>j</code> 遍历所有可能的构造子，<code>cs</code> 是各构造子的参数，<code>is = cs</code> 是各构造子对索引的实例化。</p> <p>在每种情况下，当对应的等式仅为某个索引 <code>i</code> 的 <code>c = i</code> 时，我们移除构造子参数（即 <code>cs</code>）。</p> <p>例如，对 <code>List.Chain</code> 使用 <code>mk_iff_of_inductive_prop</code> 生成： <div class=highlight><pre><span></span><code><span class=bp>∀</span><span class=w> </span><span class=o>{</span><span class=w> </span><span class=n>α</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=kt>Type</span><span class=bp>*</span><span class=o>}</span><span class=w> </span><span class=o>(</span><span class=n>R</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>α</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>α</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=kt>Prop</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>α</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>l</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>List</span><span class=w> </span><span class=n>α</span><span class=o>),</span>
<span class=w>  </span><span class=n>Chain</span><span class=w> </span><span class=n>R</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=n>l</span><span class=w> </span><span class=bp>↔</span><span class=w> </span><span class=n>l</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=o>[]</span><span class=w> </span><span class=bp>∨</span><span class=w> </span><span class=bp>∃</span><span class=o>(</span><span class=n>b</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>α</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>l&#39;</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>List</span><span class=w> </span><span class=n>α</span><span class=o>),</span><span class=w> </span><span class=n>R</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=bp>∧</span><span class=w> </span><span class=n>Chain</span><span class=w> </span><span class=n>R</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=n>l</span><span class=w> </span><span class=bp>∧</span><span class=w> </span><span class=n>l</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>::</span><span class=w> </span><span class=n>l&#39;</span>
</code></pre></div></p> <p>另见用户属性 <code>mk_iff</code>。</p> <h2 id=mutual>mutual<a class=headerlink href=#mutual title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Command.mutual</code></p> <h2 id=namespace>namespace<a class=headerlink href=#namespace title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Command.namespace</code></p> <p><code>namespace &lt;id&gt;</code> 打开一个带有标签 <code>&lt;id&gt;</code> 的区段，该区段会影响区段内的命名和名称解析： * 声明名称会被前缀化：在命名空间 <code>Nat</code> 内部的 <code>def seventeen : ℕ := 17</code> 会被赋予全名 <code>Nat.seventeen</code>。 * 由 <code>export</code> 声明引入的名称也会被标识符前缀化。 * 所有以 <code>&lt;id&gt;.</code> 开头的名称在命名空间内无需前缀即可使用。这些名称优先于由外部命名空间或 <code>open</code> 引入的名称。 * 在命名空间内部，声明可以是 <code>protected</code> 的，这会排除它们在打开命名空间时的影响。</p> <p>与 <code>section</code> 类似，命名空间可嵌套，其作用域由对应的 <code>end &lt;id&gt;</code> 或文件末尾终止。</p> <p><code>namespace</code> 也像 <code>section</code> 一样界定 <code>variable</code>、<code>open</code> 及其他作用域命令的范围。</p> <h2 id=noncomputable>noncomputable<a class=headerlink href=#noncomputable title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Command.noncomputableSection</code></p> <h2 id=norm_cast_add_elim>norm_cast_add_elim<a class=headerlink href=#norm_cast_add_elim title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.normCastAddElim</code></p> <p><code>norm_cast_add_elim foo</code> 将 <code>foo</code> 注册为 <code>norm_cast</code> 中的消除引理。</p> <h2 id=notation>notation<a class=headerlink href=#notation title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Command.notation</code></p> <h2 id=notation3>notation3<a class=headerlink href=#notation3 title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Notation3.notation3</code></p> <p><code>notation3</code> 使用 Lean-3 风格的语法声明记法。</p> <p>示例： <div class=highlight><pre><span></span><code><span class=n>notation3</span><span class=w> </span><span class=s2>&quot;∀ᶠ &quot;</span><span class=w> </span><span class=o>(</span><span class=bp>...</span><span class=o>)</span><span class=w> </span><span class=s2>&quot; in &quot;</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=s2>&quot;, &quot;</span><span class=w> </span><span class=n>r</span><span class=o>:(</span><span class=n>scoped</span><span class=w> </span><span class=n>p</span><span class=w> </span><span class=bp>=&gt;</span><span class=w> </span><span class=n>Filter.eventually</span><span class=w> </span><span class=n>p</span><span class=w> </span><span class=n>f</span><span class=o>)</span><span class=w> </span><span class=bp>=&gt;</span><span class=w> </span><span class=n>r</span>
<span class=n>notation3</span><span class=w> </span><span class=s2>&quot;MyList[&quot;</span><span class=w> </span><span class=o>(</span><span class=n>x</span><span class=s2>&quot;, &quot;</span><span class=bp>*</span><span class=w> </span><span class=bp>=&gt;</span><span class=w> </span><span class=n>foldr</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=bp>=&gt;</span><span class=w> </span><span class=n>MyList.cons</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=n>b</span><span class=o>)</span><span class=w> </span><span class=n>MyList.nil</span><span class=o>)</span><span class=w> </span><span class=s2>&quot;]&quot;</span><span class=w> </span><span class=bp>=&gt;</span><span class=w> </span><span class=n>x</span>
</code></pre></div> 默认情况下，记法无法提及使用 <code>variable</code> 定义的任何变量，但 <code>local notation3</code> 可使用此类局部变量。</p> <p>使用 <code>notation3 (prettyPrint := false)</code> 阻止命令为记法生成美化打印器。</p> <p>该命令可用于 mathlib4，但其未来不确定，主要为向后兼容而创建。</p> <h2 id=omit>omit<a class=headerlink href=#omit title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Command.omit</code></p> <p><code>omit</code> 指示 Lean 不包含先前 <code>include</code> 的变量。除变量名外，还可通过类型使用语法 <code>omit [TypeOfInst]</code> 引用类型类实例变量，此时将省略所有与给定类型统一的实例变量。<code>omit</code> 通常应与 <code>in</code> 结合使用以保持区段结构简单。</p> <h2 id=open>open<a class=headerlink href=#open title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Elab.Command.openPrivate</code></p> <p>命令 <code>open private a b c in foo bar</code> 将在声明 <code>foo</code> 和 <code>bar</code> 中查找名为 <code>a</code>、<code>b</code>、<code>c</code> 的私有定义，并在当前作用域中打开它们。这不会使定义公开，而是让它们通过短名称 <code>a</code> 在当前区段内可访问，而非无法直接输入的内部名称（如 <code>_private.Other.Module.0.Other.Namespace.foo.a</code>）。</p> <p>也可通过 <code>open private a b c from Other.Module</code> 指定模块。</p> <h2 id=open_1>open<a class=headerlink href=#open_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Command.open</code></p> <p>使其他命名空间的名称无需前缀即可见。</p> <p>通过 <code>open</code> 可用的名称在当前 <code>section</code> 或 <code>namespace</code> 块内可见。这简化了对（类型）定义和定理的引用，但需注意，也可能使来自其他命名空间的<a href=https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances title=定理证明中的作用域实例>作用域实例</a>、记法和属性可用。</p> <p><code>open</code> 命令有几种不同的使用方式：</p> <ul> <li> <p><code>open Some.Namespace.Path1 Some.Namespace.Path2</code> 使得 <code>Some.Namespace.Path1</code> 和 <code>Some.Namespace.Path2</code> 中的所有非受保护名称无需前缀即可使用，因此 <code>Some.Namespace.Path1.x</code> 和 <code>Some.Namespace.Path2.y</code> 可以直接通过 <code>x</code> 和 <code>y</code> 来引用。</p> </li> <li> <p><code>open Some.Namespace.Path hiding def1 def2</code> 打开 <code>Some.Namespace.Path</code> 中除 <code>def1</code> 和 <code>def2</code> 外的所有非受保护名称。</p> </li> <li> <p><code>open Some.Namespace.Path (def1 def2)</code> 仅使 <code>Some.Namespace.Path.def1</code> 和 <code>Some.Namespace.Path.def2</code> 无需完整前缀即可使用，而 <code>Some.Namespace.Path.def3</code> 不会受到影响。</p> </li> </ul> <p>即使 <code>def1</code> 和 <code>def2</code> 是 <code>protected</code> 的，此方法仍有效。</p> <ul> <li><code>open Some.Namespace.Path renaming def1 → def1', def2 → def2'</code> 与 <code>open Some.Namespace.Path (def1 def2)</code> 类似，但将 <code>def1</code>/<code>def2</code> 的名称更改为 <code>def1'</code>/<code>def2'</code>。</li> </ul> <p>即使 <code>def1</code> 和 <code>def2</code> 是 <code>protected</code> 的，此方法仍有效。</p> <ul> <li> <p><code>open scoped Some.Namespace.Path1 Some.Namespace.Path2</code> <strong>仅</strong> 打开来自 <code>Namespace1</code> 和 <code>Namespace2</code> 的<a href=https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances title=定理证明中的作用域实例>作用域实例</a>、符号和属性；<strong>不</strong> 提供其他任何名称。</p> </li> <li> <p><code>open &lt;上述任意 open 形式&gt; in</code> 使得 <code>open</code> 的名称仅在下一个命令或表达式中可见。</p> </li> </ul> <p>示例：</p> <div class=highlight><pre><span></span><code><span class=sd>/-- SKI组合子 https://zh.wikipedia.org/wiki/SKI组合子演算 -/</span>
<span class=kn>namespace</span><span class=w> </span><span class=n>Combinator.Calculus</span>
<span class=w>  </span><span class=kd>def</span><span class=w> </span><span class=n>I</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>α</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>α</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=n>a</span>
<span class=w>  </span><span class=kd>def</span><span class=w> </span><span class=n>K</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>α</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>β</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>α</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=k>fun</span><span class=w> </span><span class=n>_</span><span class=w> </span><span class=bp>=&gt;</span><span class=w> </span><span class=n>a</span>
<span class=w>  </span><span class=kd>def</span><span class=w> </span><span class=n>S</span><span class=w> </span><span class=o>(</span><span class=n>x</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>α</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>β</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>γ</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>y</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>α</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>β</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>z</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>α</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>γ</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=n>z</span><span class=w> </span><span class=o>(</span><span class=n>y</span><span class=w> </span><span class=n>z</span><span class=o>)</span>
<span class=kd>end</span><span class=w> </span><span class=n>Combinator.Calculus</span>

<span class=kn>section</span>
<span class=w>  </span><span class=c1>-- 打开 `Combinator.Calculus` 下的所有内容，即 `I`、`K` 和 `S`，直到该 section 结束</span>
<span class=w>  </span><span class=kn>open</span><span class=w> </span><span class=n>Combinator.Calculus</span>

<span class=w>  </span><span class=kd>theorem</span><span class=w> </span><span class=n>SKx_eq_K</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>S</span><span class=w> </span><span class=n>K</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>I</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=n>rfl</span>
<span class=kd>end</span>

<span class=c1>-- 仅对下一个命令（此处为下一个 `theorem`）打开 `Combinator.Calculus` 下的所有内容</span>
<span class=kn>open</span><span class=w> </span><span class=n>Combinator.Calculus</span><span class=w> </span><span class=k>in</span>
<span class=kd>theorem</span><span class=w> </span><span class=n>SKx_eq_K&#39;</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>S</span><span class=w> </span><span class=n>K</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>I</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=n>rfl</span>

<span class=kn>section</span>
<span class=w>  </span><span class=c1>-- 仅打开 `Combinator.Calculus` 下的 `S` 和 `K`</span>
<span class=w>  </span><span class=kn>open</span><span class=w> </span><span class=n>Combinator.Calculus</span><span class=w> </span><span class=o>(</span><span class=n>S</span><span class=w> </span><span class=n>K</span><span class=o>)</span>

<span class=w>  </span><span class=kd>theorem</span><span class=w> </span><span class=n>SKxy_eq_y</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>S</span><span class=w> </span><span class=n>K</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=n>rfl</span>

<span class=w>  </span><span class=c1>-- `I` 不在作用域中，必须使用其完整路径</span>
<span class=w>  </span><span class=kd>theorem</span><span class=w> </span><span class=n>SKxy_eq_Iy</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>S</span><span class=w> </span><span class=n>K</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>Combinator.Calculus.I</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=n>rfl</span>
<span class=kd>end</span>

<span class=kn>section</span>
<span class=w>  </span><span class=kn>open</span><span class=w> </span><span class=n>Combinator.Calculus</span>
<span class=w>    </span><span class=kn>renaming</span>
<span class=w>      </span><span class=n>I</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>identity</span><span class=o>,</span>
<span class=w>      </span><span class=n>K</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>konstant</span>

<span class=w>  </span><span class=k>#check</span><span class=w> </span><span class=n>identity</span>
<span class=w>  </span><span class=k>#check</span><span class=w> </span><span class=n>konstant</span>
<span class=kd>end</span>

<span class=kn>section</span>
<span class=w>  </span><span class=kn>open</span><span class=w> </span><span class=n>Combinator.Calculus</span>
<span class=w>    </span><span class=kn>hiding</span><span class=w> </span><span class=n>S</span>

<span class=w>  </span><span class=k>#check</span><span class=w> </span><span class=n>I</span>
<span class=w>  </span><span class=k>#check</span><span class=w> </span><span class=n>K</span>
<span class=kd>end</span>

<span class=kn>section</span>
<span class=w>  </span><span class=kn>namespace</span><span class=w> </span><span class=n>Demo</span>
<span class=w>    </span><span class=kd>inductive</span><span class=w> </span><span class=n>MyType</span>
<span class=w>    </span><span class=bp>|</span><span class=w> </span><span class=n>val</span>

<span class=w>    </span><span class=kn>namespace</span><span class=w> </span><span class=n>N1</span>
<span class=w>      </span><span class=n>scoped</span><span class=w> </span><span class=kd>infix</span><span class=o>:</span><span class=mi>68</span><span class=w> </span><span class=s2>&quot; ≋ &quot;</span><span class=w> </span><span class=bp>=&gt;</span><span class=w> </span><span class=n>BEq.beq</span>

<span class=w>      </span><span class=n>scoped</span><span class=w> </span><span class=kd>instance</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>BEq</span><span class=w> </span><span class=n>MyType</span><span class=w> </span><span class=n>where</span>
<span class=w>        </span><span class=n>beq</span><span class=w> </span><span class=n>_</span><span class=w> </span><span class=n>_</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=n>true</span>

<span class=w>      </span><span class=kd>def</span><span class=w> </span><span class=n>Alias</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=n>MyType</span>
<span class=w>    </span><span class=kd>end</span><span class=w> </span><span class=n>N1</span>
<span class=w>  </span><span class=kd>end</span><span class=w> </span><span class=n>Demo</span>

<span class=w>  </span><span class=c1>-- 将 `≋` 和实例引入作用域，但不引入 `Alias`</span>
<span class=w>  </span><span class=kn>open</span><span class=w> </span><span class=n>scoped</span><span class=w> </span><span class=n>Demo.N1</span>

<span class=w>  </span><span class=k>#check</span><span class=w> </span><span class=n>Demo.MyType.val</span><span class=w> </span><span class=bp>==</span><span class=w> </span><span class=n>Demo.MyType.val</span>
<span class=w>  </span><span class=k>#check</span><span class=w> </span><span class=n>Demo.MyType.val</span><span class=w> </span><span class=bp>≋</span><span class=w> </span><span class=n>Demo.MyType.val</span>
<span class=w>  </span><span class=c1>-- #check Alias -- 未知标识符 &#39;Alias&#39;</span>
<span class=kd>end</span>
</code></pre></div> <h2 id=proof_wanted>proof_wanted<a class=headerlink href=#proof_wanted title="Permanent link">&para;</a></h2> <p>定义于：<code>«proof_wanted»</code></p> <p>此证明将是对库的一个欢迎贡献！</p> <p><code>proof_wanted</code> 声明的语法与 <code>theorem</code> 类似，但不包含 <code>:=</code> 或证明。Lean 会检查 <code>proof_wanted</code> 声明是否格式正确（例如确保所有提到的名称都在作用域内，且定理陈述是有效的命题），但它们随后会被丢弃。这意味着它们不能作为公理使用。</p> <p>典型用法： <div class=highlight><pre><span></span><code><span class=kd>@[</span><span class=n>simp</span><span class=kd>]</span><span class=w> </span><span class=n>proof_wanted</span><span class=w> </span><span class=n>empty_find</span><span class=bp>?</span><span class=w> </span><span class=o>[</span><span class=n>BEq</span><span class=w> </span><span class=n>α</span><span class=o>]</span><span class=w> </span><span class=o>[</span><span class=n>Hashable</span><span class=w> </span><span class=n>α</span><span class=o>]</span><span class=w> </span><span class=o>{</span><span class=n>a</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>α</span><span class=o>}</span><span class=w> </span><span class=o>:</span>
<span class=w>    </span><span class=o>(</span><span class=bp>∅</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>HashMap</span><span class=w> </span><span class=n>α</span><span class=w> </span><span class=n>β</span><span class=o>)</span><span class=bp>.</span><span class=n>find</span><span class=bp>?</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>none</span>
</code></pre></div></p> <h2 id=recall>recall<a class=headerlink href=#recall title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.Recall.recall</code></p> <p><code>recall</code> 命令重新声明先前的定义以作说明之用。 这对于以说明性方式呈现某些理论的 Lean 文件非常有用。</p> <p>该命令的语法与 <code>def</code> 相同，因此所有常规功能均可使用。 <div class=highlight><pre><span></span><code><span class=n>recall</span><span class=w> </span><span class=n>List.cons_append</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>α</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>as</span><span class=w> </span><span class=n>bs</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>List</span><span class=w> </span><span class=n>α</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=o>::</span><span class=w> </span><span class=n>as</span><span class=o>)</span><span class=w> </span><span class=bp>++</span><span class=w> </span><span class=n>bs</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>::</span><span class=w> </span><span class=o>(</span><span class=n>as</span><span class=w> </span><span class=bp>++</span><span class=w> </span><span class=n>bs</span><span class=o>)</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=n>rfl</span>
</code></pre></div> 此外，可以省略主体。 <div class=highlight><pre><span></span><code><span class=n>recall</span><span class=w> </span><span class=n>Nat.add_comm</span><span class=w> </span><span class=o>(</span><span class=n>n</span><span class=w> </span><span class=n>m</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Nat</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>m</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>m</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>n</span>
</code></pre></div></p> <p>该命令验证新定义是否类型检查，以及提供的类型和值是否与原始声明在定义上相等。然而，这不会捕获某些细节（如绑定器），因此以下内容不会报错。 <div class=highlight><pre><span></span><code><span class=n>recall</span><span class=w> </span><span class=n>Nat.add_comm</span><span class=w> </span><span class=o>{</span><span class=n>n</span><span class=w> </span><span class=n>m</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Nat</span><span class=o>}</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>m</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>m</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>n</span>
</code></pre></div></p> <h2 id=recommended_spelling>recommended_spelling<a class=headerlink href=#recommended_spelling title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Command.recommended_spelling</code></p> <p>记录标识符中符号的推荐拼写。</p> <p>定理通常应根据其陈述系统命名，而非创造性命名。非标识符符号应始终通过其推荐拼写一致引用。</p> <div class=highlight><pre><span></span><code>/-- 一些额外信息 -/
recommended_spelling &quot;and&quot; for &quot;∧&quot; in [And, «term_∧_»]
</code></pre></div> <p>将执行以下操作： * 在 <code>And</code> 和 <code>∧</code> 的文档字符串末尾添加句子“<code>∧</code> 在标识符中的推荐拼写为 <code>and</code>（一些额外信息）”。如果额外信息超过一行，它将放置在句子下方而非括号内。 * 将此信息注册到环境扩展中，以便后续生成包含所有推荐拼写的表格。</p> <p>您可以将推荐拼写附加到任意多个声明。建议将推荐拼写附加到所有相关解析器以及解析器所指的声明（如果存在此类声明）。注意 <code>inherit_doc</code> 属性*不会*复制推荐拼写，因此即使 <code>∧</code> 的解析器使用 <code>@[inherit_doc And]</code>，我们也必须将推荐拼写附加到 <code>And</code> 和 <code>«term_∧_»</code> 两者。</p> <p><code>syntax</code>、<code>macro</code>、<code>elab</code> 和 <code>notation</code> 命令接受 <code>(name := parserName)</code> 选项以将名称分配给创建的解析器，从而无需猜测自动生成的名称。<code>syntax</code>、<code>macro</code> 和 <code>elab</code> 命令可悬停以查看解析器名称。</p> <p>对于包含标识符的复杂符号，约定是使用示例标识符而非其他占位符。以下是遵循此约定的示例： <div class=highlight><pre><span></span><code><span class=n>recommended_spelling</span><span class=w> </span><span class=s2>&quot;singleton&quot;</span><span class=w> </span><span class=n>for</span><span class=w> </span><span class=s2>&quot;[a]&quot;</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=o>[</span><span class=n>List.cons</span><span class=o>,</span><span class=w> </span><span class=bp>«</span><span class=n>term</span><span class=o>[</span><span class=n>_</span><span class=o>]</span><span class=bp>»</span><span class=o>]</span>
</code></pre></div> 使用 <code>[·]</code> 或 <code>[⋯]</code> 或 <code>[…]</code> 代替 <code>[a]</code> 将违反约定。当将推荐拼写附加到已有示例的符号文档时，尽量重用文档中选择的标识符名称以保持一致性。</p> <h2 id=register_builtin_option>register_builtin_option<a class=headerlink href=#register_builtin_option title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Option.registerBuiltinOption</code></p> <h2 id=register_hint>register_hint<a class=headerlink href=#register_hint title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.Hint.registerHintStx</code></p> <p>注册一个与 <code>hint</code> 策略一起使用的策略，例如 <code>register_hint simp_all</code>。</p> <h2 id=register_label_attr>register_label_attr<a class=headerlink href=#register_label_attr title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Command.registerLabelAttr</code></p> <p>初始化新的“标签”属性。 使用 <code>Lean.labelled</code> 可检索标记有此属性的声明。</p> <h2 id=register_option>register_option<a class=headerlink href=#register_option title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Option.registerOption</code></p> <h2 id=register_simp_attr>register_simp_attr<a class=headerlink href=#register_simp_attr title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Command.registerSimpAttr</code></p> <h2 id=register_tactic_tag>register_tactic_tag<a class=headerlink href=#register_tactic_tag title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Command.register_tactic_tag</code></p> <p>注册策略标签，保存其面向用户的名称和文档字符串。</p> <p>文档生成工具可使用策略标签对相关策略进行分类。</p> <h2 id=run_cmd>run_cmd<a class=headerlink href=#run_cmd title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.runCmd</code></p> <p><code>run_cmd doSeq</code> 命令在 <code>CommandElabM Unit</code> 中执行代码。 这与 <code>#eval show CommandElabM Unit from discard do doSeq</code> 相同。</p> <h2 id=run_elab>run_elab<a class=headerlink href=#run_elab title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.runElab</code></p> <p><code>run_elab doSeq</code> 命令在 <code>TermElabM Unit</code> 中执行代码。 这与 <code>#eval show TermElabM Unit from discard do doSeq</code> 相同。</p> <h2 id=run_meta>run_meta<a class=headerlink href=#run_meta title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.runMeta</code></p> <p><code>run_meta doSeq</code> 命令在 <code>MetaM Unit</code> 中执行代码。 这与 <code>#eval show MetaM Unit from do discard doSeq</code> 相同。</p> <p>（这实际上是 <code>run_elab</code> 的同义词，因为 <code>MetaM</code> 可提升至 <code>TermElabM</code>。）</p> <h2 id=scoped>scoped<a class=headerlink href=#scoped title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.scopedNS</code></p> <p><code>scoped[NS]</code> 类似于属性和符号上的 <code>scoped</code> 修饰符，但它在指定命名空间中作用语法，而非当前命名空间。 <div class=highlight><pre><span></span><code><span class=n>scoped</span><span class=o>[</span><span class=n>Matrix</span><span class=o>]</span><span class=w> </span><span class=kd>postfix</span><span class=o>:</span><span class=mi>1024</span><span class=w> </span><span class=s2>&quot;ᵀ&quot;</span><span class=w> </span><span class=bp>=&gt;</span><span class=w> </span><span class=n>Matrix.transpose</span>
<span class=c1>-- 声明 `ᵀ` 作为矩阵转置的符号</span>
<span class=c1>-- 仅在 `open Matrix` 或 `open scoped Matrix` 时可访问。</span>

<span class=kn>namespace</span><span class=w> </span><span class=n>Nat</span>

<span class=n>scoped</span><span class=o>[</span><span class=n>Nat.Count</span><span class=o>]</span><span class=w> </span><span class=kn>attribute</span><span class=w> </span><span class=o>[</span><span class=kd>instance</span><span class=o>]</span><span class=w> </span><span class=n>CountSet.fintype</span>
<span class=c1>-- 将定义 Nat.CountSet.fintype 设为实例，</span>
<span class=c1>-- 但仅在 `Nat.Count` 打开时生效</span>
</code></pre></div></p> <h2 id=seal>seal<a class=headerlink href=#seal title="Permanent link">&para;</a></h2> <p>Defined in: <code>Lean.Parser.commandSeal__</code></p> <p><code>seal foo</code> 命令确保 <code>foo</code> 的定义被密封，即标记为 <code>[irreducible]</code>。 此命令在需要防止证明过程中对 <code>foo</code> 进行规约的上下文中尤为有用。</p> <p>在功能上，<code>seal foo</code> 等同于 <code>attribute [local irreducible] foo</code>。 该属性指定 <code>foo</code> 仅在局部作用域内被视为不可规约， 这有助于在保持所需抽象层级的同时不影响全局设置。</p> <h2 id=section>section<a class=headerlink href=#section title="Permanent link">&para;</a></h2> <p>Defined in: <code>Lean.Parser.Command.section</code></p> <p><code>section</code>/<code>end</code> 对用于界定 <code>variable</code>、<code>include</code>、<code>open</code>、<code>set_option</code> 和 <code>local</code> 命令的作用域。节（section）可嵌套。<code>section &lt;id&gt;</code> 为节提供标签，需与匹配的 <code>end</code> 一起出现。 无论是否使用标签，<code>end</code> 均可省略，此时节将在文件末尾关闭。</p> <h2 id=set_option>set_option<a class=headerlink href=#set_option title="Permanent link">&para;</a></h2> <p>Defined in: <code>Lean.Parser.Command.set_option</code></p> <p><code>set_option &lt;id&gt; &lt;value&gt;</code> 将选项 <code>&lt;id&gt;</code> 设为 <code>&lt;value&gt;</code>。根据选项类型的不同， 值可为 <code>true</code>、<code>false</code>、字符串或数字。选项用于配置 Lean 及用户定义扩展的行为。 该设置将保持有效直至当前 <code>section</code> 或 <code>namespace</code> 结束，或文件结束。 输入 <code>&lt;id&gt;</code> 时可使用自动补全以列出可用选项。</p> <p><code>set_option &lt;id&gt; &lt;value&gt; in &lt;command&gt;</code> 将选项设为仅对单个命令生效： <div class=highlight><pre><span></span><code><span class=kd>set_option</span><span class=w> </span><span class=n>pp.all</span><span class=w> </span><span class=n>true</span><span class=w> </span><span class=k>in</span>
<span class=k>#check</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>1</span>
</code></pre></div> 类似地，<code>set_option &lt;id&gt; &lt;value&gt; in</code> 也可在项和策略内部使用，以仅对单个项或策略设置选项。</p> <h2 id=set_premise_selector>set_premise_selector<a class=headerlink href=#set_premise_selector title="Permanent link">&para;</a></h2> <p>Defined in: <code>Lean.setPremiseSelectorCmd</code></p> <p>指定前提选择引擎。 注意 Lean 未内置默认前提选择引擎， 因此此命令需结合提供引擎的下游包使用。</p> <h2 id=show_panel_widgets>show_panel_widgets<a class=headerlink href=#show_panel_widgets title="Permanent link">&para;</a></h2> <p>Defined in: <code>Lean.Widget.showPanelWidgetsCmd</code></p> <p>使用 <code>show_panel_widgets [&lt;widget&gt;]</code> 标记应始终显示 <code>&lt;widget&gt;</code>， 包括在下游模块中。</p> <p><code>&lt;widget&gt;</code> 的类型必须实现 <code>Widget.ToModule</code>， 且 <code>&lt;props&gt;</code> 的类型必须实现 <code>Server.RpcEncodable</code>。 特别地，<code>&lt;props&gt; : Json</code> 适用。</p> <p>使用 <code>show_panel_widgets [&lt;widget&gt; with &lt;props&gt;]</code> 指定应传递给 widget 的参数 <code>&lt;props&gt;</code>。</p> <p>使用 <code>show_panel_widgets [local &lt;widget&gt; (with &lt;props&gt;)?]</code> 标记仅在当前节、命名空间或文件中显示。</p> <p>使用 <code>show_panel_widgets [scoped &lt;widget&gt; (with &lt;props&gt;)?]</code> 标记仅当当前命名空间打开时显示。</p> <p>使用 <code>show_panel_widgets [-&lt;widget&gt;]</code> 临时隐藏先前显示的 widget， 仅在当前节、命名空间或文件内有效。 注意无法永久移除，即 <code>-&lt;widget&gt;</code> 对下游模块无影响。</p> <h2 id=simproc>simproc<a class=headerlink href=#simproc title="Permanent link">&para;</a></h2> <p>Defined in: <code>Lean.Parser.«command__Simproc__[_]_(_):=_»</code></p> <p>用户定义的简化过程，供 <code>simp</code> 策略及其变体使用。示例如下： <div class=highlight><pre><span></span><code><span class=kd>theorem</span><span class=w> </span><span class=n>and_false_eq</span><span class=w> </span><span class=o>{</span><span class=n>p</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=kt>Prop</span><span class=o>}</span><span class=w> </span><span class=o>(</span><span class=n>q</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=kt>Prop</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>p</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>False</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=o>(</span><span class=n>p</span><span class=w> </span><span class=bp>∧</span><span class=w> </span><span class=n>q</span><span class=o>)</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>False</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span><span class=w> </span><span class=n>simp</span><span class=w> </span><span class=o>[</span><span class=bp>*</span><span class=o>]</span>

<span class=kn>open</span><span class=w> </span><span class=n>Lean</span><span class=w> </span><span class=n>Meta</span><span class=w> </span><span class=n>Simp</span>
<span class=n>simproc</span><span class=w> </span><span class=bp>↓</span><span class=w> </span><span class=n>shortCircuitAnd</span><span class=w> </span><span class=o>(</span><span class=n>And</span><span class=w> </span><span class=n>_</span><span class=w> </span><span class=n>_</span><span class=o>)</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=k>fun</span><span class=w> </span><span class=n>e</span><span class=w> </span><span class=bp>=&gt;</span><span class=w> </span><span class=k>do</span>
<span class=w>  </span><span class=n>let_expr</span><span class=w> </span><span class=n>And</span><span class=w> </span><span class=n>p</span><span class=w> </span><span class=n>q</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=n>e</span><span class=w> </span><span class=bp>|</span><span class=w> </span><span class=n>return</span><span class=w> </span><span class=bp>.</span><span class=n>continue</span>
<span class=w>  </span><span class=k>let</span><span class=w> </span><span class=n>r</span><span class=w> </span><span class=bp>←</span><span class=w> </span><span class=n>simp</span><span class=w> </span><span class=n>p</span>
<span class=w>  </span><span class=n>let_expr</span><span class=w> </span><span class=n>False</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=n>r.expr</span><span class=w> </span><span class=bp>|</span><span class=w> </span><span class=n>return</span><span class=w> </span><span class=bp>.</span><span class=n>continue</span>
<span class=w>  </span><span class=k>let</span><span class=w> </span><span class=n>proof</span><span class=w> </span><span class=bp>←</span><span class=w> </span><span class=n>mkAppM</span><span class=w> </span><span class=ss>``and_false_eq</span><span class=w> </span><span class=bp>#</span><span class=o>[</span><span class=n>q</span><span class=o>,</span><span class=w> </span><span class=o>(</span><span class=bp>←</span><span class=w> </span><span class=n>r.getProof</span><span class=o>)]</span>
<span class=w>  </span><span class=n>return</span><span class=w> </span><span class=bp>.</span><span class=n>done</span><span class=w> </span><span class=o>{</span><span class=w> </span><span class=n>expr</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=n>r.expr</span><span class=o>,</span><span class=w> </span><span class=n>proof</span><span class=bp>?</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=n>some</span><span class=w> </span><span class=n>proof</span><span class=w> </span><span class=o>}</span>
</code></pre></div> 当 <code>simp</code> 策略发现形如 <code>And _ _</code> 的项时，会调用 <code>shortCircuitAnd</code>。 简化过程存储于（不完美的）判别树中。 过程**不应**假设项 <code>e</code> 完美匹配给定模式。 简化过程主体必须具有 <code>Simproc</code> 类型，即 <code>Expr → SimpM Step</code> 的别名。 使用修饰符 <code>↓</code> 在过程名前可指示简化器在子表达式简化前应用该过程。 简化过程亦可设为作用域或局部。</p> <h2 id=simproc_decl>simproc_decl<a class=headerlink href=#simproc_decl title="Permanent link">&para;</a></h2> <p>Defined in: <code>Lean.Parser.«command_Simproc_decl_(_):=_»</code></p> <p>用户定义的简化过程声明。需通过提供该过程作为参数或使用 <code>attribute</code> 命令设置其 <code>[simproc]</code> 属性， 方可在 <code>simp</code> 策略中激活。</p> <h2 id=simproc_pattern>simproc_pattern%<a class=headerlink href=#simproc_pattern title="Permanent link">&para;</a></h2> <p>Defined in: <code>Lean.Parser.simprocPattern</code></p> <p>用于将模式与简化过程关联的辅助命令。</p> <h2 id=sudo>sudo<a class=headerlink href=#sudo title="Permanent link">&para;</a></h2> <p>Defined in: <code>commandSudoSet_option___</code></p> <p>命令 <code>sudo set_option name val</code> 类似 <code>set_option name val</code>， 但允许设置未声明的选项。</p> <h2 id=suppress_compilation>suppress_compilation<a class=headerlink href=#suppress_compilation title="Permanent link">&para;</a></h2> <p>Defined in: <code>commandSuppress_compilation</code></p> <p>将 <code>def</code> 和 <code>instance</code> 替换为 <code>noncomputable def</code> 和 <code>noncomputable instance</code>， 用于在特定文件或节中禁用编译器。 此为应对 <a href=https://github.com/leanprover-community/mathlib4/issues/7103>https://github.com/leanprover-community/mathlib4/issues/7103</a> 的临时方案。 注意其不适用于 <code>notation3</code>。若 <code>suppress_compilation</code> 处于激活状态， 需在声明此类记号前使用 <code>unsuppress_compilation</code>。</p> <h2 id=syntax>syntax<a class=headerlink href=#syntax title="Permanent link">&para;</a></h2> <p>Defined in: <code>Lean.Parser.Command.syntax</code></p> <h2 id=syntax_1>syntax<a class=headerlink href=#syntax_1 title="Permanent link">&para;</a></h2> <p>Defined in: <code>Lean.Parser.Command.syntaxAbbrev</code></p> <h2 id=tactic_extension>tactic_extension<a class=headerlink href=#tactic_extension title="Permanent link">&para;</a></h2> <p>Defined in: <code>Lean.Parser.Command.tactic_extension</code></p> <p>扩展指定策略的文档。</p> <p>扩展文档置于命令的文档字符串中，以项目符号列表形式显示，应保持简洁。</p> <h2 id=test_extern>test_extern<a class=headerlink href=#test_extern title="Permanent link">&para;</a></h2> <p>Defined in: <code>testExternCmd</code></p> <h2 id=unif_hint>unif_hint<a class=headerlink href=#unif_hint title="Permanent link">&para;</a></h2> <p>Defined in: <code>Lean.«command__Unif_hint____Where_|_-⊢_»</code></p> <h2 id=universe>universe<a class=headerlink href=#universe title="Permanent link">&para;</a></h2> <p>Defined in: <code>Lean.Parser.Command.universe</code></p> <p>声明一个或多个宇宙变量。</p> <p><code>universe u v</code></p> <p><code>Prop</code>、<code>Type</code>、<code>Type u</code> 和 <code>Sort u</code> 是分类其他类型的类型，亦称*宇宙*。 在 <code>Type u</code> 和 <code>Sort u</code> 中，变量 <code>u</code> 代表宇宙的*层级*，层级为 <code>u</code> 的宇宙仅能分类层级低于 <code>u</code> 的宇宙。 有关类型宇宙的更多细节，请参阅 <a href=https://lean-lang.org/theorem_proving_in_lean4/dependent_type_theory.html#types-as-objects title="Theorem Proving in Lean 中的类型宇宙">Theorem Proving in Lean 相关章节</a>。</p> <p>正如类型参数允许多态定义用于多种类型，宇宙参数（由宇宙变量表示）允许定义用于任意所需层级。 虽然 Lean 主要自动处理宇宙层级，但显式声明可在编写签名时提供更多控制。 <code>universe</code> 关键字允许在定义集合中使用声明的宇宙变量，Lean 将确保这些定义一致使用它们。</p> <div class=highlight><pre><span></span><code><span class=c>/-</span><span class=cm> 显式类型宇宙参数 -/</span>
<span class=kd>def</span><span class=w> </span><span class=n>id₁</span><span class=bp>.</span><span class=o>{</span><span class=n>u</span><span class=o>}</span><span class=w> </span><span class=o>(</span><span class=n>α</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=kt>Type</span><span class=w> </span><span class=n>u</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>α</span><span class=o>)</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=n>a</span>

<span class=c>/-</span><span class=cm> 隐式类型宇宙参数，等价于 `id₁`。需启用选项 `autoImplicit true`（默认启用） -/</span>
<span class=kd>def</span><span class=w> </span><span class=n>id₂</span><span class=w> </span><span class=o>(</span><span class=n>α</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=kt>Type</span><span class=w> </span><span class=n>u</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>α</span><span class=o>)</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=n>a</span>

<span class=c>/-</span><span class=cm> 显式独立宇宙变量声明，等价于 `id₁` 和 `id₂` -/</span>
<span class=kd>universe</span><span class=w> </span><span class=n>u</span>
<span class=kd>def</span><span class=w> </span><span class=n>id₃</span><span class=w> </span><span class=o>(</span><span class=n>α</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=kt>Type</span><span class=w> </span><span class=n>u</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>α</span><span class=o>)</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=n>a</span>
</code></pre></div> <p>技术细节：若宇宙变量仅用于定义的右侧且未预先声明，将引发错误。</p> <div class=highlight><pre><span></span><code><span class=kd>def</span><span class=w> </span><span class=n>L₁</span><span class=bp>.</span><span class=o>{</span><span class=n>u</span><span class=o>}</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=n>List</span><span class=w> </span><span class=o>(</span><span class=kt>Type</span><span class=w> </span><span class=n>u</span><span class=o>)</span>

<span class=c1>-- def L₂ := List (Type u) -- 错误：`未知宇宙层级 &#39;u&#39;`</span>

<span class=kd>universe</span><span class=w> </span><span class=n>u</span>
<span class=kd>def</span><span class=w> </span><span class=n>L₃</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=n>List</span><span class=w> </span><span class=o>(</span><span class=kt>Type</span><span class=w> </span><span class=n>u</span><span class=o>)</span>
</code></pre></div> <p>示例：</p> <div class=highlight><pre><span></span><code><span class=kd>universe</span><span class=w> </span><span class=n>u</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=n>w</span>

<span class=kd>structure</span><span class=w> </span><span class=n>Pair</span><span class=w> </span><span class=o>(</span><span class=n>α</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=kt>Type</span><span class=w> </span><span class=n>u</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>β</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=kt>Type</span><span class=w> </span><span class=n>v</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=kt>Type</span><span class=w> </span><span class=o>(</span><span class=n>max</span><span class=w> </span><span class=n>u</span><span class=w> </span><span class=n>v</span><span class=o>)</span><span class=w> </span><span class=n>where</span>
<span class=w>  </span><span class=n>a</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>α</span>
<span class=w>  </span><span class=n>b</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>β</span>

<span class=k>#check</span><span class=w> </span><span class=n>Pair</span><span class=bp>.</span><span class=o>{</span><span class=n>v</span><span class=o>,</span><span class=w> </span><span class=n>w</span><span class=o>}</span>
<span class=c1>-- Pair : Type v → Type w → Type (max v w)</span>
</code></pre></div> <h2 id=unseal>unseal<a class=headerlink href=#unseal title="Permanent link">&para;</a></h2> <p>Defined in: <code>Lean.Parser.commandUnseal__</code></p> <p><code>unseal foo</code> 命令确保 <code>foo</code> 的定义未密封，即标记为 <code>[semireducible]</code>（默认可规约设置）。 此命令在需要允许证明中对 <code>foo</code> 进行一定程度的规约时有用。</p> <p>在功能上，<code>unseal foo</code> 等同于 <code>attribute [local semireducible] foo</code>。应用此属性会使 <code>foo</code> 仅在局部作用域内半可约。</p> <h2 id=unset_option>unset_option<a class=headerlink href=#unset_option title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Elab.Command.unsetOption</code></p> <p>取消设置用户选项</p> <h2 id=unsuppress_compilation>unsuppress_compilation<a class=headerlink href=#unsuppress_compilation title="Permanent link">&para;</a></h2> <p>定义于：<code>commandUnsuppress_compilationIn_</code></p> <p>命令 <code>unsuppress_compilation in def foo : ...</code> 确保即使 <code>suppress_compilation</code> 处于激活状态，该定义仍会被编译为可执行代码。</p> <h2 id=variable>variable<a class=headerlink href=#variable title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Command.variable</code></p> <p>声明一个或多个类型化变量，或修改已声明变量的隐式性。</p> <p>引入可在同一 <code>namespace</code> 或 <code>section</code> 块内定义中使用的变量。当定义中提及变量时，Lean 会将其作为该定义的参数添加。这在编写许多具有共同参数的定义时特别有用（参见下面的示例）。</p> <p>变量声明具有与常规函数参数相同的灵活性。特别是它们可以是[显式、隐式][binder docs]，或[实例隐式][tpil classes]（此时它们可以是匿名的）。例如，可以通过 <code>variable {x}</code> 将显式变量 <code>x</code> 转换为隐式。注意，当前应避免同时更改变量绑定方式和声明新变量；有关此主题的更多信息，请参见[问题 2789]。</p> <p>在*定理体*（即证明）中，变量不会基于使用情况被包含，以确保对证明的更改不会影响整体定理的陈述。相反，变量仅在定理头部或 <code>include</code> 命令中提及过，或者作为实例隐式且仅依赖于此类变量时，才对证明可用。</p> <p>有关更详细的讨论，请参阅 <a href=https://lean-lang.org/theorem_proving_in_lean4/dependent_type_theory.html#variables-and-sections><em>定理证明中的变量与节</em></a>。</p> <p>（定理证明中的变量与节）[tpil classes]: <a href=https://lean-lang.org/theorem_proving_in_lean4/type_classes.html>https://lean-lang.org/theorem_proving_in_lean4/type_classes.html</a> （定理证明中的类型类）[binder docs]: <a href=https://leanprover-community.github.io/mathlib4_docs/Lean/Expr.html#Lean.BinderInfo>https://leanprover-community.github.io/mathlib4_docs/Lean/Expr.html#Lean.BinderInfo</a> （BinderInfo 类型的文档）[issue 2789]: <a href=https://github.com/leanprover/lean4/issues/2789>https://github.com/leanprover/lean4/issues/2789</a> （GitHub 上的问题 2789）</p> <p>示例：</p> <div class=highlight><pre><span></span><code><span class=kn>section</span>
<span class=w>  </span><span class=kd>variable</span>
<span class=w>    </span><span class=o>{</span><span class=n>α</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=kt>Type</span><span class=w> </span><span class=n>u</span><span class=o>}</span><span class=w>      </span><span class=c1>-- 隐式</span>
<span class=w>    </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>α</span><span class=o>)</span><span class=w>           </span><span class=c1>-- 显式</span>
<span class=w>    </span><span class=o>[</span><span class=n>instBEq</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>BEq</span><span class=w> </span><span class=n>α</span><span class=o>]</span><span class=w> </span><span class=c1>-- 实例隐式，具名</span>
<span class=w>    </span><span class=o>[</span><span class=n>Hashable</span><span class=w> </span><span class=n>α</span><span class=o>]</span><span class=w>      </span><span class=c1>-- 实例隐式，匿名</span>

<span class=w>  </span><span class=kd>def</span><span class=w> </span><span class=n>isEqual</span><span class=w> </span><span class=o>(</span><span class=n>b</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>α</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Bool</span><span class=w> </span><span class=o>:=</span>
<span class=w>    </span><span class=n>a</span><span class=w> </span><span class=bp>==</span><span class=w> </span><span class=n>b</span>

<span class=w>  </span><span class=k>#check</span><span class=w> </span><span class=n>isEqual</span>
<span class=w>  </span><span class=c1>-- isEqual.{u} {α : Type u} (a : α) [instBEq : BEq α] (b : α) : Bool</span>

<span class=w>  </span><span class=kd>variable</span>
<span class=w>    </span><span class=o>{</span><span class=n>a</span><span class=o>}</span><span class=w> </span><span class=c1>-- 现在 `a` 是隐式的</span>

<span class=w>  </span><span class=kd>def</span><span class=w> </span><span class=n>eqComm</span><span class=w> </span><span class=o>{</span><span class=n>b</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>α</span><span class=o>}</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>==</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=bp>↔</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=bp>==</span><span class=w> </span><span class=n>a</span>

<span class=w>  </span><span class=k>#check</span><span class=w> </span><span class=n>eqComm</span>
<span class=w>  </span><span class=c1>-- eqComm.{u} {α : Type u} {a : α} [instBEq : BEq α] {b : α} : Prop</span>
<span class=kd>end</span>
</code></pre></div> <p>以下展示了使用 <code>variable</code> 提取定义参数的典型用法：</p> <div class=highlight><pre><span></span><code><span class=kd>variable</span><span class=w> </span><span class=o>(</span><span class=n>Src</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=kt>Type</span><span class=o>)</span>

<span class=kd>structure</span><span class=w> </span><span class=n>Logger</span><span class=w> </span><span class=n>where</span>
<span class=w>  </span><span class=n>trace</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>List</span><span class=w> </span><span class=o>(</span><span class=n>Src</span><span class=w> </span><span class=bp>×</span><span class=w> </span><span class=n>String</span><span class=o>)</span>
<span class=k>#check</span><span class=w> </span><span class=n>Logger</span>
<span class=c1>-- Logger (Src : Type) : Type</span>

<span class=kn>namespace</span><span class=w> </span><span class=n>Logger</span>
<span class=w>  </span><span class=c1>-- 将 `Src : Type` 切换为隐式，直到 `end Logger`</span>
<span class=w>  </span><span class=kd>variable</span><span class=w> </span><span class=o>{</span><span class=n>Src</span><span class=o>}</span>

<span class=w>  </span><span class=kd>def</span><span class=w> </span><span class=n>empty</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Logger</span><span class=w> </span><span class=n>Src</span><span class=w> </span><span class=n>where</span>
<span class=w>    </span><span class=n>trace</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=o>[]</span>
<span class=w>  </span><span class=k>#check</span><span class=w> </span><span class=n>empty</span>
<span class=w>  </span><span class=c1>-- Logger.empty {Src : Type} : Logger Src</span>

<span class=w>  </span><span class=kd>variable</span><span class=w> </span><span class=o>(</span><span class=n>log</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Logger</span><span class=w> </span><span class=n>Src</span><span class=o>)</span>

<span class=w>  </span><span class=kd>def</span><span class=w> </span><span class=n>len</span><span class=w> </span><span class=o>:=</span>
<span class=w>    </span><span class=n>log.trace.length</span>
<span class=w>  </span><span class=k>#check</span><span class=w> </span><span class=n>len</span>
<span class=w>  </span><span class=c1>-- Logger.len {Src : Type} (log : Logger Src) : Nat</span>

<span class=w>  </span><span class=kd>variable</span><span class=w> </span><span class=o>(</span><span class=n>src</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Src</span><span class=o>)</span><span class=w> </span><span class=o>[</span><span class=n>BEq</span><span class=w> </span><span class=n>Src</span><span class=o>]</span>

<span class=w>  </span><span class=c1>-- 此时所有 `log`、`src`、`Src` 及 `BEq` 实例均可成为参数</span>

<span class=w>  </span><span class=kd>def</span><span class=w> </span><span class=n>filterSrc</span><span class=w> </span><span class=o>:=</span>
<span class=w>    </span><span class=n>log.trace.filterMap</span>
<span class=w>      </span><span class=k>fun</span><span class=w> </span><span class=o>(</span><span class=n>src&#39;</span><span class=o>,</span><span class=w> </span><span class=n>str&#39;</span><span class=o>)</span><span class=w> </span><span class=bp>=&gt;</span><span class=w> </span><span class=k>if</span><span class=w> </span><span class=n>src&#39;</span><span class=w> </span><span class=bp>==</span><span class=w> </span><span class=n>src</span><span class=w> </span><span class=k>then</span><span class=w> </span><span class=n>some</span><span class=w> </span><span class=n>str&#39;</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=n>none</span>
<span class=w>  </span><span class=k>#check</span><span class=w> </span><span class=n>filterSrc</span>
<span class=w>  </span><span class=c1>-- Logger.filterSrc {Src : Type} (log : Logger Src) (src : Src) [inst✝ : BEq Src] : List String</span>

<span class=w>  </span><span class=kd>def</span><span class=w> </span><span class=n>lenSrc</span><span class=w> </span><span class=o>:=</span>
<span class=w>    </span><span class=n>log.filterSrc</span><span class=w> </span><span class=n>src</span><span class=w> </span><span class=bp>|&gt;.</span><span class=n>length</span>
<span class=w>  </span><span class=k>#check</span><span class=w> </span><span class=n>lenSrc</span>
<span class=w>  </span><span class=c1>-- Logger.lenSrc {Src : Type} (log : Logger Src) (src : Src) [inst✝ : BEq Src] : Nat</span>
<span class=kd>end</span><span class=w> </span><span class=n>Logger</span>
</code></pre></div> <p>以下示例展示了变量在证明中的可用性： <div class=highlight><pre><span></span><code><span class=kd>variable</span>
<span class=w>  </span><span class=o>{</span><span class=n>α</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=kt>Type</span><span class=o>}</span><span class=w>    </span><span class=c1>-- 在证明中可用，因通过 `a` 间接提及</span>
<span class=w>  </span><span class=o>[</span><span class=n>ToString</span><span class=w> </span><span class=n>α</span><span class=o>]</span><span class=w>  </span><span class=c1>-- 在证明中可用，因 `α` 被包含</span>
<span class=w>  </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>α</span><span class=o>)</span><span class=w>       </span><span class=c1>-- 在证明中可用，因在头部提及</span>
<span class=w>  </span><span class=o>{</span><span class=n>β</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=kt>Type</span><span class=o>}</span><span class=w>    </span><span class=c1>-- 在证明中不可用</span>
<span class=w>  </span><span class=o>[</span><span class=n>ToString</span><span class=w> </span><span class=n>β</span><span class=o>]</span><span class=w>  </span><span class=c1>-- 在证明中不可用</span>

<span class=kd>theorem</span><span class=w> </span><span class=n>ex</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=n>rfl</span>
</code></pre></div> 在证明精化后，将生成以下警告以突出未使用的假设： <div class=highlight><pre><span></span><code><span class=bp>包含的节变量</span><span class=w> </span><span class=bp>&#39;</span><span class=o>[</span><span class=n>ToString</span><span class=w> </span><span class=n>α</span><span class=o>]</span><span class=bp>&#39;</span><span class=w> </span><span class=bp>在</span><span class=w> </span><span class=bp>&#39;</span><span class=n>ex&#39;</span><span class=w> </span><span class=bp>中未使用，请考虑排除它</span>
</code></pre></div> 在此类情况下，应将有问题的变量声明下移或放入节中，仅让依赖它的定理跟随至节结束。</p> <h2 id=variable_1>variable?<a class=headerlink href=#variable_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Command.Variable.variable?</code></p> <p><code>variable?</code> 命令与 <code>variable</code> 语法相同，但会自动插入所需但缺失的实例参数。它不会添加可从当前上下文中其他变量推导出的变量。默认情况下，该命令检查变量是否未被之前的变量隐含，但*不*检查之前的变量是否未被之后的变量隐含。与 <code>variable</code> 不同，<code>variable?</code> 不支持更改变量绑定类型。</p> <p><code>variable?</code> 命令会建议将其自身替换为形如 <code>variable? ...binders... =&gt; ...binders...</code> 的命令。<code>=&gt;</code> 后的绑定器是完整的绑定器列表。当存在此 <code>=&gt;</code> 子句时，命令验证扩展后的绑定器是否与 <code>=&gt;</code> 后的绑定器匹配。此举旨在帮助使用 <code>variable?</code> 的代码对类型类层次结构的变化保持弹性，至少此附加信息可用于调试可能出现的问题。也可将 <code>variable? ...binders... =&gt;</code> 替换为 <code>variable</code>。</p> <p>核心算法是尝试逐一精化绑定器，每当出现类型类实例推断失败时，合成绑定器语法并将其添加到绑定器列表并重试，递归进行。此过程不保证给出“正确”的绑定器列表。</p> <p>标有 <code>variable_alias</code> 属性的结构可作为一系列类型类的别名。例如，给定 <div class=highlight><pre><span></span><code><span class=kd>@[</span><span class=n>variable_alias</span><span class=kd>]</span>
<span class=kd>structure</span><span class=w> </span><span class=n>VectorSpace</span><span class=w> </span><span class=o>(</span><span class=n>k</span><span class=w> </span><span class=n>V</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=kt>Type</span><span class=bp>*</span><span class=o>)</span><span class=w> </span><span class=o>[</span><span class=n>Field</span><span class=w> </span><span class=n>k</span><span class=o>]</span><span class=w> </span><span class=o>[</span><span class=n>AddCommGroup</span><span class=w> </span><span class=n>V</span><span class=o>]</span><span class=w> </span><span class=o>[</span><span class=n>Module</span><span class=w> </span><span class=n>k</span><span class=w> </span><span class=n>V</span><span class=o>]</span>
</code></pre></div> 则 <code>variable? [VectorSpace k V]</code> 等同于 <code>variable {k V : Type*} [Field k] [AddCommGroup V] [Module k V]</code>，假设当前作用域中 <code>k</code> 和 <code>V</code> 没有预先存在的实例。注意，这不是简单替换：它仅添加无法从当前作用域中其他变量推断出的实例。</p> <p>警告：核心算法依赖美观打印，因此若绑定器中的项无法往返，此算法可能失败。但该算法支持如 <code>[∀ i, F i]</code> 的量化绑定器。</p> <h2 id=variables>variables<a class=headerlink href=#variables title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.variables</code></p> <p><code>variables</code> 命令的语法：此命令仅为存根，仅提示在 Lean 4 中已更名为 <code>variable</code>。</p> <h2 id=whatsnew>whatsnew<a class=headerlink href=#whatsnew title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.WhatsNew.commandWhatsnewIn__</code></p> <p><code>whatsnew in $command</code> 执行命令并打印添加到环境中的声明。</p> <h2 id=with_weak_namespace>with_weak_namespace<a class=headerlink href=#with_weak_namespace title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Elab.Command.commandWith_weak_namespace__</code></p> <p>更改当前命名空间，但不会导致作用域内事物退出作用域</p> <p>语法 ... [Batteries.Tactic.Lemma.lemmaCmd] 不支持 <code>lemma</code>，请改用 <code>theorem</code></p> <p>语法 ... [Lean.Parser.Command.declaration]</p> <p>语法 ... [Lean.Parser.Command.initialize]</p> <p>语法 ... [Lean.Parser.Command.mixfix]</p> <p>语法 ... [«lemma»] <code>lemma</code> 与 <code>theorem</code> 含义相同，用于表示“次要”定理</p> </article> </div> <script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script> </div> </main> <footer class=md-footer> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-copyright> Made with <a href=https://squidfunk.github.io/mkdocs-material/ target=_blank rel=noopener> Material for MkDocs </a> </div> </div> </div> </footer> </div> <div class=md-dialog data-md-component=dialog> <div class="md-dialog__inner md-typeset"></div> </div> <script id=__config type=application/json>{"base": "../..", "features": ["navigation.tabs", "navigation.sections", "navigation.instant", "search.highlight", "search.share", "content.code.copy", "content.code.annotate"], "search": "../../assets/javascripts/workers/search.973d3a69.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": {"alias": true, "default": "latest", "provider": "mike"}}</script> <script src=../../assets/javascripts/bundle.f55a23d4.min.js></script> <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> </body> </html>