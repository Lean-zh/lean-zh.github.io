<!doctype html><html lang=en class=no-js> <head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link href=https://leanprover.cn/mathlib4_help/tactics/ rel=canonical><link rel=icon href=../../assets/images/favicon.png><meta name=generator content="mkdocs-1.6.1, mkdocs-material-9.6.20"><title>策略 - Lean Prover 中文文档</title><link rel=stylesheet href=../../assets/stylesheets/main.e53b48f4.min.css><link rel=stylesheet href=../../assets/stylesheets/palette.06af60db.min.css><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback"><style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style><link rel=stylesheet href=../../assets/css/admonition-custom.css><link rel=stylesheet href=../../assets/css/custom.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css><script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script></head> <body dir=ltr data-md-color-scheme=default data-md-color-primary=green data-md-color-accent=light-green> <input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off> <input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off> <label class=md-overlay for=__drawer></label> <div data-md-component=skip> <a href=#_1 class=md-skip> Skip to content </a> </div> <div data-md-component=announce> </div> <div data-md-color-scheme=default data-md-component=outdated hidden> </div> <header class=md-header data-md-component=header> <nav class="md-header__inner md-grid" aria-label=Header> <a href=../.. title="Lean Prover 中文文档" class="md-header__button md-logo" aria-label="Lean Prover 中文文档" data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg> </a> <label class="md-header__button md-icon" for=__drawer> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg> </label> <div class=md-header__title data-md-component=header-title> <div class=md-header__ellipsis> <div class=md-header__topic> <span class=md-ellipsis> Lean Prover 中文文档 </span> </div> <div class=md-header__topic data-md-component=header-topic> <span class=md-ellipsis> 策略 </span> </div> </div> </div> <label class="md-header__button md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg> </label> <div class=md-search data-md-component=search role=dialog> <label class=md-search__overlay for=__search></label> <div class=md-search__inner role=search> <form class=md-search__form name=search> <input type=text class=md-search__input name=query aria-label=Search placeholder=Search autocapitalize=off autocorrect=off autocomplete=off spellcheck=false data-md-component=search-query required> <label class="md-search__icon md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg> </label> <nav class=md-search__options aria-label=Search> <a href=javascript:void(0) class="md-search__icon md-icon" title=Share aria-label=Share data-clipboard data-clipboard-text data-md-component=search-share tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.15c-.05.21-.08.43-.08.66 0 1.61 1.31 2.91 2.92 2.91s2.92-1.3 2.92-2.91A2.92 2.92 0 0 0 18 16.08"/></svg> </a> <button type=reset class="md-search__icon md-icon" title=Clear aria-label=Clear tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg> </button> </nav> </form> <div class=md-search__output> <div class=md-search__scrollwrap tabindex=0 data-md-scrollfix> <div class=md-search-result data-md-component=search-result> <div class=md-search-result__meta> Initializing search </div> <ol class=md-search-result__list role=presentation></ol> </div> </div> </div> </div> </div> <div class=md-header__source> <a href=https://github.com/Lean-zh/Lean-zh.github.io title="Go to repository" class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><!-- Font Awesome Free 7.0.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M439.6 236.1 244 40.5c-5.4-5.5-12.8-8.5-20.4-8.5s-15 3-20.4 8.4L162.5 81l51.5 51.5c27.1-9.1 52.7 16.8 43.4 43.7l49.7 49.7c34.2-11.8 61.2 31 35.5 56.7-26.5 26.5-70.2-2.9-56-37.3L240.3 199v121.9c25.3 12.5 22.3 41.8 9.1 55-6.4 6.4-15.2 10.1-24.3 10.1s-17.8-3.6-24.3-10.1c-17.6-17.6-11.1-46.9 11.2-56v-123c-20.8-8.5-24.6-30.7-18.6-45L142.6 101 8.5 235.1C3 240.6 0 247.9 0 255.5s3 15 8.5 20.4l195.6 195.7c5.4 5.4 12.7 8.4 20.4 8.4s15-3 20.4-8.4l194.7-194.7c5.4-5.4 8.4-12.8 8.4-20.4s-3-15-8.4-20.4"/></svg> </div> <div class=md-source__repository> Lean-zh </div> </a> </div> </nav> </header> <div class=md-container data-md-component=container> <nav class=md-tabs aria-label=Tabs data-md-component=tabs> <div class=md-grid> <ul class=md-tabs__list> <li class=md-tabs__item> <a href=../.. class=md-tabs__link> 主页 </a> </li> <li class=md-tabs__item> <a href=../../projects/verso/ class=md-tabs__link> 项目教程 </a> </li> </ul> </div> </nav> <main class=md-main data-md-component=main> <div class="md-main__inner md-grid"> <div class="md-sidebar md-sidebar--primary" data-md-component=sidebar data-md-type=navigation> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--primary md-nav--lifted" aria-label=Navigation data-md-level=0> <label class=md-nav__title for=__drawer> <a href=../.. title="Lean Prover 中文文档" class="md-nav__button md-logo" aria-label="Lean Prover 中文文档" data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg> </a> Lean Prover 中文文档 </label> <div class=md-nav__source> <a href=https://github.com/Lean-zh/Lean-zh.github.io title="Go to repository" class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><!-- Font Awesome Free 7.0.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M439.6 236.1 244 40.5c-5.4-5.5-12.8-8.5-20.4-8.5s-15 3-20.4 8.4L162.5 81l51.5 51.5c27.1-9.1 52.7 16.8 43.4 43.7l49.7 49.7c34.2-11.8 61.2 31 35.5 56.7-26.5 26.5-70.2-2.9-56-37.3L240.3 199v121.9c25.3 12.5 22.3 41.8 9.1 55-6.4 6.4-15.2 10.1-24.3 10.1s-17.8-3.6-24.3-10.1c-17.6-17.6-11.1-46.9 11.2-56v-123c-20.8-8.5-24.6-30.7-18.6-45L142.6 101 8.5 235.1C3 240.6 0 247.9 0 255.5s3 15 8.5 20.4l195.6 195.7c5.4 5.4 12.7 8.4 20.4 8.4s15-3 20.4-8.4l194.7-194.7c5.4-5.4 8.4-12.8 8.4-20.4s-3-15-8.4-20.4"/></svg> </div> <div class=md-source__repository> Lean-zh </div> </a> </div> <ul class=md-nav__list data-md-scrollfix> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_1> <label class=md-nav__link for=__nav_1 id=__nav_1_label tabindex=0> <span class=md-ellipsis> 主页 </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_1_label aria-expanded=false> <label class=md-nav__title for=__nav_1> <span class="md-nav__icon md-icon"></span> 主页 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../.. class=md-nav__link> <span class=md-ellipsis> Lean-zh </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_2> <label class=md-nav__link for=__nav_2 id=__nav_2_label tabindex=0> <span class=md-ellipsis> 项目教程 </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_2_label aria-expanded=false> <label class=md-nav__title for=__nav_2> <span class="md-nav__icon md-icon"></span> 项目教程 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../projects/verso/ class=md-nav__link> <span class=md-ellipsis> Verso 教程 </span> </a> </li> </ul> </nav> </li> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component=sidebar data-md-type=toc> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--secondary" aria-label="Table of contents"> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> Table of contents </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#adaptation_note class=md-nav__link> <span class=md-ellipsis> #adaptation_note </span> </a> </li> <li class=md-nav__item> <a href=#check class=md-nav__link> <span class=md-ellipsis> #check </span> </a> </li> <li class=md-nav__item> <a href=#count_heartbeats class=md-nav__link> <span class=md-ellipsis> #count_heartbeats </span> </a> </li> <li class=md-nav__item> <a href=#count_heartbeats_1 class=md-nav__link> <span class=md-ellipsis> #count_heartbeats! </span> </a> </li> <li class=md-nav__item> <a href=#find class=md-nav__link> <span class=md-ellipsis> #find </span> </a> </li> <li class=md-nav__item> <a href=#leansearch class=md-nav__link> <span class=md-ellipsis> #leansearch </span> </a> </li> <li class=md-nav__item> <a href=#loogle class=md-nav__link> <span class=md-ellipsis> #loogle </span> </a> <nav class=md-nav aria-label=#loogle> <ul class=md-nav__list> <li class=md-nav__item> <a href=#loogle_1 class=md-nav__link> <span class=md-ellipsis> Loogle 使用指南 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#loogle_2 class=md-nav__link> <span class=md-ellipsis> #loogle </span> </a> </li> <li class=md-nav__item> <a href=#moogle class=md-nav__link> <span class=md-ellipsis> #moogle </span> </a> </li> <li class=md-nav__item> <a href=#search class=md-nav__link> <span class=md-ellipsis> #search </span> </a> </li> <li class=md-nav__item> <a href=#statesearch class=md-nav__link> <span class=md-ellipsis> #statesearch </span> </a> </li> <li class=md-nav__item> <a href=#_2 class=md-nav__link> <span class=md-ellipsis> ( </span> </a> </li> <li class=md-nav__item> <a href=#_3 class=md-nav__link> <span class=md-ellipsis> &lt;;&gt; </span> </a> </li> <li class=md-nav__item> <a href=#_4 class=md-nav__link> <span class=md-ellipsis> &lt;;&gt; </span> </a> </li> <li class=md-nav__item> <a href=#_ class=md-nav__link> <span class=md-ellipsis> _ </span> </a> </li> <li class=md-nav__item> <a href=#abel class=md-nav__link> <span class=md-ellipsis> abel </span> </a> <nav class=md-nav aria-label=abel> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_5 class=md-nav__link> <span class=md-ellipsis> 未来工作 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#abel_1 class=md-nav__link> <span class=md-ellipsis> abel! </span> </a> <nav class=md-nav aria-label=abel!> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_6 class=md-nav__link> <span class=md-ellipsis> 未来工作 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#abel1 class=md-nav__link> <span class=md-ellipsis> abel1 </span> </a> <nav class=md-nav aria-label=abel1> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_7 class=md-nav__link> <span class=md-ellipsis> 未来工作 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#abel1_1 class=md-nav__link> <span class=md-ellipsis> abel1! </span> </a> <nav class=md-nav aria-label=abel1!> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_8 class=md-nav__link> <span class=md-ellipsis> 未来工作 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#abel_nf class=md-nav__link> <span class=md-ellipsis> abel_nf </span> </a> <nav class=md-nav aria-label=abel_nf> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_9 class=md-nav__link> <span class=md-ellipsis> 未来工作 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#abel_nf_1 class=md-nav__link> <span class=md-ellipsis> abel_nf! </span> </a> <nav class=md-nav aria-label=abel_nf!> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_10 class=md-nav__link> <span class=md-ellipsis> 未来工作 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#absurd class=md-nav__link> <span class=md-ellipsis> absurd </span> </a> </li> <li class=md-nav__item> <a href=#ac_change class=md-nav__link> <span class=md-ellipsis> ac_change </span> </a> </li> <li class=md-nav__item> <a href=#ac_nf class=md-nav__link> <span class=md-ellipsis> ac_nf </span> </a> </li> <li class=md-nav__item> <a href=#ac_nf0 class=md-nav__link> <span class=md-ellipsis> ac_nf0 </span> </a> </li> <li class=md-nav__item> <a href=#ac_rfl class=md-nav__link> <span class=md-ellipsis> ac_rfl </span> </a> </li> <li class=md-nav__item> <a href=#admit class=md-nav__link> <span class=md-ellipsis> admit </span> </a> </li> <li class=md-nav__item> <a href=#aesop class=md-nav__link> <span class=md-ellipsis> aesop </span> </a> </li> <li class=md-nav__item> <a href=#aesop_1 class=md-nav__link> <span class=md-ellipsis> aesop? </span> </a> </li> <li class=md-nav__item> <a href=#aesop_cat class=md-nav__link> <span class=md-ellipsis> aesop_cat </span> </a> </li> <li class=md-nav__item> <a href=#aesop_cat_1 class=md-nav__link> <span class=md-ellipsis> aesop_cat? </span> </a> </li> <li class=md-nav__item> <a href=#aesop_cat_nonterminal class=md-nav__link> <span class=md-ellipsis> aesop_cat_nonterminal </span> </a> </li> <li class=md-nav__item> <a href=#aesop_graph class=md-nav__link> <span class=md-ellipsis> aesop_graph </span> </a> </li> <li class=md-nav__item> <a href=#aesop_graph_1 class=md-nav__link> <span class=md-ellipsis> aesop_graph? </span> </a> </li> <li class=md-nav__item> <a href=#aesop_graph_nonterminal class=md-nav__link> <span class=md-ellipsis> aesop_graph_nonterminal </span> </a> </li> <li class=md-nav__item> <a href=#aesop_mat class=md-nav__link> <span class=md-ellipsis> aesop_mat </span> </a> </li> <li class=md-nav__item> <a href=#aesop_unfold class=md-nav__link> <span class=md-ellipsis> aesop_unfold </span> </a> </li> <li class=md-nav__item> <a href=#aesop_unfold_1 class=md-nav__link> <span class=md-ellipsis> aesop_unfold </span> </a> </li> <li class=md-nav__item> <a href=#algebraize class=md-nav__link> <span class=md-ellipsis> algebraize </span> </a> </li> <li class=md-nav__item> <a href=#algebraize_only class=md-nav__link> <span class=md-ellipsis> algebraize_only </span> </a> </li> <li class=md-nav__item> <a href=#all_goals class=md-nav__link> <span class=md-ellipsis> all_goals </span> </a> </li> <li class=md-nav__item> <a href=#and_intros class=md-nav__link> <span class=md-ellipsis> and_intros </span> </a> </li> <li class=md-nav__item> <a href=#any_goals class=md-nav__link> <span class=md-ellipsis> any_goals </span> </a> </li> <li class=md-nav__item> <a href=#apply class=md-nav__link> <span class=md-ellipsis> apply </span> </a> </li> <li class=md-nav__item> <a href=#apply_1 class=md-nav__link> <span class=md-ellipsis> apply </span> </a> </li> <li class=md-nav__item> <a href=#apply_2 class=md-nav__link> <span class=md-ellipsis> apply </span> </a> </li> <li class=md-nav__item> <a href=#apply_3 class=md-nav__link> <span class=md-ellipsis> apply? </span> </a> </li> <li class=md-nav__item> <a href=#apply_assumption class=md-nav__link> <span class=md-ellipsis> apply_assumption </span> </a> </li> <li class=md-nav__item> <a href=#apply_ext_theorem class=md-nav__link> <span class=md-ellipsis> apply_ext_theorem </span> </a> </li> <li class=md-nav__item> <a href=#apply_fun class=md-nav__link> <span class=md-ellipsis> apply_fun </span> </a> </li> <li class=md-nav__item> <a href=#apply_gmonoid_gnpowrec_succ_tac class=md-nav__link> <span class=md-ellipsis> apply_gmonoid_gnpowRec_succ_tac </span> </a> </li> <li class=md-nav__item> <a href=#apply_gmonoid_gnpowrec_zero_tac class=md-nav__link> <span class=md-ellipsis> apply_gmonoid_gnpowRec_zero_tac </span> </a> </li> <li class=md-nav__item> <a href=#apply_mod_cast class=md-nav__link> <span class=md-ellipsis> apply_mod_cast </span> </a> </li> <li class=md-nav__item> <a href=#apply_rfl class=md-nav__link> <span class=md-ellipsis> apply_rfl </span> </a> </li> <li class=md-nav__item> <a href=#apply_rules class=md-nav__link> <span class=md-ellipsis> apply_rules </span> </a> </li> <li class=md-nav__item> <a href=#arith_mult class=md-nav__link> <span class=md-ellipsis> arith_mult </span> </a> </li> <li class=md-nav__item> <a href=#arith_mult_1 class=md-nav__link> <span class=md-ellipsis> arith_mult? </span> </a> </li> <li class=md-nav__item> <a href=#array_get_dec class=md-nav__link> <span class=md-ellipsis> array_get_dec </span> </a> </li> <li class=md-nav__item> <a href=#array_mem_dec class=md-nav__link> <span class=md-ellipsis> array_mem_dec </span> </a> </li> <li class=md-nav__item> <a href=#as_aux_lemma class=md-nav__link> <span class=md-ellipsis> as_aux_lemma </span> </a> </li> <li class=md-nav__item> <a href=#assumption class=md-nav__link> <span class=md-ellipsis> assumption </span> </a> </li> <li class=md-nav__item> <a href=#assumption_1 class=md-nav__link> <span class=md-ellipsis> assumption' </span> </a> </li> <li class=md-nav__item> <a href=#assumption_mod_cast class=md-nav__link> <span class=md-ellipsis> assumption_mod_cast </span> </a> </li> <li class=md-nav__item> <a href=#attempt_all class=md-nav__link> <span class=md-ellipsis> attempt_all </span> </a> </li> <li class=md-nav__item> <a href=#aux_group1 class=md-nav__link> <span class=md-ellipsis> aux_group₁ </span> </a> </li> <li class=md-nav__item> <a href=#aux_group2 class=md-nav__link> <span class=md-ellipsis> aux_group₂ </span> </a> </li> <li class=md-nav__item> <a href=#bdddefault class=md-nav__link> <span class=md-ellipsis> bddDefault </span> </a> </li> <li class=md-nav__item> <a href=#beta_reduce class=md-nav__link> <span class=md-ellipsis> beta_reduce </span> </a> </li> <li class=md-nav__item> <a href=#bicategory class=md-nav__link> <span class=md-ellipsis> bicategory </span> </a> </li> <li class=md-nav__item> <a href=#bicategory_coherence class=md-nav__link> <span class=md-ellipsis> bicategory_coherence </span> </a> </li> <li class=md-nav__item> <a href=#bicategory_coherence_1 class=md-nav__link> <span class=md-ellipsis> bicategory_coherence </span> </a> </li> <li class=md-nav__item> <a href=#bicategory_nf class=md-nav__link> <span class=md-ellipsis> bicategory_nf </span> </a> </li> <li class=md-nav__item> <a href=#bitwise_assoc_tac class=md-nav__link> <span class=md-ellipsis> bitwise_assoc_tac </span> </a> </li> <li class=md-nav__item> <a href=#borelize class=md-nav__link> <span class=md-ellipsis> borelize </span> </a> </li> <li class=md-nav__item> <a href=#bound class=md-nav__link> <span class=md-ellipsis> bound </span> </a> </li> <li class=md-nav__item> <a href=#bv_check class=md-nav__link> <span class=md-ellipsis> bv_check </span> </a> </li> <li class=md-nav__item> <a href=#bv_decide class=md-nav__link> <span class=md-ellipsis> bv_decide </span> </a> </li> <li class=md-nav__item> <a href=#bv_decide_1 class=md-nav__link> <span class=md-ellipsis> bv_decide? </span> </a> </li> <li class=md-nav__item> <a href=#bv_normalize class=md-nav__link> <span class=md-ellipsis> bv_normalize </span> </a> </li> <li class=md-nav__item> <a href=#bv_omega class=md-nav__link> <span class=md-ellipsis> bv_omega </span> </a> </li> <li class=md-nav__item> <a href=#by_cases class=md-nav__link> <span class=md-ellipsis> by_cases </span> </a> </li> <li class=md-nav__item> <a href=#by_contra class=md-nav__link> <span class=md-ellipsis> by_contra </span> </a> </li> <li class=md-nav__item> <a href=#calc class=md-nav__link> <span class=md-ellipsis> calc </span> </a> </li> <li class=md-nav__item> <a href=#calc_1 class=md-nav__link> <span class=md-ellipsis> calc? </span> </a> </li> <li class=md-nav__item> <a href=#cancel_denoms class=md-nav__link> <span class=md-ellipsis> cancel_denoms </span> </a> </li> <li class=md-nav__item> <a href=#cancel_denoms_1 class=md-nav__link> <span class=md-ellipsis> cancel_denoms </span> </a> </li> <li class=md-nav__item> <a href=#case class=md-nav__link> <span class=md-ellipsis> case </span> </a> </li> <li class=md-nav__item> <a href=#case_1 class=md-nav__link> <span class=md-ellipsis> case </span> </a> </li> <li class=md-nav__item> <a href=#case_2 class=md-nav__link> <span class=md-ellipsis> case' </span> </a> </li> <li class=md-nav__item> <a href=#case_3 class=md-nav__link> <span class=md-ellipsis> case' </span> </a> </li> <li class=md-nav__item> <a href=#cases class=md-nav__link> <span class=md-ellipsis> cases </span> </a> </li> <li class=md-nav__item> <a href=#cases_1 class=md-nav__link> <span class=md-ellipsis> cases' </span> </a> </li> <li class=md-nav__item> <a href=#cases_first_enat class=md-nav__link> <span class=md-ellipsis> cases_first_enat </span> </a> </li> <li class=md-nav__item> <a href=#cases_type class=md-nav__link> <span class=md-ellipsis> cases_type </span> </a> </li> <li class=md-nav__item> <a href=#cases_type_1 class=md-nav__link> <span class=md-ellipsis> cases_type! </span> </a> </li> <li class=md-nav__item> <a href=#casesm class=md-nav__link> <span class=md-ellipsis> casesm </span> </a> </li> <li class=md-nav__item> <a href=#casesm_1 class=md-nav__link> <span class=md-ellipsis> casesm! </span> </a> </li> <li class=md-nav__item> <a href=#cc class=md-nav__link> <span class=md-ellipsis> cc </span> </a> </li> <li class=md-nav__item> <a href=#cfc_cont_tac class=md-nav__link> <span class=md-ellipsis> cfc_cont_tac </span> </a> </li> <li class=md-nav__item> <a href=#cfc_tac class=md-nav__link> <span class=md-ellipsis> cfc_tac </span> </a> </li> <li class=md-nav__item> <a href=#cfc_zero_tac class=md-nav__link> <span class=md-ellipsis> cfc_zero_tac </span> </a> </li> <li class=md-nav__item> <a href=#change class=md-nav__link> <span class=md-ellipsis> change </span> </a> </li> <li class=md-nav__item> <a href=#change_1 class=md-nav__link> <span class=md-ellipsis> change </span> </a> </li> <li class=md-nav__item> <a href=#change_2 class=md-nav__link> <span class=md-ellipsis> change? </span> </a> </li> <li class=md-nav__item> <a href=#check_compositions class=md-nav__link> <span class=md-ellipsis> check_compositions </span> </a> </li> <li class=md-nav__item> <a href=#choose class=md-nav__link> <span class=md-ellipsis> choose </span> </a> </li> <li class=md-nav__item> <a href=#choose_1 class=md-nav__link> <span class=md-ellipsis> choose! </span> </a> </li> <li class=md-nav__item> <a href=#classical class=md-nav__link> <span class=md-ellipsis> classical </span> </a> </li> <li class=md-nav__item> <a href=#clean class=md-nav__link> <span class=md-ellipsis> clean </span> </a> </li> <li class=md-nav__item> <a href=#clean_wf class=md-nav__link> <span class=md-ellipsis> clean_wf </span> </a> </li> <li class=md-nav__item> <a href=#clear class=md-nav__link> <span class=md-ellipsis> clear </span> </a> </li> <li class=md-nav__item> <a href=#clear_1 class=md-nav__link> <span class=md-ellipsis> clear </span> </a> </li> <li class=md-nav__item> <a href=#clear_2 class=md-nav__link> <span class=md-ellipsis> clear! </span> </a> </li> <li class=md-nav__item> <a href=#clear_ class=md-nav__link> <span class=md-ellipsis> clear_ </span> </a> </li> <li class=md-nav__item> <a href=#clear_aux_decl class=md-nav__link> <span class=md-ellipsis> clear_aux_decl </span> </a> </li> <li class=md-nav__item> <a href=#clear_value class=md-nav__link> <span class=md-ellipsis> clear_value </span> </a> </li> <li class=md-nav__item> <a href=#coherence class=md-nav__link> <span class=md-ellipsis> coherence </span> </a> </li> <li class=md-nav__item> <a href=#compareoflessandeq_rfl class=md-nav__link> <span class=md-ellipsis> compareOfLessAndEq_rfl </span> </a> </li> <li class=md-nav__item> <a href=#compute_degree class=md-nav__link> <span class=md-ellipsis> compute_degree </span> </a> </li> <li class=md-nav__item> <a href=#compute_degree_1 class=md-nav__link> <span class=md-ellipsis> compute_degree! </span> </a> </li> <li class=md-nav__item> <a href=#congr class=md-nav__link> <span class=md-ellipsis> congr </span> </a> </li> <li class=md-nav__item> <a href=#congr_1 class=md-nav__link> <span class=md-ellipsis> congr </span> </a> </li> <li class=md-nav__item> <a href=#congr_2 class=md-nav__link> <span class=md-ellipsis> congr </span> </a> </li> <li class=md-nav__item> <a href=#congr_3 class=md-nav__link> <span class=md-ellipsis> congr! </span> </a> </li> <li class=md-nav__item> <a href=#congrm class=md-nav__link> <span class=md-ellipsis> congrm </span> </a> </li> <li class=md-nav__item> <a href=#congrm_1 class=md-nav__link> <span class=md-ellipsis> congrm? </span> </a> </li> <li class=md-nav__item> <a href=#constructor class=md-nav__link> <span class=md-ellipsis> constructor </span> </a> </li> <li class=md-nav__item> <a href=#constructorm class=md-nav__link> <span class=md-ellipsis> constructorm </span> </a> </li> <li class=md-nav__item> <a href=#continuity class=md-nav__link> <span class=md-ellipsis> continuity </span> </a> </li> <li class=md-nav__item> <a href=#continuity_1 class=md-nav__link> <span class=md-ellipsis> continuity? </span> </a> </li> <li class=md-nav__item> <a href=#contradiction class=md-nav__link> <span class=md-ellipsis> contradiction </span> </a> </li> <li class=md-nav__item> <a href=#contrapose class=md-nav__link> <span class=md-ellipsis> contrapose </span> </a> </li> <li class=md-nav__item> <a href=#contrapose_1 class=md-nav__link> <span class=md-ellipsis> contrapose! </span> </a> </li> <li class=md-nav__item> <a href=#conv class=md-nav__link> <span class=md-ellipsis> conv </span> </a> </li> <li class=md-nav__item> <a href=#conv_1 class=md-nav__link> <span class=md-ellipsis> conv' </span> </a> </li> <li class=md-nav__item> <a href=#conv_2 class=md-nav__link> <span class=md-ellipsis> conv? </span> </a> </li> <li class=md-nav__item> <a href=#conv_lhs class=md-nav__link> <span class=md-ellipsis> conv_lhs </span> </a> </li> <li class=md-nav__item> <a href=#conv_rhs class=md-nav__link> <span class=md-ellipsis> conv_rhs </span> </a> </li> <li class=md-nav__item> <a href=#convert class=md-nav__link> <span class=md-ellipsis> convert </span> </a> </li> <li class=md-nav__item> <a href=#convert_to class=md-nav__link> <span class=md-ellipsis> convert_to </span> </a> </li> <li class=md-nav__item> <a href=#count_heartbeats_2 class=md-nav__link> <span class=md-ellipsis> count_heartbeats </span> </a> </li> <li class=md-nav__item> <a href=#dbg_trace class=md-nav__link> <span class=md-ellipsis> dbg_trace </span> </a> </li> <li class=md-nav__item> <a href=#decide class=md-nav__link> <span class=md-ellipsis> decide </span> </a> </li> <li class=md-nav__item> <a href=#_11 class=md-nav__link> <span class=md-ellipsis> 性质与关系 </span> </a> </li> <li class=md-nav__item> <a href=#decreasing_tactic class=md-nav__link> <span class=md-ellipsis> decreasing_tactic </span> </a> </li> <li class=md-nav__item> <a href=#decreasing_trivial class=md-nav__link> <span class=md-ellipsis> decreasing_trivial </span> </a> </li> <li class=md-nav__item> <a href=#decreasing_trivial_pre_omega class=md-nav__link> <span class=md-ellipsis> decreasing_trivial_pre_omega </span> </a> </li> <li class=md-nav__item> <a href=#decreasing_with class=md-nav__link> <span class=md-ellipsis> decreasing_with </span> </a> </li> <li class=md-nav__item> <a href=#delta class=md-nav__link> <span class=md-ellipsis> delta </span> </a> </li> <li class=md-nav__item> <a href=#discrete_cases class=md-nav__link> <span class=md-ellipsis> discrete_cases </span> </a> </li> <li class=md-nav__item> <a href=#done class=md-nav__link> <span class=md-ellipsis> done </span> </a> </li> <li class=md-nav__item> <a href=#dsimp class=md-nav__link> <span class=md-ellipsis> dsimp </span> </a> </li> <li class=md-nav__item> <a href=#dsimp_1 class=md-nav__link> <span class=md-ellipsis> dsimp! </span> </a> </li> <li class=md-nav__item> <a href=#dsimp_2 class=md-nav__link> <span class=md-ellipsis> dsimp? </span> </a> </li> <li class=md-nav__item> <a href=#dsimp_3 class=md-nav__link> <span class=md-ellipsis> dsimp?! </span> </a> </li> <li class=md-nav__item> <a href=#eapply class=md-nav__link> <span class=md-ellipsis> eapply </span> </a> </li> <li class=md-nav__item> <a href=#econstructor class=md-nav__link> <span class=md-ellipsis> econstructor </span> </a> </li> <li class=md-nav__item> <a href=#elementwise class=md-nav__link> <span class=md-ellipsis> elementwise </span> </a> </li> <li class=md-nav__item> <a href=#elementwise_1 class=md-nav__link> <span class=md-ellipsis> elementwise! </span> </a> </li> <li class=md-nav__item> <a href=#else class=md-nav__link> <span class=md-ellipsis> else </span> </a> </li> <li class=md-nav__item> <a href=#else_1 class=md-nav__link> <span class=md-ellipsis> else </span> </a> </li> <li class=md-nav__item> <a href=#enat_to_nat class=md-nav__link> <span class=md-ellipsis> enat_to_nat </span> </a> </li> <li class=md-nav__item> <a href=#eq_refl class=md-nav__link> <span class=md-ellipsis> eq_refl </span> </a> </li> <li class=md-nav__item> <a href=#erw class=md-nav__link> <span class=md-ellipsis> erw </span> </a> </li> <li class=md-nav__item> <a href=#erw_1 class=md-nav__link> <span class=md-ellipsis> erw? </span> </a> </li> <li class=md-nav__item> <a href=#eta_expand class=md-nav__link> <span class=md-ellipsis> eta_expand </span> </a> </li> <li class=md-nav__item> <a href=#eta_reduce class=md-nav__link> <span class=md-ellipsis> eta_reduce </span> </a> </li> <li class=md-nav__item> <a href=#eta_struct class=md-nav__link> <span class=md-ellipsis> eta_struct </span> </a> </li> <li class=md-nav__item> <a href=#exact class=md-nav__link> <span class=md-ellipsis> exact </span> </a> </li> <li class=md-nav__item> <a href=#exact_1 class=md-nav__link> <span class=md-ellipsis> exact? </span> </a> </li> <li class=md-nav__item> <a href=#exact_mod_cast class=md-nav__link> <span class=md-ellipsis> exact_mod_cast </span> </a> </li> <li class=md-nav__item> <a href=#exacts class=md-nav__link> <span class=md-ellipsis> exacts </span> </a> </li> <li class=md-nav__item> <a href=#exfalso class=md-nav__link> <span class=md-ellipsis> exfalso </span> </a> </li> <li class=md-nav__item> <a href=#exists class=md-nav__link> <span class=md-ellipsis> exists </span> </a> </li> <li class=md-nav__item> <a href=#existsi class=md-nav__link> <span class=md-ellipsis> existsi </span> </a> </li> <li class=md-nav__item> <a href=#expose_names class=md-nav__link> <span class=md-ellipsis> expose_names </span> </a> </li> <li class=md-nav__item> <a href=#ext class=md-nav__link> <span class=md-ellipsis> ext </span> </a> </li> <li class=md-nav__item> <a href=#ext1 class=md-nav__link> <span class=md-ellipsis> ext1 </span> </a> </li> <li class=md-nav__item> <a href=#extract_goal class=md-nav__link> <span class=md-ellipsis> extract_goal </span> </a> </li> <li class=md-nav__item> <a href=#extract_lets class=md-nav__link> <span class=md-ellipsis> extract_lets </span> </a> </li> <li class=md-nav__item> <a href=#fail class=md-nav__link> <span class=md-ellipsis> fail </span> </a> </li> <li class=md-nav__item> <a href=#fail_if_no_progress class=md-nav__link> <span class=md-ellipsis> fail_if_no_progress </span> </a> </li> <li class=md-nav__item> <a href=#fail_if_success class=md-nav__link> <span class=md-ellipsis> fail_if_success </span> </a> </li> <li class=md-nav__item> <a href=#false_or_by_contra class=md-nav__link> <span class=md-ellipsis> false_or_by_contra </span> </a> </li> <li class=md-nav__item> <a href=#fapply class=md-nav__link> <span class=md-ellipsis> fapply </span> </a> </li> <li class=md-nav__item> <a href=#fconstructor class=md-nav__link> <span class=md-ellipsis> fconstructor </span> </a> </li> <li class=md-nav__item> <a href=#field_simp class=md-nav__link> <span class=md-ellipsis> field_simp </span> </a> </li> <li class=md-nav__item> <a href=#field_simp_discharge class=md-nav__link> <span class=md-ellipsis> field_simp_discharge </span> </a> </li> <li class=md-nav__item> <a href=#filter_upwards class=md-nav__link> <span class=md-ellipsis> filter_upwards </span> </a> </li> <li class=md-nav__item> <a href=#fin_cases class=md-nav__link> <span class=md-ellipsis> fin_cases </span> </a> </li> <li class=md-nav__item> <a href=#fin_omega class=md-nav__link> <span class=md-ellipsis> fin_omega </span> </a> </li> <li class=md-nav__item> <a href=#find_1 class=md-nav__link> <span class=md-ellipsis> find </span> </a> </li> <li class=md-nav__item> <a href=#finiteness class=md-nav__link> <span class=md-ellipsis> finiteness </span> </a> </li> <li class=md-nav__item> <a href=#finiteness_1 class=md-nav__link> <span class=md-ellipsis> finiteness? </span> </a> </li> <li class=md-nav__item> <a href=#finiteness_nonterminal class=md-nav__link> <span class=md-ellipsis> finiteness_nonterminal </span> </a> </li> <li class=md-nav__item> <a href=#first class=md-nav__link> <span class=md-ellipsis> first </span> </a> </li> <li class=md-nav__item> <a href=#focus class=md-nav__link> <span class=md-ellipsis> focus </span> </a> </li> <li class=md-nav__item> <a href=#forward class=md-nav__link> <span class=md-ellipsis> forward </span> </a> </li> <li class=md-nav__item> <a href=#forward_1 class=md-nav__link> <span class=md-ellipsis> forward? </span> </a> </li> <li class=md-nav__item> <a href=#frac_tac class=md-nav__link> <span class=md-ellipsis> frac_tac </span> </a> </li> <li class=md-nav__item> <a href=#fun_cases class=md-nav__link> <span class=md-ellipsis> fun_cases </span> </a> </li> <li class=md-nav__item> <a href=#fun_induction class=md-nav__link> <span class=md-ellipsis> fun_induction </span> </a> </li> <li class=md-nav__item> <a href=#fun_prop class=md-nav__link> <span class=md-ellipsis> fun_prop </span> </a> </li> <li class=md-nav__item> <a href=#funext class=md-nav__link> <span class=md-ellipsis> funext </span> </a> </li> <li class=md-nav__item> <a href=#gcongr class=md-nav__link> <span class=md-ellipsis> gcongr </span> </a> </li> <li class=md-nav__item> <a href=#gcongr_1 class=md-nav__link> <span class=md-ellipsis> gcongr? </span> </a> </li> <li class=md-nav__item> <a href=#gcongr_discharger class=md-nav__link> <span class=md-ellipsis> gcongr_discharger </span> </a> </li> <li class=md-nav__item> <a href=#generalize class=md-nav__link> <span class=md-ellipsis> generalize </span> </a> </li> <li class=md-nav__item> <a href=#generalize_1 class=md-nav__link> <span class=md-ellipsis> generalize' </span> </a> </li> <li class=md-nav__item> <a href=#generalize_proofs class=md-nav__link> <span class=md-ellipsis> generalize_proofs </span> </a> </li> <li class=md-nav__item> <a href=#get_elem_tactic class=md-nav__link> <span class=md-ellipsis> get_elem_tactic </span> </a> </li> <li class=md-nav__item> <a href=#get_elem_tactic_trivial class=md-nav__link> <span class=md-ellipsis> get_elem_tactic_trivial </span> </a> </li> <li class=md-nav__item> <a href=#ghost_calc class=md-nav__link> <span class=md-ellipsis> ghost_calc </span> </a> </li> <li class=md-nav__item> <a href=#ghost_fun_tac class=md-nav__link> <span class=md-ellipsis> ghost_fun_tac </span> </a> </li> <li class=md-nav__item> <a href=#ghost_simp class=md-nav__link> <span class=md-ellipsis> ghost_simp </span> </a> </li> <li class=md-nav__item> <a href=#grind class=md-nav__link> <span class=md-ellipsis> grind </span> </a> </li> <li class=md-nav__item> <a href=#grind_1 class=md-nav__link> <span class=md-ellipsis> grind? </span> </a> </li> <li class=md-nav__item> <a href=#group class=md-nav__link> <span class=md-ellipsis> group </span> </a> </li> <li class=md-nav__item> <a href=#guard_expr class=md-nav__link> <span class=md-ellipsis> guard_expr </span> </a> </li> <li class=md-nav__item> <a href=#guard_goal_nums class=md-nav__link> <span class=md-ellipsis> guard_goal_nums </span> </a> </li> <li class=md-nav__item> <a href=#guard_hyp class=md-nav__link> <span class=md-ellipsis> guard_hyp </span> </a> </li> <li class=md-nav__item> <a href=#guard_hyp_nums class=md-nav__link> <span class=md-ellipsis> guard_hyp_nums </span> </a> </li> <li class=md-nav__item> <a href=#guard_target class=md-nav__link> <span class=md-ellipsis> guard_target </span> </a> </li> <li class=md-nav__item> <a href=#have class=md-nav__link> <span class=md-ellipsis> have </span> </a> </li> <li class=md-nav__item> <a href=#have_1 class=md-nav__link> <span class=md-ellipsis> have </span> </a> </li> <li class=md-nav__item> <a href=#have_2 class=md-nav__link> <span class=md-ellipsis> have!? </span> </a> </li> <li class=md-nav__item> <a href=#have_3 class=md-nav__link> <span class=md-ellipsis> have' </span> </a> </li> <li class=md-nav__item> <a href=#have_4 class=md-nav__link> <span class=md-ellipsis> have' </span> </a> </li> <li class=md-nav__item> <a href=#have_5 class=md-nav__link> <span class=md-ellipsis> have? </span> </a> </li> <li class=md-nav__item> <a href=#have_6 class=md-nav__link> <span class=md-ellipsis> have?! </span> </a> </li> <li class=md-nav__item> <a href=#havei class=md-nav__link> <span class=md-ellipsis> haveI </span> </a> </li> <li class=md-nav__item> <a href=#hint class=md-nav__link> <span class=md-ellipsis> hint </span> </a> </li> <li class=md-nav__item> <a href=#induction class=md-nav__link> <span class=md-ellipsis> induction </span> </a> </li> <li class=md-nav__item> <a href=#induction_1 class=md-nav__link> <span class=md-ellipsis> induction' </span> </a> </li> <li class=md-nav__item> <a href=#infer_instance class=md-nav__link> <span class=md-ellipsis> infer_instance </span> </a> </li> <li class=md-nav__item> <a href=#infer_param class=md-nav__link> <span class=md-ellipsis> infer_param </span> </a> </li> <li class=md-nav__item> <a href=#inhabit class=md-nav__link> <span class=md-ellipsis> inhabit </span> </a> </li> <li class=md-nav__item> <a href=#init_ring class=md-nav__link> <span class=md-ellipsis> init_ring </span> </a> </li> <li class=md-nav__item> <a href=#injection class=md-nav__link> <span class=md-ellipsis> injection（单射分解） </span> </a> </li> <li class=md-nav__item> <a href=#injections class=md-nav__link> <span class=md-ellipsis> injections </span> </a> </li> <li class=md-nav__item> <a href=#interval_cases class=md-nav__link> <span class=md-ellipsis> interval_cases </span> </a> </li> <li class=md-nav__item> <a href=#intro class=md-nav__link> <span class=md-ellipsis> intro </span> </a> </li> <li class=md-nav__item> <a href=#intro_1 class=md-nav__link> <span class=md-ellipsis> intro </span> </a> </li> <li class=md-nav__item> <a href=#intro_2 class=md-nav__link> <span class=md-ellipsis> intro </span> </a> </li> <li class=md-nav__item> <a href=#intros class=md-nav__link> <span class=md-ellipsis> intros </span> </a> </li> <li class=md-nav__item> <a href=#introv class=md-nav__link> <span class=md-ellipsis> introv </span> </a> </li> <li class=md-nav__item> <a href=#isboundeddefault class=md-nav__link> <span class=md-ellipsis> isBoundedDefault </span> </a> </li> <li class=md-nav__item> <a href=#itauto class=md-nav__link> <span class=md-ellipsis> itauto </span> </a> </li> <li class=md-nav__item> <a href=#itauto_1 class=md-nav__link> <span class=md-ellipsis> itauto! </span> </a> </li> <li class=md-nav__item> <a href=#iterate class=md-nav__link> <span class=md-ellipsis> iterate </span> </a> </li> <li class=md-nav__item> <a href=#left class=md-nav__link> <span class=md-ellipsis> left </span> </a> </li> <li class=md-nav__item> <a href=#let class=md-nav__link> <span class=md-ellipsis> let </span> </a> </li> <li class=md-nav__item> <a href=#let_1 class=md-nav__link> <span class=md-ellipsis> let </span> </a> </li> <li class=md-nav__item> <a href=#let_2 class=md-nav__link> <span class=md-ellipsis> let </span> </a> </li> <li class=md-nav__item> <a href=#let_3 class=md-nav__link> <span class=md-ellipsis> let' </span> </a> </li> <li class=md-nav__item> <a href=#leti class=md-nav__link> <span class=md-ellipsis> letI </span> </a> </li> <li class=md-nav__item> <a href=#lift class=md-nav__link> <span class=md-ellipsis> lift </span> </a> </li> <li class=md-nav__item> <a href=#lift_lets class=md-nav__link> <span class=md-ellipsis> lift_lets </span> </a> </li> <li class=md-nav__item> <a href=#liftable_prefixes class=md-nav__link> <span class=md-ellipsis> liftable_prefixes </span> </a> </li> <li class=md-nav__item> <a href=#linarith class=md-nav__link> <span class=md-ellipsis> linarith </span> </a> </li> <li class=md-nav__item> <a href=#linarith_1 class=md-nav__link> <span class=md-ellipsis> linarith! </span> </a> </li> <li class=md-nav__item> <a href=#linear_combination class=md-nav__link> <span class=md-ellipsis> linear_combination </span> </a> </li> <li class=md-nav__item> <a href=#linear_combination_1 class=md-nav__link> <span class=md-ellipsis> linear_combination' </span> </a> </li> <li class=md-nav__item> <a href=#linear_combination_2 class=md-nav__link> <span class=md-ellipsis> linear_combination' </span> </a> </li> <li class=md-nav__item> <a href=#map_fun_tac class=md-nav__link> <span class=md-ellipsis> map_fun_tac </span> </a> </li> <li class=md-nav__item> <a href=#map_tacs class=md-nav__link> <span class=md-ellipsis> map_tacs </span> </a> </li> <li class=md-nav__item> <a href=#match class=md-nav__link> <span class=md-ellipsis> match </span> </a> </li> <li class=md-nav__item> <a href=#match_1 class=md-nav__link> <span class=md-ellipsis> match </span> </a> </li> <li class=md-nav__item> <a href=#match_scalars class=md-nav__link> <span class=md-ellipsis> match_scalars </span> </a> </li> <li class=md-nav__item> <a href=#match_target class=md-nav__link> <span class=md-ellipsis> match_target </span> </a> </li> <li class=md-nav__item> <a href=#measurability class=md-nav__link> <span class=md-ellipsis> measurability </span> </a> </li> <li class=md-nav__item> <a href=#measurability_1 class=md-nav__link> <span class=md-ellipsis> measurability! </span> </a> </li> <li class=md-nav__item> <a href=#measurability_2 class=md-nav__link> <span class=md-ellipsis> measurability!? </span> </a> </li> <li class=md-nav__item> <a href=#measurability_3 class=md-nav__link> <span class=md-ellipsis> measurability? </span> </a> </li> <li class=md-nav__item> <a href=#mem_tac class=md-nav__link> <span class=md-ellipsis> mem_tac </span> </a> </li> <li class=md-nav__item> <a href=#mem_tac_aux class=md-nav__link> <span class=md-ellipsis> mem_tac_aux </span> </a> </li> <li class=md-nav__item> <a href=#mfld_set_tac class=md-nav__link> <span class=md-ellipsis> mfld_set_tac </span> </a> </li> <li class=md-nav__item> <a href=#mod_cases class=md-nav__link> <span class=md-ellipsis> mod_cases </span> </a> </li> <li class=md-nav__item> <a href=#module class=md-nav__link> <span class=md-ellipsis> module </span> </a> </li> <li class=md-nav__item> <a href=#monicity class=md-nav__link> <span class=md-ellipsis> monicity </span> </a> </li> <li class=md-nav__item> <a href=#monicity_1 class=md-nav__link> <span class=md-ellipsis> monicity! </span> </a> </li> <li class=md-nav__item> <a href=#mono class=md-nav__link> <span class=md-ellipsis> mono </span> </a> </li> <li class=md-nav__item> <a href=#monoidal class=md-nav__link> <span class=md-ellipsis> monoidal </span> </a> </li> <li class=md-nav__item> <a href=#monoidal_coherence class=md-nav__link> <span class=md-ellipsis> monoidal_coherence </span> </a> </li> <li class=md-nav__item> <a href=#monoidal_nf class=md-nav__link> <span class=md-ellipsis> monoidal_nf </span> </a> </li> <li class=md-nav__item> <a href=#monoidal_simps class=md-nav__link> <span class=md-ellipsis> monoidal_simps </span> </a> </li> <li class=md-nav__item> <a href=#move_add class=md-nav__link> <span class=md-ellipsis> move_add </span> </a> </li> <li class=md-nav__item> <a href=#move_mul class=md-nav__link> <span class=md-ellipsis> move_mul </span> </a> </li> <li class=md-nav__item> <a href=#move_oper class=md-nav__link> <span class=md-ellipsis> move_oper </span> </a> </li> <li class=md-nav__item> <a href=#mv_bisim class=md-nav__link> <span class=md-ellipsis> mv_bisim </span> </a> </li> <li class=md-nav__item> <a href=#native_decide class=md-nav__link> <span class=md-ellipsis> native_decide </span> </a> </li> <li class=md-nav__item> <a href=#next class=md-nav__link> <span class=md-ellipsis> next </span> </a> </li> <li class=md-nav__item> <a href=#nlinarith class=md-nav__link> <span class=md-ellipsis> nlinarith </span> </a> </li> <li class=md-nav__item> <a href=#nlinarith_1 class=md-nav__link> <span class=md-ellipsis> nlinarith! </span> </a> </li> <li class=md-nav__item> <a href=#nofun class=md-nav__link> <span class=md-ellipsis> nofun </span> </a> </li> <li class=md-nav__item> <a href=#nomatch class=md-nav__link> <span class=md-ellipsis> nomatch </span> </a> </li> <li class=md-nav__item> <a href=#noncomm_ring class=md-nav__link> <span class=md-ellipsis> noncomm_ring </span> </a> </li> <li class=md-nav__item> <a href=#nontriviality class=md-nav__link> <span class=md-ellipsis> nontriviality </span> </a> </li> <li class=md-nav__item> <a href=#norm_cast class=md-nav__link> <span class=md-ellipsis> norm_cast </span> </a> </li> <li class=md-nav__item> <a href=#norm_num class=md-nav__link> <span class=md-ellipsis> norm_num </span> </a> </li> <li class=md-nav__item> <a href=#norm_num1 class=md-nav__link> <span class=md-ellipsis> norm_num1 </span> </a> </li> <li class=md-nav__item> <a href=#nth_rewrite class=md-nav__link> <span class=md-ellipsis> nth_rewrite </span> </a> </li> <li class=md-nav__item> <a href=#nth_rw class=md-nav__link> <span class=md-ellipsis> nth_rw </span> </a> </li> <li class=md-nav__item> <a href=#observe class=md-nav__link> <span class=md-ellipsis> observe </span> </a> </li> <li class=md-nav__item> <a href=#observe_1 class=md-nav__link> <span class=md-ellipsis> observe? </span> </a> </li> <li class=md-nav__item> <a href=#observe_2 class=md-nav__link> <span class=md-ellipsis> observe? </span> </a> </li> <li class=md-nav__item> <a href=#obtain class=md-nav__link> <span class=md-ellipsis> obtain </span> </a> </li> <li class=md-nav__item> <a href=#omega class=md-nav__link> <span class=md-ellipsis> omega </span> </a> </li> <li class=md-nav__item> <a href=#on_goal class=md-nav__link> <span class=md-ellipsis> on_goal </span> </a> </li> <li class=md-nav__item> <a href=#open class=md-nav__link> <span class=md-ellipsis> open </span> </a> </li> <li class=md-nav__item> <a href=#order class=md-nav__link> <span class=md-ellipsis> order </span> </a> </li> <li class=md-nav__item> <a href=#peel class=md-nav__link> <span class=md-ellipsis> peel </span> </a> </li> <li class=md-nav__item> <a href=#pgame_wf_tac class=md-nav__link> <span class=md-ellipsis> pgame_wf_tac </span> </a> </li> <li class=md-nav__item> <a href=#pi_lower_bound class=md-nav__link> <span class=md-ellipsis> pi_lower_bound </span> </a> </li> <li class=md-nav__item> <a href=#pi_upper_bound class=md-nav__link> <span class=md-ellipsis> pi_upper_bound </span> </a> </li> <li class=md-nav__item> <a href=#pick_goal class=md-nav__link> <span class=md-ellipsis> pick_goal </span> </a> </li> <li class=md-nav__item> <a href=#plausible class=md-nav__link> <span class=md-ellipsis> plausible </span> </a> </li> <li class=md-nav__item> <a href=#pnat_positivity class=md-nav__link> <span class=md-ellipsis> pnat_positivity </span> </a> </li> <li class=md-nav__item> <a href=#pnat_to_nat class=md-nav__link> <span class=md-ellipsis> pnat_to_nat </span> </a> </li> <li class=md-nav__item> <a href=#polyrith class=md-nav__link> <span class=md-ellipsis> polyrith </span> </a> </li> <li class=md-nav__item> <a href=#pure_coherence class=md-nav__link> <span class=md-ellipsis> pure_coherence </span> </a> </li> <li class=md-nav__item> <a href=#push_cast class=md-nav__link> <span class=md-ellipsis> push_cast </span> </a> </li> <li class=md-nav__item> <a href=#push_neg class=md-nav__link> <span class=md-ellipsis> push_neg </span> </a> </li> <li class=md-nav__item> <a href=#qify class=md-nav__link> <span class=md-ellipsis> qify </span> </a> </li> <li class=md-nav__item> <a href=#rcases class=md-nav__link> <span class=md-ellipsis> rcases </span> </a> </li> <li class=md-nav__item> <a href=#rcongr class=md-nav__link> <span class=md-ellipsis> rcongr </span> </a> </li> <li class=md-nav__item> <a href=#recover class=md-nav__link> <span class=md-ellipsis> recover </span> </a> </li> <li class=md-nav__item> <a href=#reduce class=md-nav__link> <span class=md-ellipsis> reduce </span> </a> </li> <li class=md-nav__item> <a href=#reduce_mod_char class=md-nav__link> <span class=md-ellipsis> reduce_mod_char </span> </a> </li> <li class=md-nav__item> <a href=#reduce_mod_char_1 class=md-nav__link> <span class=md-ellipsis> reduce_mod_char! </span> </a> </li> <li class=md-nav__item> <a href=#refine class=md-nav__link> <span class=md-ellipsis> refine </span> </a> </li> <li class=md-nav__item> <a href=#refine_1 class=md-nav__link> <span class=md-ellipsis> refine' </span> </a> </li> <li class=md-nav__item> <a href=#refine_lift class=md-nav__link> <span class=md-ellipsis> refine_lift </span> </a> </li> <li class=md-nav__item> <a href=#refine_lift_1 class=md-nav__link> <span class=md-ellipsis> refine_lift' </span> </a> </li> <li class=md-nav__item> <a href=#refold_let class=md-nav__link> <span class=md-ellipsis> refold_let </span> </a> </li> <li class=md-nav__item> <a href=#rel class=md-nav__link> <span class=md-ellipsis> rel </span> </a> </li> <li class=md-nav__item> <a href=#rename class=md-nav__link> <span class=md-ellipsis> rename </span> </a> </li> <li class=md-nav__item> <a href=#rename_1 class=md-nav__link> <span class=md-ellipsis> rename' </span> </a> </li> <li class=md-nav__item> <a href=#rename_bvar class=md-nav__link> <span class=md-ellipsis> rename_bvar </span> </a> </li> <li class=md-nav__item> <a href=#rename_i class=md-nav__link> <span class=md-ellipsis> rename_i </span> </a> </li> <li class=md-nav__item> <a href=#repeat class=md-nav__link> <span class=md-ellipsis> repeat </span> </a> </li> <li class=md-nav__item> <a href=#repeat_1 class=md-nav__link> <span class=md-ellipsis> repeat' </span> </a> </li> <li class=md-nav__item> <a href=#repeat1 class=md-nav__link> <span class=md-ellipsis> repeat1 </span> </a> </li> <li class=md-nav__item> <a href=#repeat1_1 class=md-nav__link> <span class=md-ellipsis> repeat1' </span> </a> </li> <li class=md-nav__item> <a href=#replace class=md-nav__link> <span class=md-ellipsis> replace </span> </a> </li> <li class=md-nav__item> <a href=#replace_1 class=md-nav__link> <span class=md-ellipsis> replace </span> </a> </li> <li class=md-nav__item> <a href=#restrict_tac class=md-nav__link> <span class=md-ellipsis> restrict_tac </span> </a> </li> <li class=md-nav__item> <a href=#restrict_tac_1 class=md-nav__link> <span class=md-ellipsis> restrict_tac? </span> </a> </li> <li class=md-nav__item> <a href=#revert class=md-nav__link> <span class=md-ellipsis> revert </span> </a> </li> <li class=md-nav__item> <a href=#rewrite class=md-nav__link> <span class=md-ellipsis> rewrite </span> </a> </li> <li class=md-nav__item> <a href=#rfl class=md-nav__link> <span class=md-ellipsis> rfl </span> </a> </li> <li class=md-nav__item> <a href=#rfl_1 class=md-nav__link> <span class=md-ellipsis> rfl' </span> </a> </li> <li class=md-nav__item> <a href=#rify class=md-nav__link> <span class=md-ellipsis> rify </span> </a> </li> <li class=md-nav__item> <a href=#right class=md-nav__link> <span class=md-ellipsis> right </span> </a> </li> <li class=md-nav__item> <a href=#ring class=md-nav__link> <span class=md-ellipsis> ring </span> </a> </li> <li class=md-nav__item> <a href=#ring_1 class=md-nav__link> <span class=md-ellipsis> ring! </span> </a> </li> <li class=md-nav__item> <a href=#ring1 class=md-nav__link> <span class=md-ellipsis> ring1 </span> </a> </li> <li class=md-nav__item> <a href=#ring1_1 class=md-nav__link> <span class=md-ellipsis> ring1! </span> </a> </li> <li class=md-nav__item> <a href=#ring1_nf class=md-nav__link> <span class=md-ellipsis> ring1_nf </span> </a> </li> <li class=md-nav__item> <a href=#ring1_nf_1 class=md-nav__link> <span class=md-ellipsis> ring1_nf! </span> </a> </li> <li class=md-nav__item> <a href=#ring_nf class=md-nav__link> <span class=md-ellipsis> ring_nf </span> </a> </li> <li class=md-nav__item> <a href=#ring_nf_1 class=md-nav__link> <span class=md-ellipsis> ring_nf! </span> </a> </li> <li class=md-nav__item> <a href=#rintro class=md-nav__link> <span class=md-ellipsis> rintro </span> </a> </li> <li class=md-nav__item> <a href=#rotate_left class=md-nav__link> <span class=md-ellipsis> rotate_left </span> </a> </li> <li class=md-nav__item> <a href=#rotate_right class=md-nav__link> <span class=md-ellipsis> rotate_right </span> </a> </li> <li class=md-nav__item> <a href=#rsuffices class=md-nav__link> <span class=md-ellipsis> rsuffices </span> </a> </li> <li class=md-nav__item> <a href=#run_tac class=md-nav__link> <span class=md-ellipsis> run_tac </span> </a> </li> <li class=md-nav__item> <a href=#rw class=md-nav__link> <span class=md-ellipsis> rw </span> </a> </li> <li class=md-nav__item> <a href=#rw_1 class=md-nav__link> <span class=md-ellipsis> rw? </span> </a> </li> <li class=md-nav__item> <a href=#rw_mod_cast class=md-nav__link> <span class=md-ellipsis> rw_mod_cast </span> </a> </li> <li class=md-nav__item> <a href=#rw_search class=md-nav__link> <span class=md-ellipsis> rw_search </span> </a> </li> <li class=md-nav__item> <a href=#rwa class=md-nav__link> <span class=md-ellipsis> rwa </span> </a> </li> <li class=md-nav__item> <a href=#saturate class=md-nav__link> <span class=md-ellipsis> saturate </span> </a> </li> <li class=md-nav__item> <a href=#saturate_1 class=md-nav__link> <span class=md-ellipsis> saturate? </span> </a> </li> <li class=md-nav__item> <a href=#says class=md-nav__link> <span class=md-ellipsis> says </span> </a> </li> <li class=md-nav__item> <a href=#set class=md-nav__link> <span class=md-ellipsis> set </span> </a> </li> <li class=md-nav__item> <a href=#set_1 class=md-nav__link> <span class=md-ellipsis> set! </span> </a> </li> <li class=md-nav__item> <a href=#set_option class=md-nav__link> <span class=md-ellipsis> set_option </span> </a> </li> <li class=md-nav__item> <a href=#show class=md-nav__link> <span class=md-ellipsis> show </span> </a> </li> <li class=md-nav__item> <a href=#show_term class=md-nav__link> <span class=md-ellipsis> show_term </span> </a> </li> <li class=md-nav__item> <a href=#simp class=md-nav__link> <span class=md-ellipsis> simp </span> </a> </li> <li class=md-nav__item> <a href=#simp_1 class=md-nav__link> <span class=md-ellipsis> simp! </span> </a> </li> <li class=md-nav__item> <a href=#simp_2 class=md-nav__link> <span class=md-ellipsis> simp? </span> </a> </li> <li class=md-nav__item> <a href=#simp_3 class=md-nav__link> <span class=md-ellipsis> simp?! </span> </a> </li> <li class=md-nav__item> <a href=#simp_all class=md-nav__link> <span class=md-ellipsis> simp_all </span> </a> </li> <li class=md-nav__item> <a href=#simp_all_1 class=md-nav__link> <span class=md-ellipsis> simp_all! </span> </a> </li> <li class=md-nav__item> <a href=#simp_all_2 class=md-nav__link> <span class=md-ellipsis> simp_all? </span> </a> </li> <li class=md-nav__item> <a href=#simp_all_3 class=md-nav__link> <span class=md-ellipsis> simp_all?! </span> </a> </li> <li class=md-nav__item> <a href=#simp_all_arith class=md-nav__link> <span class=md-ellipsis> simp_all_arith </span> </a> </li> <li class=md-nav__item> <a href=#simp_all_arith_1 class=md-nav__link> <span class=md-ellipsis> simp_all_arith! </span> </a> </li> <li class=md-nav__item> <a href=#simp_arith class=md-nav__link> <span class=md-ellipsis> simp_arith </span> </a> </li> <li class=md-nav__item> <a href=#simp_arith_1 class=md-nav__link> <span class=md-ellipsis> simp_arith! </span> </a> </li> <li class=md-nav__item> <a href=#simp_intro class=md-nav__link> <span class=md-ellipsis> simp_intro </span> </a> </li> <li class=md-nav__item> <a href=#simp_rw class=md-nav__link> <span class=md-ellipsis> simp_rw </span> </a> </li> <li class=md-nav__item> <a href=#simp_wf class=md-nav__link> <span class=md-ellipsis> simp_wf </span> </a> </li> <li class=md-nav__item> <a href=#simpa class=md-nav__link> <span class=md-ellipsis> simpa </span> </a> </li> <li class=md-nav__item> <a href=#simpa_1 class=md-nav__link> <span class=md-ellipsis> simpa! </span> </a> </li> <li class=md-nav__item> <a href=#simpa_2 class=md-nav__link> <span class=md-ellipsis> simpa? </span> </a> </li> <li class=md-nav__item> <a href=#simpa_3 class=md-nav__link> <span class=md-ellipsis> simpa?! </span> </a> </li> <li class=md-nav__item> <a href=#sizeof_list_dec class=md-nav__link> <span class=md-ellipsis> sizeOf_list_dec </span> </a> </li> <li class=md-nav__item> <a href=#skip class=md-nav__link> <span class=md-ellipsis> skip </span> </a> </li> <li class=md-nav__item> <a href=#sleep class=md-nav__link> <span class=md-ellipsis> sleep </span> </a> </li> <li class=md-nav__item> <a href=#sleep_heartbeats class=md-nav__link> <span class=md-ellipsis> sleep_heartbeats </span> </a> </li> <li class=md-nav__item> <a href=#slice_lhs class=md-nav__link> <span class=md-ellipsis> slice_lhs </span> </a> </li> <li class=md-nav__item> <a href=#slice_rhs class=md-nav__link> <span class=md-ellipsis> slice_rhs </span> </a> </li> <li class=md-nav__item> <a href=#smul_tac class=md-nav__link> <span class=md-ellipsis> smul_tac </span> </a> </li> <li class=md-nav__item> <a href=#solve class=md-nav__link> <span class=md-ellipsis> solve </span> </a> </li> <li class=md-nav__item> <a href=#solve_by_elim class=md-nav__link> <span class=md-ellipsis> solve_by_elim </span> </a> </li> <li class=md-nav__item> <a href=#sorry class=md-nav__link> <span class=md-ellipsis> sorry </span> </a> </li> <li class=md-nav__item> <a href=#sorry_if_sorry class=md-nav__link> <span class=md-ellipsis> sorry_if_sorry </span> </a> </li> <li class=md-nav__item> <a href=#specialize class=md-nav__link> <span class=md-ellipsis> specialize </span> </a> </li> <li class=md-nav__item> <a href=#specialize_all class=md-nav__link> <span class=md-ellipsis> specialize_all </span> </a> </li> <li class=md-nav__item> <a href=#split class=md-nav__link> <span class=md-ellipsis> split </span> </a> </li> <li class=md-nav__item> <a href=#split_ands class=md-nav__link> <span class=md-ellipsis> split_ands </span> </a> </li> <li class=md-nav__item> <a href=#split_ifs class=md-nav__link> <span class=md-ellipsis> split_ifs </span> </a> </li> <li class=md-nav__item> <a href=#squeeze_scope class=md-nav__link> <span class=md-ellipsis> squeeze_scope </span> </a> </li> <li class=md-nav__item> <a href=#stop class=md-nav__link> <span class=md-ellipsis> stop </span> </a> </li> <li class=md-nav__item> <a href=#subsingleton class=md-nav__link> <span class=md-ellipsis> subsingleton </span> </a> <nav class=md-nav aria-label=subsingleton> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_12 class=md-nav__link> <span class=md-ellipsis> 特性 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#subst class=md-nav__link> <span class=md-ellipsis> subst </span> </a> </li> <li class=md-nav__item> <a href=#subst_eqs class=md-nav__link> <span class=md-ellipsis> subst_eqs </span> </a> </li> <li class=md-nav__item> <a href=#subst_hom_lift class=md-nav__link> <span class=md-ellipsis> subst_hom_lift </span> </a> </li> <li class=md-nav__item> <a href=#subst_vars class=md-nav__link> <span class=md-ellipsis> subst_vars </span> </a> </li> <li class=md-nav__item> <a href=#substs class=md-nav__link> <span class=md-ellipsis> substs </span> </a> </li> <li class=md-nav__item> <a href=#success_if_fail_with_msg class=md-nav__link> <span class=md-ellipsis> success_if_fail_with_msg </span> </a> </li> <li class=md-nav__item> <a href=#suffices class=md-nav__link> <span class=md-ellipsis> suffices </span> </a> </li> <li class=md-nav__item> <a href=#suffices_1 class=md-nav__link> <span class=md-ellipsis> suffices </span> </a> </li> <li class=md-nav__item> <a href=#suggest_premises class=md-nav__link> <span class=md-ellipsis> suggest_premises </span> </a> </li> <li class=md-nav__item> <a href=#swap class=md-nav__link> <span class=md-ellipsis> swap </span> </a> </li> <li class=md-nav__item> <a href=#swap_var class=md-nav__link> <span class=md-ellipsis> swap_var </span> </a> </li> <li class=md-nav__item> <a href=#symm class=md-nav__link> <span class=md-ellipsis> symm </span> </a> </li> <li class=md-nav__item> <a href=#symm_saturate class=md-nav__link> <span class=md-ellipsis> symm_saturate </span> </a> </li> <li class=md-nav__item> <a href=#tauto class=md-nav__link> <span class=md-ellipsis> tauto </span> </a> </li> <li class=md-nav__item> <a href=#tauto_set class=md-nav__link> <span class=md-ellipsis> tauto_set </span> </a> </li> <li class=md-nav__item> <a href=#tfae_finish class=md-nav__link> <span class=md-ellipsis> tfae_finish </span> </a> </li> <li class=md-nav__item> <a href=#tfae_have class=md-nav__link> <span class=md-ellipsis> tfae_have </span> </a> </li> <li class=md-nav__item> <a href=#tfae_have_1 class=md-nav__link> <span class=md-ellipsis> tfae_have </span> </a> </li> <li class=md-nav__item> <a href=#tofinite_tac class=md-nav__link> <span class=md-ellipsis> toFinite_tac </span> </a> </li> <li class=md-nav__item> <a href=#to_encard_tac class=md-nav__link> <span class=md-ellipsis> to_encard_tac </span> </a> </li> <li class=md-nav__item> <a href=#trace class=md-nav__link> <span class=md-ellipsis> trace </span> </a> </li> <li class=md-nav__item> <a href=#trace_1 class=md-nav__link> <span class=md-ellipsis> trace </span> </a> </li> <li class=md-nav__item> <a href=#trace_state class=md-nav__link> <span class=md-ellipsis> trace_state </span> </a> </li> <li class=md-nav__item> <a href=#trans class=md-nav__link> <span class=md-ellipsis> trans </span> </a> </li> <li class=md-nav__item> <a href=#transitivity class=md-nav__link> <span class=md-ellipsis> transitivity </span> </a> </li> <li class=md-nav__item> <a href=#triv class=md-nav__link> <span class=md-ellipsis> triv </span> </a> </li> <li class=md-nav__item> <a href=#trivial class=md-nav__link> <span class=md-ellipsis> trivial </span> </a> </li> <li class=md-nav__item> <a href=#try class=md-nav__link> <span class=md-ellipsis> try </span> </a> </li> <li class=md-nav__item> <a href=#try_1 class=md-nav__link> <span class=md-ellipsis> try? </span> </a> </li> <li class=md-nav__item> <a href=#try_suggestions class=md-nav__link> <span class=md-ellipsis> try_suggestions </span> </a> </li> <li class=md-nav__item> <a href=#try_this class=md-nav__link> <span class=md-ellipsis> try_this </span> </a> </li> <li class=md-nav__item> <a href=#type_check class=md-nav__link> <span class=md-ellipsis> type_check </span> </a> </li> <li class=md-nav__item> <a href=#unfold class=md-nav__link> <span class=md-ellipsis> unfold </span> </a> </li> <li class=md-nav__item> <a href=#unfold_1 class=md-nav__link> <span class=md-ellipsis> unfold? </span> </a> </li> <li class=md-nav__item> <a href=#unfold_let class=md-nav__link> <span class=md-ellipsis> unfold_let </span> </a> </li> <li class=md-nav__item> <a href=#unfold_projs class=md-nav__link> <span class=md-ellipsis> unfold_projs </span> </a> </li> <li class=md-nav__item> <a href=#unhygienic class=md-nav__link> <span class=md-ellipsis> unhygienic </span> </a> </li> <li class=md-nav__item> <a href=#uniquediffwithinat_ici_iic_univ class=md-nav__link> <span class=md-ellipsis> uniqueDiffWithinAt_Ici_Iic_univ </span> </a> </li> <li class=md-nav__item> <a href=#unit_interval class=md-nav__link> <span class=md-ellipsis> unit_interval </span> </a> </li> <li class=md-nav__item> <a href=#unreachable class=md-nav__link> <span class=md-ellipsis> unreachable! </span> </a> </li> <li class=md-nav__item> <a href=#use class=md-nav__link> <span class=md-ellipsis> use </span> </a> </li> <li class=md-nav__item> <a href=#use_1 class=md-nav__link> <span class=md-ellipsis> use! </span> </a> </li> <li class=md-nav__item> <a href=#use_discharger class=md-nav__link> <span class=md-ellipsis> use_discharger </span> </a> </li> <li class=md-nav__item> <a href=#use_finite_instance class=md-nav__link> <span class=md-ellipsis> use_finite_instance </span> </a> </li> <li class=md-nav__item> <a href=#valid class=md-nav__link> <span class=md-ellipsis> valid </span> </a> </li> <li class=md-nav__item> <a href=#volume_tac class=md-nav__link> <span class=md-ellipsis> volume_tac </span> </a> </li> <li class=md-nav__item> <a href=#wait_for_unblock_async class=md-nav__link> <span class=md-ellipsis> wait_for_unblock_async </span> </a> </li> <li class=md-nav__item> <a href=#whisker_simps class=md-nav__link> <span class=md-ellipsis> whisker_simps </span> </a> </li> <li class=md-nav__item> <a href=#whnf class=md-nav__link> <span class=md-ellipsis> whnf </span> </a> </li> <li class=md-nav__item> <a href=#with_panel_widgets class=md-nav__link> <span class=md-ellipsis> with_panel_widgets </span> </a> </li> <li class=md-nav__item> <a href=#with_reducible class=md-nav__link> <span class=md-ellipsis> with_reducible </span> </a> </li> <li class=md-nav__item> <a href=#with_reducible_and_instances class=md-nav__link> <span class=md-ellipsis> with_reducible_and_instances </span> </a> </li> <li class=md-nav__item> <a href=#with_unfolding_all class=md-nav__link> <span class=md-ellipsis> with_unfolding_all </span> </a> </li> <li class=md-nav__item> <a href=#witt_truncatefun_tac class=md-nav__link> <span class=md-ellipsis> witt_truncateFun_tac </span> </a> </li> <li class=md-nav__item> <a href=#wlog class=md-nav__link> <span class=md-ellipsis> wlog </span> </a> </li> <li class=md-nav__item> <a href=#zify class=md-nav__link> <span class=md-ellipsis> zify </span> </a> </li> </ul> </nav> </div> </div> </div> <div class=md-content data-md-component=content> <article class="md-content__inner md-typeset"> <h1 id=_1>策略<a class=headerlink href=#_1 title="Permanent link">&para;</a></h1> <p>Mathlib 版本：<code>e4cf8333e0be712392567e370eead57e05d636a7</code></p> <h2 id=adaptation_note>#adaptation_note<a class=headerlink href=#adaptation_note title="Permanent link">&para;</a></h2> <p>定义于：<code>«tactic#adaptation_note_»</code></p> <p>适配注释（Adaptation notes）是用于标记某段代码因 Lean 核心变更而进行调整的注释。通常需要未来进一步的维护操作。</p> <h2 id=check>#check<a class=headerlink href=#check title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.«tactic#check__»</code></p> <p><code>#check t</code> 策略会对项 <code>t</code> 进行详细阐述，随后以 <code>e : ty</code> 的形式美观打印其类型。</p> <p>若 <code>t</code> 为标识符，则改为打印全局常量 <code>t</code> 的类型声明形式。使用 <code>#check (t)</code> 可将其作为详细阐述后的表达式打印。</p> <p>与 <code>#check</code> 命令类似，<code>#check</code> 策略允许存在未解决的类型类实例问题，这些将作为元变量出现在输出中。</p> <h2 id=count_heartbeats>#count_heartbeats<a class=headerlink href=#count_heartbeats title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.CountHeartbeats.«tactic#count_heartbeats_»</code></p> <p>统计策略使用的心拍数，例如：<code>#count_heartbeats simp</code>。</p> <h2 id=count_heartbeats_1>#count_heartbeats!<a class=headerlink href=#count_heartbeats_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.CountHeartbeats.«tactic#count_heartbeats!_In__»</code></p> <p><code>#count_heartbeats! in tac</code> 将运行策略 <code>tac</code> 10 次，统计使用的心拍数，并记录范围和标准差。<code>#count_heartbeats! n in tac</code> 则会运行 <code>n</code> 次。</p> <h2 id=find>#find<a class=headerlink href=#find title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.Find.«tactic#find_»</code></p> <h2 id=leansearch>#leansearch<a class=headerlink href=#leansearch title="Permanent link">&para;</a></h2> <p>定义于：<code>LeanSearchClient.leansearch_search_tactic</code></p> <p>在 Lean 内搜索 <a href=https://leansearch.net/ >LeanSearch</a>。查询应为以 <code>.</code> 或 <code>?</code> 结尾的字符串。可作为命令、项或策略使用。在策略模式下，仅显示有效策略。</p> <div class=highlight><pre><span></span><code><span class=bp>#</span><span class=n>leansearch</span><span class=w> </span><span class=s2>&quot;If a natural number n is less than m, then the successor of n is less than the successor of m.&quot;</span>

<span class=kd>example</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=bp>#</span><span class=n>leansearch</span><span class=w> </span><span class=s2>&quot;If a natural number n is less than m, then the successor of n is less than the successor of m.&quot;</span>
<span class=kd>example</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=mi>3</span><span class=w> </span><span class=bp>≤</span><span class=w> </span><span class=mi>5</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=bp>#</span><span class=n>leansearch</span><span class=w> </span><span class=s2>&quot;If a natural number n is less than m, then the successor of n is less than the successor of m.&quot;</span>
<span class=w>  </span><span class=gr>sorry</span>
</code></pre></div> <h2 id=loogle>#loogle<a class=headerlink href=#loogle title="Permanent link">&para;</a></h2> <p>定义于：<code>LeanSearchClient.loogle_tactic</code></p> <p>在 Lean 内搜索 <a href=https://loogle.lean-lang.org/json>Loogle</a>。可作为命令、项或策略使用。在策略模式下，仅显示有效策略。</p> <div class=highlight><pre><span></span><code><span class=bp>#</span><span class=n>loogle</span><span class=w> </span><span class=n>List</span><span class=w> </span><span class=bp>?</span><span class=n>a</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=bp>?</span><span class=n>a</span>

<span class=kd>example</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=bp>#</span><span class=n>loogle</span><span class=w> </span><span class=n>List</span><span class=w> </span><span class=bp>?</span><span class=n>a</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=bp>?</span><span class=n>a</span>

<span class=kd>example</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=mi>3</span><span class=w> </span><span class=bp>≤</span><span class=w> </span><span class=mi>5</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=bp>#</span><span class=n>loogle</span><span class=w> </span><span class=n>Nat.succ_le_succ</span>
<span class=w>  </span><span class=gr>sorry</span>
</code></pre></div> <h3 id=loogle_1>Loogle 使用指南<a class=headerlink href=#loogle_1 title="Permanent link">&para;</a></h3> <p>Loogle 通过多种方式查找定义和引理：</p> <p>按常量： 🔍 Real.sin 查找所有陈述中提及正弦函数的引理。</p> <p>按引理名称子串： 🔍 "differ" 查找所有名称中包含 "differ" 的引理。</p> <p>按子表达式： 🔍 _ * (_ ^ _) 查找所有陈述中包含乘积且第二个参数为某次幂的引理。</p> <p>模式可非线性，如： 🔍 Real.sqrt ?a * Real.sqrt ?a</p> <p>若模式含参数，将以任意顺序匹配。以下两者均能找到 List.map： 🔍 (?a -&gt; ?b) -&gt; List ?a -&gt; List ?b 🔍 List ?a -&gt; (?a -&gt; ?b) -&gt; List ?b</p> <p>按主要结论： 🔍 |- tsum _ = _ * tsum _ 查找所有结论（所有 → 和 ∀ 右侧的子表达式）具有给定形状的引理。</p> <p>如前所述，若模式含参数，将按任意顺序匹配引理的假设。例如： 🔍 |- _ &lt; _ → tsum _ &lt; tsum _ 将找到 tsum_lt_tsum，尽管假设 f i &lt; g i 并非最后。</p> <p>若传递多个搜索过滤器（以逗号分隔），Loogle 将返回匹配所有过滤器的引理。例如： 🔍 Real.sin, "two", tsum, _ * _, _ ^ _, |- _ &lt; _ → _ 将查找提及常量 Real.sin 和 tsum、引理名包含 "two"、类型中某处含乘积和幂、且具有 _ &lt; _ 形式假设的引理（若有）。元变量（?a）在各过滤器中独立分配。</p> <h2 id=loogle_2>#loogle<a class=headerlink href=#loogle_2 title="Permanent link">&para;</a></h2> <p>定义于：<code>LeanSearchClient.just_loogle_tactic</code></p> <h2 id=moogle>#moogle<a class=headerlink href=#moogle title="Permanent link">&para;</a></h2> <p>定义于：<code>LeanSearchClient.moogle_search_tactic</code></p> <p>在 Lean 内搜索 <a href=https://www.moogle.ai/api/search>Moogle</a>。查询应为以 <code>.</code> 或 <code>?</code> 结尾的字符串。可作为命令、项或策略使用。在策略模式下，仅显示有效策略。</p> <div class=highlight><pre><span></span><code><span class=bp>#</span><span class=n>moogle</span><span class=w> </span><span class=s2>&quot;If a natural number n is less than m, then the successor of n is less than the successor of m.&quot;</span>

<span class=kd>example</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=bp>#</span><span class=n>moogle</span><span class=w> </span><span class=s2>&quot;If a natural number n is less than m, then the successor of n is less than the successor of m.&quot;</span>

<span class=kd>example</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=mi>3</span><span class=w> </span><span class=bp>≤</span><span class=w> </span><span class=mi>5</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=bp>#</span><span class=n>moogle</span><span class=w> </span><span class=s2>&quot;If a natural number n is less than m, then the successor of n is less than the successor of m.&quot;</span>
<span class=w>  </span><span class=gr>sorry</span>
</code></pre></div> <h2 id=search>#search<a class=headerlink href=#search title="Permanent link">&para;</a></h2> <p>定义于：<code>LeanSearchClient.search_tactic</code></p> <p>根据选项 <code>leansearchclient.backend</code>，在 Lean 内搜索 <a href=https://www.moogle.ai/api/search>Moogle</a> 或 <a href=https://leansearch.net/ >LeanSearch</a>。查询应为以 <code>.</code> 或 <code>?</code> 结尾的字符串。可作为命令、项或策略使用。在策略模式下，仅显示有效策略。</p> <div class=highlight><pre><span></span><code><span class=bp>#</span><span class=n>search</span><span class=w> </span><span class=s2>&quot;If a natural number n is less than m, then the successor of n is less than the successor of m.&quot;</span>

<span class=kd>example</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=bp>#</span><span class=n>search</span><span class=w> </span><span class=s2>&quot;If a natural number n is less than m, then the successor of n is less than the successor of m.&quot;</span>

<span class=kd>example</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=mi>3</span><span class=w> </span><span class=bp>≤</span><span class=w> </span><span class=mi>5</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=bp>#</span><span class=n>search</span><span class=w> </span><span class=s2>&quot;If a natural number n is less than m, then the successor of n is less than the successor of m.&quot;</span>
<span class=w>  </span><span class=gr>sorry</span>
</code></pre></div> <p>在策略模式下，若未提供查询字符串，则基于当前目标状态查询 <a href=https://premise-search.com>LeanStateSearch</a>。</p> <h2 id=statesearch>#statesearch<a class=headerlink href=#statesearch title="Permanent link">&para;</a></h2> <p>定义于：<code>LeanSearchClient.statesearch_search_tactic</code></p> <p>在 Lean 内搜索 <a href=https://premise-search.com>LeanStateSearch</a>。当前主目标将作为查询发送。可通过 <code>statesearch.revision</code> 选项设置搜索版本，通过 <code>statesearch.queries</code> 选项设置结果数量。</p> <p>提示：若需修改查询，需使用网页界面。</p> <div class=highlight><pre><span></span><code><span class=kd>set_option</span><span class=w> </span><span class=n>statesearch.queries</span><span class=w> </span><span class=mi>1</span>
<span class=kd>set_option</span><span class=w> </span><span class=n>statesearch.revision</span><span class=w> </span><span class=s2>&quot;v4.16.0&quot;</span>

<span class=kd>example</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=bp>≤</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=bp>#</span><span class=n>statesearch</span>
<span class=w>  </span><span class=gr>sorry</span>
</code></pre></div> <h2 id=_2>(<a class=headerlink href=#_2 title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.paren</code></p> <p><code>(tacs)</code> 依次执行一系列策略，无需像 <code>· tacs</code> 那样在最后关闭目标。类似 <code>by</code> 本身，策略可通过换行或 <code>;</code> 分隔。</p> <h2 id=_3>&lt;;&gt;<a class=headerlink href=#_3 title="Permanent link">&para;</a></h2> <p>定义于：<code>Batteries.Tactic.seq_focus</code></p> <p><code>t &lt;;&gt; [t1; t2; ...; tn]</code> 聚焦于首个目标并应用 <code>t</code>，应生成 <code>n</code> 个子目标。随后对每个目标应用对应的 <code>ti</code> 并收集生成的子目标。</p> <h2 id=_4>&lt;;&gt;<a class=headerlink href=#_4 title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.«tactic_&lt;;&gt;_»</code></p> <p><code>tac &lt;;&gt; tac'</code> 在主目标上运行 <code>tac</code>，随后在每个生成的目标上运行 <code>tac'</code>，合并所有 <code>tac'</code> 生成的子目标。</p> <h2 id=_>_<a class=headerlink href=#_ title="Permanent link">&para;</a></h2> <p>定义于：<code>Batteries.Tactic.tactic_</code></p> <p>策略位置的 <code>_</code> 类似 <code>done</code> 策略：若存在任何目标则失败并列出目标列表。在开始策略块（如 <code>by _</code>）后作为占位符使用，可保证语法正确并显示当前目标。</p> <h2 id=abel>abel<a class=headerlink href=#abel title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.Abel.abel</code></p> <p>用于在*加法*交换幺半群和群的语言中评估方程的策略。</p> <p><code>abel</code> 及其变体既可作为策略，也可作为转换策略使用。</p> <ul> <li><code>abel1</code> 若目标非由交换幺半群/群公理可证的等式，则失败。</li> <li><code>abel_nf</code> 将所有群表达式重写为规范形式。</li> <li>在策略模式下，<code>abel_nf at h</code> 可用于在假设中重写。</li> <li><code>abel_nf (config := cfg)</code> 允许额外配置：<ul> <li><code>red</code>: 可约性设置（被 <code>!</code> 覆盖）</li> <li><code>zetaDelta</code>: 若为真，可展开局部 let 变量（被 <code>!</code> 覆盖）</li> <li><code>recursive</code>: 若为真，<code>abel_nf</code> 将递归处理原子</li> </ul> </li> <li><code>abel!</code>, <code>abel1!</code>, <code>abel_nf!</code> 将使用更激进的可约性设置识别原子。</li> </ul> <p>例如：</p> <div class=highlight><pre><span></span><code>example [AddCommMonoid α] (a b : α) : a + (b + a) = a + a + b := by abel
example [AddCommGroup α] (a : α) : (3 : ℤ) • a = a + (2 : ℤ) • a := by abel
</code></pre></div> <h3 id=_5>未来工作<a class=headerlink href=#_5 title="Permanent link">&para;</a></h3> <ul> <li>在 mathlib 3 中，<code>abel</code> 接受额外的可选参数： <div class=highlight><pre><span></span><code>syntax &quot;abel&quot; (&amp;&quot; raw&quot; &lt;|&gt; &amp;&quot; term&quot;)? (location)? : tactic
</code></pre></div> 是否应最终恢复这些功能尚未决定。</li> </ul> <h2 id=abel_1>abel!<a class=headerlink href=#abel_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.Abel.tacticAbel!</code></p> <p>用于在*加法*交换幺半群和群的公理体系中验证等式的策略。</p> <p><code>abel</code> 及其变体既可作为普通策略，也可作为转换策略使用。</p> <ul> <li><code>abel1</code> 若目标不是可被交换幺半群/群公理证明的等式，则会失败。</li> <li><code>abel_nf</code> 将所有群表达式重写为标准形式。</li> <li>在策略模式中，<code>abel_nf at h</code> 可用于在假设中重写。</li> <li><code>abel_nf (config := cfg)</code> 允许额外配置：<ul> <li><code>red</code>：可约性设置（被 <code>!</code> 覆盖）</li> <li><code>zetaDelta</code>：若为真，局部 let 变量可展开（被 <code>!</code> 覆盖）</li> <li><code>recursive</code>：若为真，<code>abel_nf</code> 将递归进入原子</li> </ul> </li> <li><code>abel!</code>、<code>abel1!</code>、<code>abel_nf!</code> 将使用更激进的可约性设置来识别原子。</li> </ul> <p>例如：</p> <div class=highlight><pre><span></span><code>example [AddCommMonoid α] (a b : α) : a + (b + a) = a + a + b := by abel
example [AddCommGroup α] (a : α) : (3 : ℤ) • a = a + (2 : ℤ) • a := by abel
</code></pre></div> <h3 id=_6>未来工作<a class=headerlink href=#_6 title="Permanent link">&para;</a></h3> <ul> <li>在 mathlib 3 中，<code>abel</code> 接受额外的可选参数： <div class=highlight><pre><span></span><code>syntax &quot;abel&quot; (&amp;&quot; raw&quot; &lt;|&gt; &amp;&quot; term&quot;)? (location)? : tactic
</code></pre></div> 是否应最终恢复这些功能尚未决定。</li> </ul> <h2 id=abel1>abel1<a class=headerlink href=#abel1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.Abel.abel1</code></p> <p>用于在*加法*交换幺半群和群的公理体系中验证等式的策略。</p> <p><code>abel</code> 及其变体既可作为普通策略，也可作为转换策略使用。</p> <ul> <li><code>abel1</code> 若目标不是可被交换幺半群/群公理证明的等式，则会失败。</li> <li><code>abel_nf</code> 将所有群表达式重写为标准形式。</li> <li>在策略模式中，<code>abel_nf at h</code> 可用于在假设中重写。</li> <li><code>abel_nf (config := cfg)</code> 允许额外配置：<ul> <li><code>red</code>：可约性设置（被 <code>!</code> 覆盖）</li> <li><code>zetaDelta</code>：若为真，局部 let 变量可展开（被 <code>!</code> 覆盖）</li> <li><code>recursive</code>：若为真，<code>abel_nf</code> 将递归进入原子</li> </ul> </li> <li><code>abel!</code>、<code>abel1!</code>、<code>abel_nf!</code> 将使用更激进的可约性设置来识别原子。</li> </ul> <p>例如：</p> <div class=highlight><pre><span></span><code>example [AddCommMonoid α] (a b : α) : a + (b + a) = a + a + b := by abel
example [AddCommGroup α] (a : α) : (3 : ℤ) • a = a + (2 : ℤ) • a := by abel
</code></pre></div> <h3 id=_7>未来工作<a class=headerlink href=#_7 title="Permanent link">&para;</a></h3> <ul> <li>在 mathlib 3 中，<code>abel</code> 接受额外的可选参数： <div class=highlight><pre><span></span><code>syntax &quot;abel&quot; (&amp;&quot; raw&quot; &lt;|&gt; &amp;&quot; term&quot;)? (location)? : tactic
</code></pre></div> 是否应最终恢复这些功能尚未决定。</li> </ul> <h2 id=abel1_1>abel1!<a class=headerlink href=#abel1_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.Abel.abel1!</code></p> <p>用于在*加法*交换幺半群和群的公理体系中验证等式的策略。</p> <p><code>abel</code> 及其变体既可作为普通策略，也可作为转换策略使用。</p> <ul> <li><code>abel1</code> 若目标不是可被交换幺半群/群公理证明的等式，则会失败。</li> <li><code>abel_nf</code> 将所有群表达式重写为标准形式。</li> <li>在策略模式中，<code>abel_nf at h</code> 可用于在假设中重写。</li> <li><code>abel_nf (config := cfg)</code> 允许额外配置：<ul> <li><code>red</code>：可约性设置（被 <code>!</code> 覆盖）</li> <li><code>zetaDelta</code>：若为真，局部 let 变量可展开（被 <code>!</code> 覆盖）</li> <li><code>recursive</code>：若为真，<code>abel_nf</code> 将递归进入原子</li> </ul> </li> <li><code>abel!</code>、<code>abel1!</code>、<code>abel_nf!</code> 将使用更激进的可约性设置来识别原子。</li> </ul> <p>例如：</p> <div class=highlight><pre><span></span><code>example [AddCommMonoid α] (a b : α) : a + (b + a) = a + a + b := by abel
example [AddCommGroup α] (a : α) : (3 : ℤ) • a = a + (2 : ℤ) • a := by abel
</code></pre></div> <h3 id=_8>未来工作<a class=headerlink href=#_8 title="Permanent link">&para;</a></h3> <ul> <li>在 mathlib 3 中，<code>abel</code> 接受额外的可选参数： <div class=highlight><pre><span></span><code>syntax &quot;abel&quot; (&amp;&quot; raw&quot; &lt;|&gt; &amp;&quot; term&quot;)? (location)? : tactic
</code></pre></div> 是否应最终恢复这些功能尚未决定。</li> </ul> <h2 id=abel_nf>abel_nf<a class=headerlink href=#abel_nf title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.Abel.abelNF</code></p> <p>用于在*加法*交换幺半群和群的公理体系中验证等式的策略。</p> <p><code>abel</code> 及其变体既可作为普通策略，也可作为转换策略使用。</p> <ul> <li><code>abel1</code> 若目标不是可被交换幺半群/群公理证明的等式，则会失败。</li> <li><code>abel_nf</code> 将所有群表达式重写为标准形式。</li> <li>在策略模式中，<code>abel_nf at h</code> 可用于在假设中重写。</li> <li><code>abel_nf (config := cfg)</code> 允许额外配置：<ul> <li><code>red</code>：可约性设置（被 <code>!</code> 覆盖）</li> <li><code>zetaDelta</code>：若为真，局部 let 变量可展开（被 <code>!</code> 覆盖）</li> <li><code>recursive</code>：若为真，<code>abel_nf</code> 将递归进入原子</li> </ul> </li> <li><code>abel!</code>、<code>abel1!</code>、<code>abel_nf!</code> 将使用更激进的可约性设置来识别原子。</li> </ul> <p>例如：</p> <div class=highlight><pre><span></span><code>example [AddCommMonoid α] (a b : α) : a + (b + a) = a + a + b := by abel
example [AddCommGroup α] (a : α) : (3 : ℤ) • a = a + (2 : ℤ) • a := by abel
</code></pre></div> <h3 id=_9>未来工作<a class=headerlink href=#_9 title="Permanent link">&para;</a></h3> <ul> <li>在 mathlib 3 中，<code>abel</code> 接受额外的可选参数： <div class=highlight><pre><span></span><code>syntax &quot;abel&quot; (&amp;&quot; raw&quot; &lt;|&gt; &amp;&quot; term&quot;)? (location)? : tactic
</code></pre></div> 是否应最终恢复这些功能尚未决定。</li> </ul> <h2 id=abel_nf_1>abel_nf!<a class=headerlink href=#abel_nf_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.Abel.tacticAbel_nf!__</code></p> <p>用于在*加法*交换幺半群和群的公理体系中验证等式的策略。</p> <p><code>abel</code> 及其变体既可作为普通策略，也可作为转换策略使用。</p> <ul> <li><code>abel1</code> 若目标不是可被交换幺半群/群公理证明的等式，则会失败。</li> <li><code>abel_nf</code> 将所有群表达式重写为标准形式。</li> <li>在策略模式中，<code>abel_nf at h</code> 可用于在假设中重写。</li> <li><code>abel_nf (config := cfg)</code> 允许额外配置：<ul> <li><code>red</code>：可约性设置（被 <code>!</code> 覆盖）</li> <li><code>zetaDelta</code>：若为真，局部 let 变量可展开（被 <code>!</code> 覆盖）</li> <li><code>recursive</code>：若为真，<code>abel_nf</code> 将递归进入原子</li> </ul> </li> <li><code>abel!</code>、<code>abel1!</code>、<code>abel_nf!</code> 将使用更激进的可约性设置来识别原子。</li> </ul> <p>例如：</p> <div class=highlight><pre><span></span><code>example [AddCommMonoid α] (a b : α) : a + (b + a) = a + a + b := by abel
example [AddCommGroup α] (a : α) : (3 : ℤ) • a = a + (2 : ℤ) • a := by abel
</code></pre></div> <h3 id=_10>未来工作<a class=headerlink href=#_10 title="Permanent link">&para;</a></h3> <ul> <li>在 mathlib 3 中，<code>abel</code> 接受额外的可选参数： <div class=highlight><pre><span></span><code>syntax &quot;abel&quot; (&amp;&quot; raw&quot; &lt;|&gt; &amp;&quot; term&quot;)? (location)? : tactic
</code></pre></div> 是否应最终恢复这些功能尚未决定。</li> </ul> <h2 id=absurd>absurd<a class=headerlink href=#absurd title="Permanent link">&para;</a></h2> <p>定义于：<code>Batteries.Tactic.tacticAbsurd_</code></p> <p>给定一个证明 <code>h</code> 证明 <code>p</code>，<code>absurd h</code> 将目标更改为 <code>⊢ ¬ p</code>。若 <code>p</code> 是否定式 <code>¬q</code>，则目标将更改为 <code>⊢ q</code>。</p> <h2 id=ac_change>ac_change<a class=headerlink href=#ac_change title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.acChange</code></p> <p><code>ac_change g using n</code> 是 <code>convert_to g using n</code> 后接 <code>ac_rfl</code>。它对于重新排列/重新结合例如和式很有用： <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=n>d</span><span class=w> </span><span class=n>e</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=n>g</span><span class=w> </span><span class=n>N</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℕ</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>b</span><span class=o>)</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=o>(</span><span class=n>c</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>d</span><span class=o>)</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=o>(</span><span class=n>e</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>f</span><span class=o>)</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>g</span><span class=w> </span><span class=bp>≤</span><span class=w> </span><span class=n>N</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>ac_change</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>d</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>e</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>g</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=bp>≤</span><span class=w> </span><span class=n>_</span>
<span class=w>  </span><span class=c1>-- ⊢ a + d + e + f + c + g + b ≤ N</span>
</code></pre></div></p> <h2 id=ac_nf>ac_nf<a class=headerlink href=#ac_nf title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.tacticAc_nf_</code></p> <p><code>ac_nf</code> 将等式规范化至结合交换运算符的应用。 - <code>ac_nf</code> 规范化所有假设和当前目标的目标。 - <code>ac_nf at l</code> 在位置 <code>l</code> 处规范化，其中 <code>l</code> 是 <code>*</code> 或局部上下文中的假设列表。后者中，可使用转向符 <code>⊢</code> 或 <code>|-</code> 表示当前目标的目标。 <div class=highlight><pre><span></span><code><span class=kd>instance</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Associative</span><span class=w> </span><span class=o>(</span><span class=n>α</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=n>Nat</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=bp>.+.</span><span class=o>)</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=o>⟨</span><span class=n>Nat.add_assoc</span><span class=o>⟩</span>
<span class=kd>instance</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Commutative</span><span class=w> </span><span class=o>(</span><span class=n>α</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=n>Nat</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=bp>.+.</span><span class=o>)</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=o>⟨</span><span class=n>Nat.add_comm</span><span class=o>⟩</span>

<span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=n>d</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Nat</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>d</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>d</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=o>(</span><span class=n>b</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>c</span><span class=o>)</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w> </span><span class=n>ac_nf</span>
<span class=w> </span><span class=c1>-- 目标：a + (b + (c + d)) = a + (b + (c + d))</span>
</code></pre></div></p> <h2 id=ac_nf0>ac_nf0<a class=headerlink href=#ac_nf0 title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.acNf0</code></p> <p><code>ac_nf</code> 的实现（完整的 <code>ac_nf</code> 之后会调用 <code>trivial</code>）。</p> <h2 id=ac_rfl>ac_rfl<a class=headerlink href=#ac_rfl title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.acRfl</code></p> <p><code>ac_rfl</code> 证明等式至结合交换运算符的应用。 <div class=highlight><pre><span></span><code><span class=kd>instance</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Associative</span><span class=w> </span><span class=o>(</span><span class=n>α</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=n>Nat</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=bp>.+.</span><span class=o>)</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=o>⟨</span><span class=n>Nat.add_assoc</span><span class=o>⟩</span>
<span class=kd>instance</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Commutative</span><span class=w> </span><span class=o>(</span><span class=n>α</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=n>Nat</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=bp>.+.</span><span class=o>)</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=o>⟨</span><span class=n>Nat.add_comm</span><span class=o>⟩</span>

<span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=n>d</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Nat</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>d</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>d</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=o>(</span><span class=n>b</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>c</span><span class=o>)</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span><span class=w> </span><span class=n>ac_rfl</span>
</code></pre></div></p> <h2 id=admit>admit<a class=headerlink href=#admit title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.tacticAdmit</code></p> <p><code>admit</code> 是 <code>sorry</code> 的同义词。</p> <h2 id=aesop>aesop<a class=headerlink href=#aesop title="Permanent link">&para;</a></h2> <p>定义于：<code>Aesop.Frontend.Parser.aesopTactic</code></p> <p><code>aesop &lt;clause&gt;*</code> 尝试通过应用一组使用 <code>@[aesop]</code> 属性注册的规则来解决当前目标。参考<a href=https://github.com/JLimperg/aesop#readme>其 README</a>获取教程和参考。</p> <p>变体 <code>aesop?</code> 会打印找到的证明作为 <code>Try this</code> 建议。</p> <p>子句可用于自定义 Aesop 调用的行为。可用的子句包括：</p> <ul> <li><code>(add &lt;phase&gt; &lt;priority&gt; &lt;builder&gt; &lt;rule&gt;)</code> 添加一条规则。<code>&lt;phase&gt;</code> 为 <code>unsafe</code>、<code>safe</code> 或 <code>norm</code>。<code>&lt;priority&gt;</code> 对于不安全规则是百分比，对于安全和规范规则是整数。<code>&lt;rule&gt;</code> 是声明或局部假设的名称。<code>&lt;builder&gt;</code> 是将 <code>&lt;rule&gt;</code> 转换为 Aesop 规则的构建器。例如：<code>(add unsafe 50% apply Or.inl)</code>。</li> <li><code>(erase &lt;rule&gt;)</code> 禁用全局注册的 Aesop 规则。例如：<code>(erase Aesop.BuiltinRules.assumption)</code>。</li> <li><code>(rule_sets := [&lt;ruleset&gt;,*])</code> 为此 Aesop 调用启用或禁用命名的规则集。例如：<code>(rule_sets := [-builtin, MyRuleSet])</code>。</li> <li><code>(config { &lt;opt&gt; := &lt;value&gt; })</code> 调整 Aesop 的搜索选项。参考 <code>Aesop.Options</code>。</li> <li><code>(simp_config { &lt;opt&gt; := &lt;value&gt; })</code> 调整 Aesop 内置 <code>simp</code> 规则的选项。给定的选项直接传递给 <code>simp</code>。例如：<code>(simp_config := { zeta := false })</code> 使 Aesop 使用 <code>simp (config := { zeta := false })</code>。</li> </ul> <h2 id=aesop_1>aesop?<a class=headerlink href=#aesop_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Aesop.Frontend.Parser.aesopTactic?</code></p> <p><code>aesop &lt;clause&gt;*</code> 尝试通过应用一组使用 <code>@[aesop]</code> 属性注册的规则来解决当前目标。参考<a href=https://github.com/JLimperg/aesop#readme>其 README</a>获取教程和参考。</p> <p>变体 <code>aesop?</code> 会打印找到的证明作为 <code>Try this</code> 建议。</p> <p>子句可用于自定义 Aesop 调用的行为。可用的子句包括：</p> <ul> <li><code>(add &lt;phase&gt; &lt;priority&gt; &lt;builder&gt; &lt;rule&gt;)</code> 添加一条规则。<code>&lt;phase&gt;</code> 为 <code>unsafe</code>、<code>safe</code> 或 <code>norm</code>。<code>&lt;priority&gt;</code> 对于不安全规则是百分比，对于安全和规范规则是整数。<code>&lt;rule&gt;</code> 是声明或局部假设的名称。<code>&lt;builder&gt;</code> 是将 <code>&lt;rule&gt;</code> 转换为 Aesop 规则的构建器。例如：<code>(add unsafe 50% apply Or.inl)</code>。</li> <li><code>(erase &lt;rule&gt;)</code> 禁用全局注册的 Aesop 规则。例如：<code>(erase Aesop.BuiltinRules.assumption)</code>。</li> <li><code>(rule_sets := [&lt;ruleset&gt;,*])</code> 为此 Aesop 调用启用或禁用命名的规则集。例如：<code>(rule_sets := [-builtin, MyRuleSet])</code>。</li> <li><code>(config { &lt;opt&gt; := &lt;value&gt; })</code> 调整 Aesop 的搜索选项。参考 <code>Aesop.Options</code>。</li> <li><code>(simp_config { &lt;opt&gt; := &lt;value&gt; })</code> 调整 Aesop 内置 <code>simp</code> 规则的选项。给定的选项直接传递给 <code>simp</code>。例如：<code>(simp_config := { zeta := false })</code> 使 Aesop 使用 <code>simp (config := { zeta := false })</code>。</li> </ul> <h2 id=aesop_cat>aesop_cat<a class=headerlink href=#aesop_cat title="Permanent link">&para;</a></h2> <p>定义于：<code>CategoryTheory.aesop_cat</code></p> <p><code>aesop_cat</code> 是 <code>aesop</code> 的轻量级包装，添加了 <code>CategoryTheory</code> 规则集，并允许 <code>aesop</code> 在调用 <code>intros</code> 时查看半透明定义。当无法解决目标时，此策略会失败，适用于在自动参数中使用。</p> <h2 id=aesop_cat_1>aesop_cat?<a class=headerlink href=#aesop_cat_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>CategoryTheory.aesop_cat?</code></p> <p>我们还使用 <code>aesop_cat?</code> 在使用 <code>aesop_cat</code> 时传递 <code>Try this</code> 建议。</p> <h2 id=aesop_cat_nonterminal>aesop_cat_nonterminal<a class=headerlink href=#aesop_cat_nonterminal title="Permanent link">&para;</a></h2> <p>定义于：<code>CategoryTheory.aesop_cat_nonterminal</code></p> <p><code>aesop_cat_nonterminal</code> 是 <code>aesop_cat</code> 的变体，当无法解决目标时不会失败。仅用于探索！非终止的 <code>aesop</code> 比非终止的 <code>simp</code> 更糟糕。</p> <h2 id=aesop_graph>aesop_graph<a class=headerlink href=#aesop_graph title="Permanent link">&para;</a></h2> <p>定义于：<code>aesop_graph</code></p> <p>用于图库的 <code>aesop</code> 策略变体。相对于标准 <code>aesop</code> 的更改：</p> <ul> <li>除默认规则集外，还使用 <code>SimpleGraph</code> 规则集。</li> <li>指示 Aesop 的 <code>intro</code> 规则使用 <code>default</code> 透明度展开。</li> <li>指示 Aesop 如果无法完全解决目标则失败。这允许我们将 <code>aesop_graph</code> 用于自动参数。</li> </ul> <h2 id=aesop_graph_1>aesop_graph?<a class=headerlink href=#aesop_graph_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>aesop_graph?</code></p> <p>使用 <code>aesop_graph?</code> 在使用 <code>aesop_graph</code> 时传递 <code>Try this</code> 建议。</p> <h2 id=aesop_graph_nonterminal>aesop_graph_nonterminal<a class=headerlink href=#aesop_graph_nonterminal title="Permanent link">&para;</a></h2> <p>定义于：<code>aesop_graph_nonterminal</code></p> <p><code>aesop_graph_nonterminal</code> 是 <code>aesop_graph</code> 的变体，当无法解决目标时不会失败。仅用于探索！非终止的 Aesop 比非终止的 <code>simp</code> 更糟糕。</p> <h2 id=aesop_mat>aesop_mat<a class=headerlink href=#aesop_mat title="Permanent link">&para;</a></h2> <p>定义于：<code>Matroid.aesop_mat</code></p> <p><code>aesop_mat</code> 策略尝试证明一个集合包含在拟阵的基集中。它使用 <code>[Matroid]</code> 规则集，并允许失败。</p> <h2 id=aesop_unfold>aesop_unfold<a class=headerlink href=#aesop_unfold title="Permanent link">&para;</a></h2> <p>定义于：<code>Aesop.tacticAesop_unfold_</code></p> <h2 id=aesop_unfold_1>aesop_unfold<a class=headerlink href=#aesop_unfold_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Aesop.tacticAesop_unfold_At_</code></p> <h2 id=algebraize>algebraize<a class=headerlink href=#algebraize title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.tacticAlgebraize__</code></p> <p>给定 <code>RingHom</code> 时，<code>algebraize</code> 策略会添加相应的 <code>Algebra</code> 实例（如果可能）和 <code>IsScalarTower</code> 实例，以及将 <code>RingHom</code> 属性转换为可用假设的 <code>Algebra</code> 属性。</p> <p>例如：给定 <code>f : A →+* B</code> 和 <code>g : B →+* C</code>，以及 <code>hf : f.FiniteType</code>，<code>algebraize [f, g]</code> 将添加实例 <code>Algebra A B</code>、<code>Algebra B C</code> 和 <code>Algebra.FiniteType A B</code>。</p> <p>参考 <code>algebraize</code> 标签以获取可添加属性的说明。</p> <p>该策略还提供配置选项 <code>properties</code>。若设置为 <code>true</code>（默认），策略会在局部上下文中搜索可转换为 <code>Algebra</code> 属性的 <code>RingHom</code> 属性。宏 <code>algebraize_only</code> 调用 <code>algebraize (config := {properties := false})</code>，即仅添加 <code>Algebra</code> 和 <code>IsScalarTower</code> 实例。</p> <h2 id=algebraize_only>algebraize_only<a class=headerlink href=#algebraize_only title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.tacticAlgebraize_only__</code></p> <p><code>algebraize_only</code> 是 <code>algebraize</code> 的版本，仅添加 <code>Algebra</code> 实例和 <code>IsScalarTower</code> 实例，不尝试添加任何关于带有 <code>@[algebraize]</code> 标签的属性（如 <code>Finite</code> 或 <code>IsIntegral</code>）的实例。</p> <h2 id=all_goals>all_goals<a class=headerlink href=#all_goals title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.allGoals</code></p> <p><code>all_goals tac</code> 在每个目标上运行 <code>tac</code>，合并结果目标。若策略在任何目标上失败，整个 <code>all_goals</code> 策略失败。</p> <p>另见 <code>any_goals tac</code>。</p> <h2 id=and_intros>and_intros<a class=headerlink href=#and_intros title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.tacticAnd_intros</code></p> <p><code>and_intros</code> 应用 <code>And.intro</code> 直到不再有进展。</p> <h2 id=any_goals>any_goals<a class=headerlink href=#any_goals title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.anyGoals</code></p> <p><code>any_goals tac</code> 将策略 <code>tac</code> 应用于每个目标，合并成功应用的结果目标。若策略在所有目标上失败，整个 <code>any_goals</code> 策略失败。</p> <p>此策略类似于 <code>all_goals try tac</code>，但若所有 <code>tac</code> 应用均失败，则失败。</p> <h2 id=apply>apply<a class=headerlink href=#apply title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.tacticApply_At_</code></p> <p><code>apply t at i</code> 将在假设 <code>i</code> 处使用 <code>t</code> 进行前向推理。明确地说，若 <code>t : α₁ → ⋯ → αᵢ → ⋯ → αₙ</code> 且 <code>i</code> 的类型为 <code>αᵢ</code>，则此策略将为 <code>j = 1, …, i-1</code> 的任意 <code>αⱼ</code> 添加元变量/目标，然后通过应用这些元变量和原始 <code>i</code>，将 <code>i</code> 的类型替换为 <code>αᵢ₊₁ → ⋯ → αₙ</code>。</p> <h2 id=apply_1>apply<a class=headerlink href=#apply_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.apply</code></p> <p><code>apply e</code> 尝试将当前目标与 <code>e</code> 类型的结论匹配。若成功，则返回与未被类型推断或类型类解析固定的前提数量相同的子目标。非依赖前提在依赖前提之前添加。</p> <p><code>apply</code> 策略使用高阶模式匹配、类型类解析和依赖类型的一阶统一。</p> <h2 id=apply_2>apply<a class=headerlink href=#apply_2 title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.applyWith</code></p> <p><code>apply (config := cfg) e</code> 类似于 <code>apply e</code>，但允许提供传递到底层 <code>apply</code> 操作的配置 <code>cfg : ApplyConfig</code>。</p> <h2 id=apply_3>apply?<a class=headerlink href=#apply_3 title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.apply?</code></p> <p>在环境中搜索可使用 <code>apply</code> 通过 <code>solve_by_elim</code> 解决条件来优化目标的定义或定理。</p> <p>可选的 <code>using</code> 子句提供必须用于关闭目标的局部上下文中的标识符。</p> <h2 id=apply_assumption>apply_assumption<a class=headerlink href=#apply_assumption title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.applyAssumption</code></p> <p><code>apply_assumption</code> 会寻找形式为 <code>... → ∀ _, ... → head</code> 的假设，其中 <code>head</code> 与当前目标匹配。</p> <p>您可以通过 <code>apply_assumption [...]</code> 指定额外的应用规则。默认情况下，<code>apply_assumption</code> 还会尝试使用 <code>rfl</code>、<code>trivial</code>、<code>congrFun</code> 和 <code>congrArg</code>。若您不希望使用这些规则，或不想使用所有假设，请使用 <code>apply_assumption only [...]</code>。您可以使用 <code>apply_assumption [-h]</code> 来忽略某个局部假设。通过 <code>apply_assumption using [a₁, ...]</code> 可以使用所有标有属性 <code>aᵢ</code> 的引理（这些属性必须通过 <code>register_label_attr</code> 创建）。</p> <p><code>apply_assumption</code> 会使用通过 <code>symm</code> 获得的局部假设的推论。</p> <p>若 <code>apply_assumption</code> 失败，它将调用 <code>exfalso</code> 并重试。因此，若存在形式为 <code>P → ¬ Q</code> 的假设，新的策略状态将包含两个目标：<code>P</code> 和 <code>Q</code>。</p> <p>您可以通过语法 <code>apply_rules (config := {...}) lemmas</code> 传递进一步的配置。支持的选项与 <code>solve_by_elim</code> 相同（包括所有 <code>apply</code> 的选项）。</p> <h2 id=apply_ext_theorem>apply_ext_theorem<a class=headerlink href=#apply_ext_theorem title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Elab.Tactic.Ext.applyExtTheorem</code></p> <p>将单个扩展性定理应用于当前目标。</p> <h2 id=apply_fun>apply_fun<a class=headerlink href=#apply_fun title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.applyFun</code></p> <p>将函数应用于等式或不等式中的局部假设或目标。</p> <ul> <li>若存在 <code>h : a = b</code>，则 <code>apply_fun f at h</code> 将替换为 <code>h : f a = f b</code>。</li> <li>若存在 <code>h : a ≤ b</code>，则 <code>apply_fun f at h</code> 将替换为 <code>h : f a ≤ f b</code>，并创建辅助目标 <code>Monotone f</code>。<code>apply_fun</code> 会自动尝试使用 <code>mono</code> 解决此辅助目标，或通过 <code>apply_fun f at h using P</code> 显式提供解决方案，其中 <code>P : Monotone f</code>。</li> <li>若存在 <code>h : a &lt; b</code>，则 <code>apply_fun f at h</code> 将替换为 <code>h : f a &lt; f b</code>，并创建辅助目标 <code>StrictMono f</code>，行为与上一条类似。</li> <li>若存在 <code>h : a ≠ b</code>，则 <code>apply_fun f at h</code> 将替换为 <code>h : f a ≠ f b</code>，并创建辅助目标 <code>Injective f</code>，行为与上述情况类似。</li> <li>若目标为 <code>a ≠ b</code>，<code>apply_fun f</code> 将替换为 <code>f a ≠ f b</code>。</li> <li>若目标为 <code>a = b</code>，<code>apply_fun f</code> 将替换为 <code>f a = f b</code>，并创建辅助目标 <code>injective f</code>。<code>apply_fun</code> 会自动尝试使用局部假设解决此辅助目标，若 <code>f</code> 实际为 <code>Equiv</code>，或通过 <code>apply_fun f using P</code> 显式提供解决方案，其中 <code>P : Injective f</code>。</li> <li>若目标为 <code>a ≤ b</code>（或类似 <code>a &lt; b</code>），且 <code>f</code> 实际为 <code>OrderIso</code>，<code>apply_fun f</code> 将替换目标为 <code>f a ≤ f b</code>。若 <code>f</code> 为其他类型（例如普通函数或 <code>Equiv</code>），<code>apply_fun</code> 将失败。</li> </ul> <p>典型用法如下： <div class=highlight><pre><span></span><code><span class=kn>open</span><span class=w> </span><span class=n>Function</span>

<span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>X</span><span class=w> </span><span class=n>Y</span><span class=w> </span><span class=n>Z</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=kt>Type</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>f</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>X</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>Y</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>g</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Y</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>Z</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>H</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Injective</span><span class=w> </span><span class=bp>&lt;|</span><span class=w> </span><span class=n>g</span><span class=w> </span><span class=bp>∘</span><span class=w> </span><span class=n>f</span><span class=o>)</span><span class=w> </span><span class=o>:</span>
<span class=w>    </span><span class=n>Injective</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>intros</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=n>x&#39;</span><span class=w> </span><span class=n>h</span>
<span class=w>  </span><span class=n>apply_fun</span><span class=w> </span><span class=n>g</span><span class=w> </span><span class=n>at</span><span class=w> </span><span class=n>h</span>
<span class=w>  </span><span class=n>exact</span><span class=w> </span><span class=n>H</span><span class=w> </span><span class=n>h</span>
</code></pre></div></p> <p>函数 <code>f</code> 的处理方式与 <code>refine</code> 类似，<code>f</code> 可包含占位符。命名占位符（如 <code>?a</code> 或 <code>?_</code>）将生成新目标。</p> <h2 id=apply_gmonoid_gnpowrec_succ_tac>apply_gmonoid_gnpowRec_succ_tac<a class=headerlink href=#apply_gmonoid_gnpowrec_succ_tac title="Permanent link">&para;</a></h2> <p>定义于：<code>GradedMonoid.tacticApply_gmonoid_gnpowRec_succ_tac</code></p> <p>作为 <code>GMonoid.gnpow_succ'</code> 可选值的策略。</p> <h2 id=apply_gmonoid_gnpowrec_zero_tac>apply_gmonoid_gnpowRec_zero_tac<a class=headerlink href=#apply_gmonoid_gnpowrec_zero_tac title="Permanent link">&para;</a></h2> <p>定义于：<code>GradedMonoid.tacticApply_gmonoid_gnpowRec_zero_tac</code></p> <p>作为 <code>GMonoid.gnpow_zero'</code> 可选值的策略。</p> <h2 id=apply_mod_cast>apply_mod_cast<a class=headerlink href=#apply_mod_cast title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.tacticApply_mod_cast_</code></p> <p>规范化目标及给定表达式中的强制转换，随后将表达式 <code>apply</code> 到目标。</p> <h2 id=apply_rfl>apply_rfl<a class=headerlink href=#apply_rfl title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.applyRfl</code></p> <p>与 <code>rfl</code> 相同，但不在最后尝试 <code>eq_refl</code>。</p> <h2 id=apply_rules>apply_rules<a class=headerlink href=#apply_rules title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.applyRules</code></p> <p><code>apply_rules [l₁, l₂, ...]</code> 尝试通过迭代应用引理列表 <code>[l₁, l₂, ...]</code> 或局部假设来解决主要目标。若 <code>apply</code> 生成新目标，<code>apply_rules</code> 会迭代尝试解决这些目标。您可使用 <code>apply_rules [-h]</code> 忽略局部假设。</p> <p><code>apply_rules</code> 还会使用 <code>rfl</code>、<code>trivial</code>、<code>congrFun</code> 和 <code>congrArg</code>。通过 <code>apply_rules only [...]</code> 可禁用这些规则及局部假设。</p> <p>通过 <code>apply_rules using [a₁, ...]</code> 可使用所有标有属性 <code>aᵢ</code> 的引理（这些属性必须通过 <code>register_label_attr</code> 创建）。</p> <p>您可通过语法 <code>apply_rules (config := {...})</code> 传递进一步配置。支持的选项与 <code>solve_by_elim</code> 相同（包括所有 <code>apply</code> 的选项）。</p> <p><code>apply_rules</code> 会在需要时对假设调用 <code>symm</code> 并对目标调用 <code>exfalso</code>。通过 <code>apply_rules (config := {symm := false, exfalso := false})</code> 可禁用此行为。</p> <p>使用语法 <code>apply_rules (config := {maxDepth := n})</code> 可限制迭代深度。</p> <p>与 <code>solve_by_elim</code> 不同，<code>apply_rules</code> 不执行回溯，并贪婪应用列表中的引理直至陷入停滞。</p> <h2 id=arith_mult>arith_mult<a class=headerlink href=#arith_mult title="Permanent link">&para;</a></h2> <p>定义于：<code>ArithmeticFunction.arith_mult</code></p> <p><code>arith_mult</code> 通过应用标有用户属性 <code>arith_mult</code> 的引理，解决形如 <code>IsMultiplicative f</code>（其中 <code>f : ArithmeticFunction R</code>）的目标。</p> <h2 id=arith_mult_1>arith_mult?<a class=headerlink href=#arith_mult_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>ArithmeticFunction.arith_mult?</code></p> <p><code>arith_mult</code> 通过应用标有用户属性 <code>arith_mult</code> 的引理，解决形如 <code>IsMultiplicative f</code>（其中 <code>f : ArithmeticFunction R</code>）的目标，并打印生成的证明项。</p> <h2 id=array_get_dec>array_get_dec<a class=headerlink href=#array_get_dec title="Permanent link">&para;</a></h2> <p>定义于：<code>Array.tacticArray_get_dec</code></p> <p>此策略被添加到 <code>decreasing_trivial</code> 工具箱中，用于证明 <code>sizeOf arr[i] &lt; sizeOf arr</code>，这对于嵌套归纳类型（如 <code>inductive T | mk : Array T → T</code>）的良基递归非常有用。</p> <h2 id=array_mem_dec>array_mem_dec<a class=headerlink href=#array_mem_dec title="Permanent link">&para;</a></h2> <p>定义于：<code>Array.tacticArray_mem_dec</code></p> <p>此策略被添加到 <code>decreasing_trivial</code> 工具箱中，用于在 <code>a ∈ arr</code> 时证明 <code>sizeOf a &lt; sizeOf arr</code>，这对于嵌套归纳类型（如 <code>inductive T | mk : Array T → T</code>）的良基递归非常有用。</p> <h2 id=as_aux_lemma>as_aux_lemma<a class=headerlink href=#as_aux_lemma title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.as_aux_lemma</code></p> <p><code>as_aux_lemma =&gt; tac</code> 执行与 <code>tac</code> 相同的操作，但会将结果表达式包装到辅助引理中。在某些情况下，这能显著减小表达式的大小，因为证明项不会被重复。</p> <h2 id=assumption>assumption<a class=headerlink href=#assumption title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.assumption</code></p> <p><code>assumption</code> 尝试使用类型兼容的假设解决主要目标，否则失败。另请注意术语符号 <code>‹t›</code>，它是 <code>show t by assumption</code> 的简写。</p> <h2 id=assumption_1>assumption'<a class=headerlink href=#assumption_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.tacticAssumption'</code></p> <p>尝试在所有目标上调用 <code>assumption</code>；若至少关闭一个目标，则成功。</p> <h2 id=assumption_mod_cast>assumption_mod_cast<a class=headerlink href=#assumption_mod_cast title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.tacticAssumption_mod_cast_</code></p> <p><code>assumption_mod_cast</code> 是 <code>assumption</code> 的变体，使用假设解决目标。与 <code>assumption</code> 不同，它首先预处理目标及各假设，将强制转换尽可能外移，从而适用于更多情况。</p> <p>具体而言，它对目标运行 <code>norm_cast</code>。对于每个局部假设 <code>h</code>，它还会使用 <code>norm_cast</code> 规范化 <code>h</code>，并尝试用其关闭目标。</p> <h2 id=attempt_all>attempt_all<a class=headerlink href=#attempt_all title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.attemptAll</code></p> <p>实现 <code>try?</code> 策略的辅助内部策略。</p> <h2 id=aux_group1>aux_group₁<a class=headerlink href=#aux_group1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.Group.aux_group₁</code></p> <p><code>group</code> 策略的辅助策略。仅调用简化器。</p> <h2 id=aux_group2>aux_group₂<a class=headerlink href=#aux_group2 title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.Group.aux_group₂</code></p> <p><code>group</code> 策略的辅助策略。调用 <code>ring_nf</code> 规范化指数。</p> <h2 id=bdddefault>bddDefault<a class=headerlink href=#bdddefault title="Permanent link">&para;</a></h2> <p>定义于：<code>tacticBddDefault</code></p> <p>在完全格中，集合自动有界或共界。为了在完全格和条件完全格中使用相同陈述，但让自动化在完全格中自动填充有界性证明，我们在陈述中使用 <code>bddDefault</code> 策略，形式为 <code>(hA : BddAbove A := by bddDefault)</code>。</p> <h2 id=beta_reduce>beta_reduce<a class=headerlink href=#beta_reduce title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.betaReduceStx</code></p> <p><code>beta_reduce at loc</code> 完全贝塔归约给定位置。这也作为 <code>conv</code> 模式策略存在。</p> <p>这意味着每当有一个应用的lambda表达式如 <code>(fun x =&gt; f x) y</code> 时，参数会被代入lambda表达式，生成如 <code>f y</code> 的表达式。</p> <h2 id=bicategory>bicategory<a class=headerlink href=#bicategory title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.Bicategory.tacticBicategory</code></p> <p>使用双范畴的相干定理来解双范畴中的方程，其中两边仅通过用不同但具有相同源和目标的双范畴结构态射（即结合子、单位子和恒等态射）替换结构态射字符串而不同。</p> <p>即，<code>bicategory</code> 可处理形如 <code>a ≫ f ≫ b ≫ g ≫ c = a' ≫ f ≫ b' ≫ g ≫ c'</code> 的目标，其中 <code>a = a'</code>、<code>b = b'</code> 和 <code>c = c'</code> 可通过 <code>bicategory_coherence</code> 证明。</p> <h2 id=bicategory_coherence>bicategory_coherence<a class=headerlink href=#bicategory_coherence title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.BicategoryCoherence.tacticBicategory_coherence</code></p> <p>双范畴的相干策略。请改用 <code>pure_coherence</code>，这是本策略的前端。</p> <h2 id=bicategory_coherence_1>bicategory_coherence<a class=headerlink href=#bicategory_coherence_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.Bicategory.tacticBicategory_coherence</code></p> <p>关闭形如 <code>η = θ</code> 的目标，其中 <code>η</code> 和 <code>θ</code> 是仅由结合子、单位子和恒等态射构成的2-同构。 <div class=highlight><pre><span></span><code><span class=bp>示例</span><span class=w> </span><span class=o>{</span><span class=n>B</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=kt>Type</span><span class=o>}</span><span class=w> </span><span class=o>[</span><span class=n>Bicategory</span><span class=w> </span><span class=n>B</span><span class=o>]</span><span class=w> </span><span class=o>{</span><span class=n>a</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>B</span><span class=o>}</span><span class=w> </span><span class=o>:</span>
<span class=w>  </span><span class=o>(</span><span class=bp>λ</span><span class=n>_</span><span class=w> </span><span class=o>(</span><span class=mi>𝟙</span><span class=w> </span><span class=n>a</span><span class=o>))</span><span class=bp>.</span><span class=n>hom</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=o>(</span><span class=n>ρ_</span><span class=w> </span><span class=o>(</span><span class=mi>𝟙</span><span class=w> </span><span class=n>a</span><span class=o>))</span><span class=bp>.</span><span class=n>hom</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>bicategory_coherence</span>
</code></pre></div></p> <h2 id=bicategory_nf>bicategory_nf<a class=headerlink href=#bicategory_nf title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.Bicategory.tacticBicategory_nf</code></p> <p>规范化等式两边。</p> <h2 id=bitwise_assoc_tac>bitwise_assoc_tac<a class=headerlink href=#bitwise_assoc_tac title="Permanent link">&para;</a></h2> <p>定义于：<code>Nat.tacticBitwise_assoc_tac</code></p> <p>证明位运算的结合性通常需要进行大量的案例分析，因此使用此策略比在一般情况下证明更为简便。</p> <h2 id=borelize>borelize<a class=headerlink href=#borelize title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.Borelize.tacticBorelize___</code></p> <p><code>borelize α</code> 的行为取决于关于 <code>α</code> 的现有假设：</p> <ul> <li>若 <code>α</code> 是具有实例 <code>[MeasurableSpace α] [BorelSpace α]</code> 的拓扑空间，则 <code>borelize α</code> 将前者实例替换为 <code>borel α</code>；</li> <li>否则，<code>borelize α</code> 添加实例 <code>borel α : MeasurableSpace α</code> 和 <code>⟨rfl⟩ : BorelSpace α</code>。</li> </ul> <p>最后，<code>borelize α β γ</code> 执行 <code>borelize α; borelize β; borelize γ</code>。</p> <h2 id=bound>bound<a class=headerlink href=#bound title="Permanent link">&para;</a></h2> <p>定义于：<code>«tacticBound[_]»</code></p> <p><code>bound</code> 策略通过直接递归表达式结构来证明不等式。</p> <p>一个使用示例如下：</p> <div class=highlight><pre><span></span><code>-- 计算示例：`z ↦ z^2 + c` 的弱下界
lemma le_sqr_add (c z : ℝ) (cz : ‖c‖ ≤ ‖z‖) (z3 : 3 ≤ ‖z‖) :
    2 * ‖z‖ ≤ ‖z^2 + c‖ := by
  calc ‖z^2 + c‖
    _ ≥ ‖z^2‖ - ‖c‖ := by bound
    _ ≥ ‖z^2‖ - ‖z‖ := by bound
    _ ≥ (‖z‖ - 1) * ‖z‖ := by
      rw [mul_comm, mul_sub_one, ← pow_two, ← norm_pow]
    _ ≥ 2 * ‖z‖ := by bound
</code></pre></div> <p><code>bound</code> 构建于 <code>aesop</code> 之上，使用： 1. 应用通过 <code>@[bound]</code> 属性注册的引理 2. 前向通过 <code>@[bound_forward]</code> 属性注册的引理 3. 上下文中的局部假设 4. 可选：作为 <code>bound [h₀, h₁]</code> 提供的额外假设。这些假设会被添加到上下文中，如同通过 <code>have := hᵢ</code> 添加。</p> <p><code>bound</code> 的功能与 <code>positivity</code> 和 <code>gcongr</code> 有所重叠，但可以在 <code>0 ≤ x</code> 和 <code>x ≤ y</code> 型不等式之间来回跳跃。例如，<code>bound</code> 通过将目标转化为 <code>b * c ≤ a * c</code>，然后使用 <code>mul_le_mul_of_nonneg_right</code> 来证明 <code>0 ≤ c → b ≤ a → 0 ≤ a * c - b * c</code>。<code>bound</code> 还包含处理形如 <code>1 ≤ x</code>、<code>1 &lt; x</code>、<code>x ≤ 1</code>、<code>x &lt; 1</code> 的目标的引理。相反，<code>gcongr</code> 可证明更多类型关系的不等式，支持所有 <code>positivity</code> 功能，并且可能更快，因为它更专门（非基于 <code>aesop</code>）。</p> <h2 id=bv_check>bv_check<a class=headerlink href=#bv_check title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.bvCheck</code></p> <p>此策略与 <code>bv_decide</code> 类似，但通过使用已存储在磁盘上的证明来跳过调用SAT求解器。调用时需指定与当前Lean文件同目录下的LRAT文件名： <div class=highlight><pre><span></span><code><span class=n>bv_check</span><span class=w> </span><span class=s2>&quot;proof.lrat&quot;</span>
</code></pre></div></p> <h2 id=bv_decide>bv_decide<a class=headerlink href=#bv_decide title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.bvDecide</code></p> <p>通过从外部SAT求解器获取证明并在Lean内部验证，关闭固定宽度的 <code>BitVec</code> 和 <code>Bool</code> 目标。当前可解决的目标限于： - Lean中等效于 <a href=https://smt-lib.org/logics-all.shtml#QF_BV><code>QF_BV</code></a> 的目标 - 自动拆解包含 <code>BitVec</code> 或 <code>Bool</code> 信息的结构 <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=o>:</span><span class=w> </span><span class=bp>∀</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>BitVec</span><span class=w> </span><span class=mi>64</span><span class=o>),</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=bp>&amp;&amp;&amp;</span><span class=w> </span><span class=n>b</span><span class=o>)</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=bp>^^^</span><span class=w> </span><span class=n>b</span><span class=o>)</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>|||</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>intros</span>
<span class=w>  </span><span class=n>bv_decide</span>
</code></pre></div></p> <p>若 <code>bv_decide</code> 遇到未知定义，则会将其视为无约束的 <code>BitVec</code> 变量。有时这可以在不理解定义的情况下解决问题，因为定义的精确属性在特定证明中无关紧要。</p> <p>若 <code>bv_decide</code> 未能关闭目标，则会提供反例，包含所有被视为变量的项的赋值。</p> <p>为避免每次调用SAT求解器，可通过 <code>bv_decide?</code> 缓存证明。</p> <p>若解决问题依赖于结合性或交换性，请启用 <code>bv.ac_nf</code> 选项。</p> <p>注意：<code>bv_decide</code> 使用 <code>ofReduceBool</code>，因此信任代码生成器的正确性。</p> <p>注意：需包含 <code>import Std.Tactic.BVDecide</code></p> <h2 id=bv_decide_1>bv_decide?<a class=headerlink href=#bv_decide_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.bvTraceMacro</code></p> <p>为 <code>bv_decide</code> 策略调用建议证明脚本。用于缓存LRAT证明。</p> <p>注意：需包含 <code>import Std.Tactic.BVDecide</code></p> <h2 id=bv_normalize>bv_normalize<a class=headerlink href=#bv_normalize title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.bvNormalize</code></p> <p>仅运行 <code>bv_decide</code> 的规范化过程。有时这足以解决基本的 <code>BitVec</code> 目标。</p> <p>注意：需包含 <code>import Std.Tactic.BVDecide</code></p> <h2 id=bv_omega>bv_omega<a class=headerlink href=#bv_omega title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.tacticBv_omega</code></p> <p><code>bv_omega</code> 是带有预处理器的 <code>omega</code>，将关于 <code>BitVec</code> 的陈述转化为关于 <code>Nat</code> 的陈述。当前预处理器实现为 <code>try simp only [bitvec_to_nat] at *</code>。<code>bitvec_to_nat</code> 是您可（谨慎）添加更多定理的 <code>@[simp]</code> 属性。</p> <h2 id=by_cases>by_cases<a class=headerlink href=#by_cases title="Permanent link">&para;</a></h2> <p>定义于：<code>«tacticBy_cases_:_»</code></p> <p><code>by_cases (h :)? p</code> 将主目标拆分为两种情况，在第一个分支中假设 <code>h : p</code>，在第二个分支中假设 <code>h : ¬ p</code>。</p> <h2 id=by_contra>by_contra<a class=headerlink href=#by_contra title="Permanent link">&para;</a></h2> <p>定义于：<code>Batteries.Tactic.byContra</code></p> <p><code>by_contra h</code> 通过反证法证明 <code>⊢ p</code>，引入假设 <code>h : ¬p</code> 并证明 <code>False</code>。 * 若 <code>p</code> 是否定式 <code>¬q</code>，则会引入 <code>h : q</code> 而非 <code>¬¬q</code>。 * 若 <code>p</code> 可判定，则使用 <code>Decidable.byContradiction</code> 替代 <code>Classical.byContradiction</code>。 * 若省略 <code>h</code>，则引入的变量 <code>_: ¬p</code> 将为匿名。## by_contra! 定义于：<code>byContra!</code></p> <p>若主目标的目标类型为命题 <code>p</code>，<code>by_contra!</code> 会将目标转换为在额外假设 <code>this : ¬ p</code> 下证明 <code>False</code>。<br> <code>by_contra! h</code> 可用于为假设命名 <code>h : ¬ p</code>。<br> 假设 <code>¬ p</code> 将使用 <code>push_neg</code> 进行否定规范化。例如，<code>¬ a &lt; b</code> 将被更改为 <code>b ≤ a</code>。<br> <code>by_contra! h : q</code> 会对 <code>¬ p</code> 进行否定规范化，对 <code>q</code> 进行否定规范化，然后检查两个规范化形式是否相等。生成的假设为规范化前的形式 <code>q</code>。<br> 若未显式提供名称 <code>h</code>，则默认使用 <code>this</code> 作为名称。<br> 此策略使用经典推理。<br> 它是策略 <code>by_contra</code> 的一个变体。<br> 示例：<br> <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>by_contra</span><span class=bp>!</span><span class=w> </span><span class=n>h</span>
<span class=w>  </span><span class=c1>-- h : 2 ≤ 1 ⊢ False</span>

<span class=kd>example</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>by_contra</span><span class=bp>!</span><span class=w> </span><span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=bp>¬</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=mi>2</span>
<span class=w>  </span><span class=c1>-- h : ¬ 1 &lt; 2 ⊢ False</span>
</code></pre></div></p> <h2 id=calc>calc<a class=headerlink href=#calc title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.calcTactic</code></p> <p>基于传递关系的逐步推理。<br> <div class=highlight><pre><span></span><code><span class=k>calc</span>
<span class=w>  </span><span class=n>a</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=n>pab</span>
<span class=w>  </span><span class=n>b</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=n>pbc</span>
<span class=w>  </span><span class=bp>...</span>
<span class=w>  </span><span class=n>y</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>z</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=n>pyz</span>
</code></pre></div> 通过逐步证明 <code>a = b</code>、<code>b = c</code> 等，最终证明 <code>a = z</code>。<code>=</code> 可替换为任何实现了 <code>Trans</code> 类型类的关系。为避免重复右侧表达式，后续左侧可用 <code>_</code> 替代。<br> <div class=highlight><pre><span></span><code><span class=k>calc</span>
<span class=w>  </span><span class=n>a</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=n>pab</span>
<span class=w>  </span><span class=n>_</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=n>pbc</span>
<span class=w>  </span><span class=bp>...</span>
<span class=w>  </span><span class=n>_</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>z</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=n>pyz</span>
</code></pre></div> 首行也可写作 <code>&lt;lhs&gt;\n _ = &lt;rhs&gt; := &lt;proof&gt;</code>，便于对齐长标识符的关系符号：<br> <div class=highlight><pre><span></span><code><span class=k>calc</span><span class=w> </span><span class=n>abc</span>
<span class=w>  </span><span class=n>_</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>bce</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=n>pabce</span>
<span class=w>  </span><span class=n>_</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>cef</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=n>pbcef</span>
<span class=w>  </span><span class=bp>...</span>
<span class=w>  </span><span class=n>_</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>xyz</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=n>pwxyz</span>
</code></pre></div></p> <p><code>calc</code> 可作为项、策略或 <code>conv</code> 策略使用。<br> 详见 <a href=https://lean-lang.org/theorem_proving_in_lean4/induction_and_recursion.html>Lean 4 定理证明</a>。 </p> <h2 id=calc_1>calc?<a class=headerlink href=#calc_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Elab.Tactic.tacticCalc?</code></p> <p>生成 <code>calc</code> 证明。</p> <h2 id=cancel_denoms>cancel_denoms<a class=headerlink href=#cancel_denoms title="Permanent link">&para;</a></h2> <p>定义于：<code>tacticCancel_denoms_</code></p> <h2 id=cancel_denoms_1>cancel_denoms<a class=headerlink href=#cancel_denoms_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>cancelDenoms</code></p> <p><code>cancel_denoms</code> 尝试从分数分母中去除数值。适用于有序域不等式命题。 </p> <div class=highlight><pre><span></span><code><span class=kd>variable</span><span class=w> </span><span class=o>[</span><span class=n>LinearOrderedField</span><span class=w> </span><span class=n>α</span><span class=o>]</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>α</span><span class=o>)</span>

<span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>/</span><span class=w> </span><span class=mi>5</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=bp>/</span><span class=w> </span><span class=mi>4</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=n>c</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=mi>4</span><span class=bp>*</span><span class=n>a</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>5</span><span class=bp>*</span><span class=n>b</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=mi>20</span><span class=bp>*</span><span class=n>c</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>cancel_denoms</span><span class=w> </span><span class=n>at</span><span class=w> </span><span class=n>h</span>
<span class=w>  </span><span class=n>exact</span><span class=w> </span><span class=n>h</span>

<span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>&gt;</span><span class=w> </span><span class=mi>0</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>/</span><span class=w> </span><span class=mi>5</span><span class=w> </span><span class=bp>&gt;</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>cancel_denoms</span>
<span class=w>  </span><span class=n>exact</span><span class=w> </span><span class=n>h</span>
</code></pre></div> <h2 id=case>case<a class=headerlink href=#case title="Permanent link">&para;</a></h2> <p>定义于：<code>Batteries.Tactic.casePatt</code></p> <ul> <li> <p><code>case _ : t =&gt; tac</code> 寻找首个与 <code>t</code> 统一的目标，使用 <code>tac</code> 解决之，否则失败。类似 <code>show</code>，将目标类型更改为 <code>t</code>。<br> <code>_</code> 可为案例标签，此时仅匹配符合 <code>case</code> 规则的目标（精确匹配标签，或以标签为后缀/前缀的目标）。 </p> </li> <li> <p><code>case _ n₁ ... nₘ : t =&gt; tac</code> 额外将最近 <code>m</code> 个不可访问名称的假设重命名为指定名称。重命名在匹配 <code>t</code> 前进行。<br> <code>_</code> 可为案例标签。 </p> </li> <li> <p><code>case _ : t := e</code> 是 <code>case _ : t =&gt; exact e</code> 的简写。 </p> </li> <li> <p><code>case _ : t₁ | _ : t₂ | ... =&gt; tac</code> 等价于依次对每个模式执行 <code>case</code>，但所有匹配基于原始目标列表——每个目标被匹配后即被消耗，故模式可重复或重叠。 </p> </li> <li> <p><code>case _ : t</code> 将使匹配目标成为首个目标。<br> <code>case _ : t₁ | _ : t₂ | ...</code> 按顺序使匹配目标成为首个目标。 </p> </li> <li> <p><code>case _ : t := _</code> 和 <code>case _ : t := ?m</code> 等同于 <code>case _ : t</code>，但在 <code>?m</code> 情况下目标标签更改为 <code>m</code>，目标变为元变量 <code>?m</code>。 </p> </li> </ul> <h2 id=case_1>case<a class=headerlink href=#case_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.case</code></p> <ul> <li><code>case tag =&gt; tac</code> 聚焦于案例名为 <code>tag</code> 的目标，使用 <code>tac</code> 解决之，否则失败。 </li> <li><code>case tag x₁ ... xₙ =&gt; tac</code> 额外将最近 <code>n</code> 个假设重命名为指定名称。 </li> <li><code>case tag₁ | tag₂ =&gt; tac</code> 等价于依次执行 <code>(case tag₁ =&gt; tac); (case tag₂ =&gt; tac)</code>。 </li> </ul> <h2 id=case_2>case'<a class=headerlink href=#case_2 title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.case'</code></p> <p><code>case'</code> 类似 <code>case tag =&gt; tac</code>，但不确保 <code>tac</code> 后目标已解决，且在 <code>tac</code> 失败时不会承认目标。注意：<code>case</code> 在 <code>tac</code> 失败时使用 <code>sorry</code> 关闭目标，且不中断策略执行。 </p> <h2 id=case_3>case'<a class=headerlink href=#case_3 title="Permanent link">&para;</a></h2> <p>定义于：<code>Batteries.Tactic.casePatt'</code></p> <p><code>case' _ : t =&gt; tac</code> 类似 <code>case _ : t =&gt; tac</code>，但不确保 <code>tac</code> 后目标已解决，且在 <code>tac</code> 失败时不会承认目标。注意：<code>case</code> 在 <code>tac</code> 失败时使用 <code>sorry</code> 关闭目标，且不中断策略执行。 </p> <h2 id=cases>cases<a class=headerlink href=#cases title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.cases</code></p> <p>假设局部上下文中变量 <code>x</code> 具有归纳类型，<code>cases x</code> 将主目标拆分，为每个构造子生成一个目标，其中目标被替换为该构造子的通用实例。若局部上下文中的元素类型依赖于 <code>x</code>，则该元素会被恢复并重新引入，确保案例拆分影响该假设。<code>cases</code> 自动检测并关闭不可达案例。 </p> <p>例如，给定 <code>n : Nat</code> 及目标假设 <code>h : P n</code> 和目标 <code>Q n</code>，<code>cases n</code> 生成两个目标：假设 <code>h : P 0</code> 和目标 <code>Q 0</code>，以及假设 <code>h : P (Nat.succ a)</code> 和目标 <code>Q (Nat.succ a)</code>。此处名称 <code>a</code> 自动生成且不可访问。可使用 <code>with</code> 为各构造子指定变量名。<br> - <code>cases e</code>（<code>e</code> 为表达式而非变量）将 <code>e</code> 在目标中泛化，然后对结果变量进行案例拆分。<br> - 给定 <code>as : List α</code>，<code>cases as with | nil =&gt; tac₁ | cons a as' =&gt; tac₂</code> 对 <code>nil</code> 案例使用 <code>tac₁</code>，对 <code>cons</code> 案例使用 <code>tac₂</code>，其中 <code>a</code> 和 <code>as'</code> 为新引入变量名。<br> - <code>cases h : e</code>（<code>e</code> 为变量或表达式）对 <code>e</code> 进行案例拆分，并为每个案例添加假设 <code>h : e = ...</code>，其中 <code>...</code> 为该案例的构造子实例。 </p> <h2 id=cases_1>cases'<a class=headerlink href=#cases_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.cases'</code></p> <p><code>cases'</code> 策略类似 Lean 4 核心的 <code>cases</code>，但命名语法不同： </p> <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>p</span><span class=w> </span><span class=bp>∨</span><span class=w> </span><span class=n>q</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>q</span><span class=w> </span><span class=bp>∨</span><span class=w> </span><span class=n>p</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>cases</span><span class=w> </span><span class=n>h</span><span class=w> </span><span class=k>with</span>
<span class=w>  </span><span class=bp>|</span><span class=w> </span><span class=n>inl</span><span class=w> </span><span class=n>hp</span><span class=w> </span><span class=bp>=&gt;</span><span class=w> </span><span class=n>exact</span><span class=w> </span><span class=n>Or.inr</span><span class=w> </span><span class=n>hp</span>
<span class=w>  </span><span class=bp>|</span><span class=w> </span><span class=n>inr</span><span class=w> </span><span class=n>hq</span><span class=w> </span><span class=bp>=&gt;</span><span class=w> </span><span class=n>exact</span><span class=w> </span><span class=n>Or.inl</span><span class=w> </span><span class=n>hq</span>

<span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>p</span><span class=w> </span><span class=bp>∨</span><span class=w> </span><span class=n>q</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>q</span><span class=w> </span><span class=bp>∨</span><span class=w> </span><span class=n>p</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>cases&#39;</span><span class=w> </span><span class=n>h</span><span class=w> </span><span class=k>with</span><span class=w> </span><span class=n>hp</span><span class=w> </span><span class=n>hq</span>
<span class=w>  </span><span class=bp>·</span><span class=w> </span><span class=n>exact</span><span class=w> </span><span class=n>Or.inr</span><span class=w> </span><span class=n>hp</span>
<span class=w>  </span><span class=bp>·</span><span class=w> </span><span class=n>exact</span><span class=w> </span><span class=n>Or.inl</span><span class=w> </span><span class=n>hq</span>

<span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>p</span><span class=w> </span><span class=bp>∨</span><span class=w> </span><span class=n>q</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>q</span><span class=w> </span><span class=bp>∨</span><span class=w> </span><span class=n>p</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>rcases</span><span class=w> </span><span class=n>h</span><span class=w> </span><span class=k>with</span><span class=w> </span><span class=n>hp</span><span class=w> </span><span class=bp>|</span><span class=w> </span><span class=n>hq</span>
<span class=w>  </span><span class=bp>·</span><span class=w> </span><span class=n>exact</span><span class=w> </span><span class=n>Or.inr</span><span class=w> </span><span class=n>hp</span>
<span class=w>  </span><span class=bp>·</span><span class=w> </span><span class=n>exact</span><span class=w> </span><span class=n>Or.inl</span><span class=w> </span><span class=n>hq</span>
</code></pre></div> <p>推荐优先使用 <code>cases</code> 或 <code>rcases</code>，因其支持结构化证明。 </p> <h2 id=cases_first_enat>cases_first_enat<a class=headerlink href=#cases_first_enat title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.ENatToNat.tacticCases_first_enat</code></p> <p>在上下文中查找首个 <code>ENat</code> 并对其应用 <code>cases</code> 策略，随后使用 <code>enat_to_nat_top</code> 简化集简化含 <code>⊤</code> 的表达式。 </p> <h2 id=cases_type>cases_type<a class=headerlink href=#cases_type title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.casesType</code></p> <ul> <li><code>cases_type I</code> 对假设 <code>h : (I ...)</code> 应用 <code>cases</code> 策略。 </li> <li><code>cases_type I_1 ... I_n</code> 对假设 <code>h : (I_1 ...)</code> 或 ... 或 <code>h : (I_n ...)</code> 应用 <code>cases</code> 策略。 </li> <li><code>cases_type* I</code> 为 <code>· repeat cases_type I</code> 的简写。 </li> <li><code>cases_type! I</code> 仅在生成子目标数 ≤ 1 时应用 <code>cases</code>。 </li> </ul> <p>示例：以下策略解构当前目标中所有合取与析取。<br> <div class=highlight><pre><span></span><code><span class=n>cases_type</span><span class=bp>*</span><span class=w> </span><span class=n>Or</span><span class=w> </span><span class=n>And</span>
</code></pre></div></p> <h2 id=cases_type_1>cases_type!<a class=headerlink href=#cases_type_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.casesType!</code></p> <ul> <li><code>cases_type I</code> 对假设 <code>h : (I ...)</code> 应用 <code>cases</code> 策略。 </li> <li><code>cases_type I_1 ... I_n</code> 对假设 <code>h : (I_1 ...)</code> 或 ... 或 <code>h : (I_n ...)</code> 应用 <code>cases</code> 策略。 </li> <li><code>cases_type* I</code> 为 <code>· repeat cases_type I</code> 的简写。 </li> <li><code>cases_type! I</code> 仅在生成子目标数 ≤ 1 时应用 <code>cases</code>。 </li> </ul> <p>示例：以下策略解构当前目标中所有合取与析取。<br> <div class=highlight><pre><span></span><code><span class=n>cases_type</span><span class=bp>*</span><span class=w> </span><span class=n>Or</span><span class=w> </span><span class=n>And</span>
</code></pre></div></p> <h2 id=casesm>casesm<a class=headerlink href=#casesm title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.casesM</code></p> <p><code>casesm</code> 允许使用模式匹配语法指定多个目标进行案例拆分。例如：<br> <div class=highlight><pre><span></span><code><span class=n>casesm</span><span class=w> </span><span class=n>_</span><span class=w> </span><span class=bp>∨</span><span class=w> </span><span class=n>_</span><span class=w>  </span><span class=c1>-- 拆分所有析取假设</span>
<span class=n>casesm</span><span class=w> </span><span class=n>_</span><span class=w> </span><span class=bp>∧</span><span class=w> </span><span class=n>_</span><span class=w>  </span><span class=c1>-- 拆分所有合取假设</span>
</code></pre></div></p> <ul> <li><code>casesm p</code> 对假设 <code>h : type</code> 应用 <code>cases</code> 策略，前提是 <code>type</code> 匹配模式 <code>p</code>。</li> <li><code>casesm p_1, ..., p_n</code> 对假设 <code>h : type</code> 应用 <code>cases</code> 策略，前提是 <code>type</code> 匹配任一给定模式。</li> <li><code>casesm* p</code> 是 <code>· repeat casesm p</code> 的更高效简洁版本，由于模式只需编译一次，因此效率更高。</li> <li><code>casesm! p</code> 仅在生成的子目标数 ≤ 1 时应用 <code>cases</code>。</li> </ul> <p>示例：以下策略在当前上下文中解构所有合取与析取。 <div class=highlight><pre><span></span><code><span class=n>casesm</span><span class=bp>*</span><span class=w> </span><span class=n>_</span><span class=w> </span><span class=bp>∨</span><span class=w> </span><span class=n>_</span><span class=o>,</span><span class=w> </span><span class=n>_</span><span class=w> </span><span class=bp>∧</span><span class=w> </span><span class=n>_</span>
</code></pre></div></p> <h2 id=casesm_1>casesm!<a class=headerlink href=#casesm_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.casesm!</code></p> <ul> <li><code>casesm p</code> 对假设 <code>h : type</code> 应用 <code>cases</code> 策略，前提是 <code>type</code> 匹配模式 <code>p</code>。</li> <li><code>casesm p_1, ..., p_n</code> 对假设 <code>h : type</code> 应用 <code>cases</code> 策略，前提是 <code>type</code> 匹配任一给定模式。</li> <li><code>casesm* p</code> 是 <code>· repeat casesm p</code> 的更高效简洁版本，由于模式只需编译一次，因此效率更高。</li> <li><code>casesm! p</code> 仅在生成的子目标数 ≤ 1 时应用 <code>cases</code>。</li> </ul> <p>示例：以下策略在当前上下文中解构所有合取与析取。 <div class=highlight><pre><span></span><code><span class=n>casesm</span><span class=bp>*</span><span class=w> </span><span class=n>_</span><span class=w> </span><span class=bp>∨</span><span class=w> </span><span class=n>_</span><span class=o>,</span><span class=w> </span><span class=n>_</span><span class=w> </span><span class=bp>∧</span><span class=w> </span><span class=n>_</span>
</code></pre></div></p> <h2 id=cc>cc<a class=headerlink href=#cc title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.cc</code></p> <p>同余闭包策略 <code>cc</code> 试图通过链式应用上下文中的等式及同余（即若 <code>a = b</code>，则 <code>f a = f b</code>）来解决目标。它是终结策略，旨在关闭当前目标而非取得不确定的进展。一个简单的示例如下：</p> <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℕ</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>f</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℕ</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>ℕ</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>h</span><span class=o>:</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>b</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>h&#39;</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>c</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>cc</span>
</code></pre></div> <p>需要手动推导的示例如下：</p> <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>f</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℕ</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>ℕ</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>x</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℕ</span><span class=o>)</span>
<span class=w>    </span><span class=o>(</span><span class=n>H1</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=o>(</span><span class=n>f</span><span class=w> </span><span class=o>(</span><span class=n>f</span><span class=w> </span><span class=n>x</span><span class=o>))</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>x</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>H2</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=o>(</span><span class=n>f</span><span class=w> </span><span class=o>(</span><span class=n>f</span><span class=w> </span><span class=o>(</span><span class=n>f</span><span class=w> </span><span class=o>(</span><span class=n>f</span><span class=w> </span><span class=n>x</span><span class=o>))))</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>x</span><span class=o>)</span><span class=w> </span><span class=o>:</span>
<span class=w>    </span><span class=n>f</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>cc</span>
</code></pre></div> <h2 id=cfc_cont_tac>cfc_cont_tac<a class=headerlink href=#cfc_cont_tac title="Permanent link">&para;</a></h2> <p>定义于：<code>cfcContTac</code></p> <p>用于自动解除与连续函数演算相关目标的策略，特别涉及函数的连续性。</p> <h2 id=cfc_tac>cfc_tac<a class=headerlink href=#cfc_tac title="Permanent link">&para;</a></h2> <p>定义于：<code>cfcTac</code></p> <p>用于自动解除与连续函数演算相关目标的策略，特别是元素是否满足谓词。</p> <h2 id=cfc_zero_tac>cfc_zero_tac<a class=headerlink href=#cfc_zero_tac title="Permanent link">&para;</a></h2> <p>定义于：<code>cfcZeroTac</code></p> <p>用于自动解除与非单位连续函数演算相关目标的策略，特别是验证 <code>f 0 = 0</code>。</p> <h2 id=change>change<a class=headerlink href=#change title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.change</code></p> <ul> <li><code>change tgt'</code> 将目标从 <code>tgt</code> 更改为 <code>tgt'</code>，假设二者定义等价。</li> <li><code>change t' at h</code> 将假设 <code>h : t</code> 的类型更改为 <code>t'</code>，假设 <code>t</code> 和 <code>t'</code> 定义等价。</li> </ul> <h2 id=change_1>change<a class=headerlink href=#change_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.changeWith</code></p> <ul> <li><code>change a with b</code> 将目标中的 <code>a</code> 更改为 <code>b</code>，假设二者定义等价。</li> <li><code>change a with b at h</code> 类似地更改假设 <code>h</code> 类型中的 <code>a</code> 为 <code>b</code>。</li> </ul> <h2 id=change_2>change?<a class=headerlink href=#change_2 title="Permanent link">&para;</a></h2> <p>定义于：<code>change?</code></p> <p><code>change? term</code> 将 <code>term</code> 与当前目标统一，然后建议使用统一后的 <code>term</code> 的显式 <code>change</code> 语法。</p> <p>若 <code>term</code> 未提供，<code>change?</code> 将建议当前目标本身。这在需要删除维持定义等价的先前策略（如 <code>dsimp</code>）时有用。</p> <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=o>(</span><span class=k>fun</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Nat</span><span class=w> </span><span class=bp>=&gt;</span><span class=w> </span><span class=n>x</span><span class=o>)</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>change</span><span class=bp>?</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>_</span><span class=w>  </span><span class=c1>-- `Try this: change 0 = 1`</span>
</code></pre></div> <h2 id=check_compositions>check_compositions<a class=headerlink href=#check_compositions title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.CheckCompositions.tacticCheck_compositions</code></p> <p>对于目标中的每个组合 <code>f ≫ g</code>（内部表示为 <code>CategoryStruct.comp C inst X Y Z f g</code>），推断 <code>f</code> 和 <code>g</code> 的类型，并在“实例与可约简”透明级别检查其来源和目标是否与 <code>X</code>、<code>Y</code> 和 <code>Z</code> 一致，报告任何差异。</p> <p>示例：</p> <div class=highlight><pre><span></span><code>example (j : J) :
    colimit.ι ((F ⋙ G) ⋙ H) j ≫ (preservesColimitIso (G ⋙ H) F).inv =
      H.map (G.map (colimit.ι F j)) := by

  -- 已知想使用的引理，甚至是simp引理，但`rw`不允许应用
  fail_if_success rw [ι_preservesColimitIso_inv]
  fail_if_success rw [ι_preservesColimitIso_inv (G ⋙ H)]
  fail_if_success simp only [ι_preservesColimitIso_inv]

  -- 这会有效：
  -- erw [ι_preservesColimitIso_inv (G ⋙ H)]

  -- `check_compositions`检查是否存在滥用定义的组合，并提示定义性结合性问题。

  check_compositions

  -- 此处可通过重新结合目标来“修复”，但通常应回溯检查问题根源。
  dsimp only [Functor.assoc]

  -- 此时可应用`rw`，但`simp`同样有效。
  -- rw [ι_preservesColimitIso_inv]

  simp
</code></pre></div> <h2 id=choose>choose<a class=headerlink href=#choose title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.Choose.choose</code></p> <ul> <li> <p><code>choose a b h h' using hyp</code> 接受形如 <code>∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b ∧ Q x y a b</code> 的假设 <code>hyp</code>，输出函数 <code>a : X → Y → A</code>、<code>b : X → Y → B</code> 及假设 <code>h : ∀ (x : X) (y : Y), P x y (a x y) (b x y)</code> 和 <code>h' : ∀ (x : X) (y : Y), Q x y (a x y) (b x y)</code>。支持依赖版本。</p> </li> <li> <p><code>choose! a b h h' using hyp</code> 类似，但尽可能移除函数对命题参数的依赖。例如若 <code>Y</code> 为命题且 <code>A</code>、<code>B</code> 非空，则得到 <code>a : X → A</code>、<code>b : X → B</code> 及假设 <code>h : ∀ (x : X) (y : Y), P x y (a x) (b x)</code> 和 <code>h' : ∀ (x : X) (y : Y), Q x y (a x) (b x)</code>。</p> </li> </ul> <p>可省略 <code>using hyp</code>，此时 <code>choose</code> 会以 <code>intro hyp</code> 开始。</p> <p>示例：</p> <div class=highlight><pre><span></span><code>example (h : ∀ n m : ℕ, ∃ i j, m = n + i ∨ m + j = n) : True := by
  choose i j h using h
  guard_hyp i : ℕ → ℕ → ℕ
  guard_hyp j : ℕ → ℕ → ℕ
  guard_hyp h : ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n
  trivial
</code></pre></div> <div class=highlight><pre><span></span><code>example (h : ∀ i : ℕ, i &lt; 7 → ∃ j, i &lt; j ∧ j &lt; i+i) : True := by
  choose! f h h&#39; using h
  guard_hyp f : ℕ → ℕ
  guard_hyp h : ∀ (i : ℕ), i &lt; 7 → i &lt; f i
  guard_hyp h&#39; : ∀ (i : ℕ), i &lt; 7 → f i &lt; i + i
  trivial
</code></pre></div> <h2 id=choose_1>choose!<a class=headerlink href=#choose_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.Choose.tacticChoose!___Using_</code></p> <ul> <li> <p><code>choose a b h h' using hyp</code> 接受形如 <code>∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b ∧ Q x y a b</code> 的假设 <code>hyp</code>，输出函数 <code>a : X → Y → A</code>、<code>b : X → Y → B</code> 及假设 <code>h : ∀ (x : X) (y : Y), P x y (a x y) (b x y)</code> 和 <code>h' : ∀ (x : X) (y : Y), Q x y (a x y) (b x y)</code>。支持依赖版本。</p> </li> <li> <p><code>choose! a b h h' using hyp</code> 类似，但尽可能移除函数对命题参数的依赖。例如若 <code>Y</code> 为命题且 <code>A</code>、<code>B</code> 非空，则得到 <code>a : X → A</code>、<code>b : X → B</code> 及假设 <code>h : ∀ (x : X) (y : Y), P x y (a x) (b x)</code> 和 <code>h' : ∀ (x : X) (y : Y), Q x y (a x) (b x)</code>。</p> </li> </ul> <p>可省略 <code>using hyp</code>，此时 <code>choose</code> 会以 <code>intro hyp</code> 开始。</p> <p>示例：</p> <div class=highlight><pre><span></span><code>example (h : ∀ n m : ℕ, ∃ i j, m = n + i ∨ m + j = n) : True := by
  choose i j h using h
  guard_hyp i : ℕ → ℕ → ℕ
  guard_hyp j : ℕ → ℕ → ℕ
  guard_hyp h : ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n
  trivial
</code></pre></div> <div class=highlight><pre><span></span><code>example (h : ∀ i : ℕ, i &lt; 7 → ∃ j, i &lt; j ∧ j &lt; i+i) : True := by
  choose! f h h&#39; using h
  guard_hyp f : ℕ → ℕ
  guard_hyp h : ∀ (i : ℕ), i &lt; 7 → i &lt; f i
  guard_hyp h&#39; : ∀ (i : ℕ), i &lt; 7 → f i &lt; i + i
  trivial
</code></pre></div> <h2 id=classical>classical<a class=headerlink href=#classical title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.classical</code></p> <p><code>classical tacs</code> 在 <code>Classical.propDecidable</code> 作为低优先级局部实例的范围内运行 <code>tacs</code>。</p> <p>注意，<code>classical</code> 是一个作用域策略：它仅在策略的作用域内添加该实例。</p> <h2 id=clean>clean<a class=headerlink href=#clean title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.tacticClean_</code></p> <p>（已弃用）<code>clean t</code> 是 <code>exact clean% t</code> 的宏。</p> <h2 id=clean_wf>clean_wf<a class=headerlink href=#clean_wf title="Permanent link">&para;</a></h2> <p>定义于：<code>tacticClean_wf</code></p> <p>此策略由 Lean 内部在通过 <code>decreasing_by</code> 向用户展示良基定义产生的证明义务之前使用。无需手动使用此策略。</p> <h2 id=clear>clear<a class=headerlink href=#clear title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Elab.Tactic.clearExcept</code></p> <p>清除所有可清除的假设，除了减号后提供的那些。示例： <div class=highlight><pre><span></span><code><span class=w>  </span><span class=n>clear</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=bp>-</span><span class=w> </span><span class=n>h₁</span><span class=w> </span><span class=n>h₂</span>
</code></pre></div></p> <h2 id=clear_1>clear<a class=headerlink href=#clear_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.clear</code></p> <p><code>clear x...</code> 移除给定假设，若假设仍被引用则失败。</p> <h2 id=clear_2>clear!<a class=headerlink href=#clear_2 title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.clear!</code></p> <p><code>clear</code> 的变体，不仅清除给定假设，还清除依赖它们的其他假设。</p> <h2 id=clear_>clear_<a class=headerlink href=#clear_ title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.clear_</code></p> <p>清除所有以下划线开头的假设，如 <code>_match</code> 和 <code>_let_match</code>。</p> <h2 id=clear_aux_decl>clear_aux_decl<a class=headerlink href=#clear_aux_decl title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.clearAuxDecl</code></p> <p>此策略清除上下文中的所有辅助声明。</p> <h2 id=clear_value>clear_value<a class=headerlink href=#clear_value title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.clearValue</code></p> <p><code>clear_value n₁ n₂ ...</code> 清除局部定义 <code>n₁, n₂ ...</code> 的主体，将其变为普通假设。假设 <code>n : α := t</code> 将变为 <code>n : α</code>。</p> <p><code>n₁ n₂ ...</code> 的顺序无关紧要，值将按其在上下文中出现的逆序清除。</p> <h2 id=coherence>coherence<a class=headerlink href=#coherence title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.Coherence.coherence</code></p> <p>使用幺半范畴的连贯定理解决幺半方程，其中两边仅通过用具有相同源和目标的幺半结构态射（即结合子、单位子和恒等态射）的不同字符串替换来区分。</p> <p>即，<code>coherence</code> 可处理形式为 <code>a ≫ f ≫ b ≫ g ≫ c = a' ≫ f ≫ b' ≫ g ≫ c'</code> 的目标，其中 <code>a = a'</code>、<code>b = b'</code> 和 <code>c = c'</code> 可使用 <code>pure_coherence</code> 证明。</p> <p>（若 <code>coherence</code> 在处理大方程时意外失败，可能需要增加类型类搜索深度，如使用 <code>set_option synthInstance.maxSize 500</code>。）</p> <h2 id=compareoflessandeq_rfl>compareOfLessAndEq_rfl<a class=headerlink href=#compareoflessandeq_rfl title="Permanent link">&para;</a></h2> <p>定义于：<code>tacticCompareOfLessAndEq_rfl</code></p> <p>此策略尝试通过引入参数并按以下顺序应用方法，证明给定的 <code>compare</code> 实例等于 <code>compareOfLessAndEq</code>：</p> <ol> <li>检查 <code>rfl</code> 是否有效。</li> <li>检查当前的 <code>compare</code> 是否本质上是 <code>compareOfLessAndEq</code>，但因隐式参数需要展开定义并拆分 <code>compareOfLessAndEq</code> 中的 <code>if</code>。</li> <li>若无法拆分参数，则尝试通过案例分析参数，让定义自行解决（适用于 <code>compare</code> 通过 <code>match</code> 语句定义的情况，如 <code>Bool</code>）。</li> </ol> <h2 id=compute_degree>compute_degree<a class=headerlink href=#compute_degree title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.ComputeDegree.computeDegree</code></p> <p><code>compute_degree</code> 是解决以下形式目标的策略： * <code>natDegree f = d</code> * <code>degree f = d</code> * <code>natDegree f ≤ d</code> * <code>degree f ≤ d</code> * <code>coeff f d = r</code>（若 <code>d</code> 为 <code>f</code> 的次数）</p> <p>该策略可能留下形式为 <code>d' = d</code>、<code>d' ≤ d</code> 或 <code>r ≠ 0</code> 的子目标，其中 <code>d'</code> 为策略猜测的次数（<code>ℕ</code> 或 <code>WithBot ℕ</code>），<code>r</code> 为猜测的 <code>f</code> 的首项系数。</p> <p><code>compute_degree</code> 对所有子目标的左侧应用 <code>norm_num</code>，尝试关闭它们。</p> <p>变体 <code>compute_degree!</code> 首先应用 <code>compute_degree</code>，然后在剩余目标上使用 <code>norm_num</code> 并尝试 <code>assumption</code>。</p> <h2 id=compute_degree_1>compute_degree!<a class=headerlink href=#compute_degree_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.ComputeDegree.tacticCompute_degree!</code></p> <p><code>compute_degree</code> 是解决以下形式目标的策略： * <code>natDegree f = d</code> * <code>degree f = d</code> * <code>natDegree f ≤ d</code> * <code>degree f ≤ d</code> * <code>coeff f d = r</code>（若 <code>d</code> 为 <code>f</code> 的次数）</p> <p>该策略可能留下形式为 <code>d' = d</code>、<code>d' ≤ d</code> 或 <code>r ≠ 0</code> 的子目标，其中 <code>d'</code> 为策略猜测的次数（<code>ℕ</code> 或 <code>WithBot ℕ</code>），<code>r</code> 为猜测的 <code>f</code> 的首项系数。</p> <p><code>compute_degree</code> 对所有子目标的左侧应用 <code>norm_num</code>，尝试关闭它们。</p> <p>变体 <code>compute_degree!</code> 首先应用 <code>compute_degree</code>，然后在剩余目标上使用 <code>norm_num</code> 并尝试 <code>assumption</code>。</p> <h2 id=congr>congr<a class=headerlink href=#congr title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.congr</code></p> <p>对形如 <code>⊢ f as = f bs</code> 和 <code>⊢ HEq (f as) (f bs)</code> 的目标应用同余（递归）。可选参数为递归应用的深度。当 <code>congr</code> 分解目标过于激进时，此参数有用。例如，给定 <code>⊢ f (g (x + y)) = f (g (y + x))</code>，<code>congr</code> 产生目标 <code>⊢ x = y</code> 和 <code>⊢ y = x</code>，而 <code>congr 2</code> 产生预期的 <code>⊢ x + y = y + x</code>。</p> <h2 id=congr_1>congr<a class=headerlink href=#congr_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Batteries.Tactic.congrConfigWith</code></p> <p>对形如 <code>⊢ f as = f bs</code> 和 <code>⊢ HEq (f as) (f bs)</code> 的目标应用同余（递归）。 * <code>congr n</code> 控制递归应用的深度。当 <code>congr</code> 分解目标过于激进时，此参数有用。例如，给定 <code>⊢ f (g (x + y)) = f (g (y + x))</code>，<code>congr</code> 产生目标 <code>⊢ x = y</code> 和 <code>⊢ y = x</code>，而 <code>congr 2</code> 产生预期的 <code>⊢ x + y = y + x</code>。 * 若在任何时候子目标匹配假设，则该子目标将被关闭。 * 可使用 <code>congr with p (: n)?</code> 调用 <code>ext p (: n)?</code> 到所有由 <code>congr</code> 生成的子目标。例如，若目标为 <code>⊢ f '' s = g '' s</code>，则 <code>congr with x</code> 生成目标 <code>x : α ⊢ f x = g x</code>。</p> <h2 id=congr_2>congr<a class=headerlink href=#congr_2 title="Permanent link">&para;</a></h2> <p>定义于：<code>Batteries.Tactic.congrConfig</code></p> <p>对形如 <code>⊢ f as = f bs</code> 和 <code>⊢ HEq (f as) (f bs)</code> 的目标应用同余（递归）。可选参数为递归应用的深度。当 <code>congr</code> 分解目标过于激进时，此参数有用。例如，给定 <code>⊢ f (g (x + y)) = f (g (y + x))</code>，<code>congr</code> 产生目标 <code>⊢ x = y</code> 和 <code>⊢ y = x</code>，而 <code>congr 2</code> 产生预期的 <code>⊢ x + y = y + x</code>。</p> <h2 id=congr_3>congr!<a class=headerlink href=#congr_3 title="Permanent link">&para;</a></h2> <p>定义于：<code>Congr!.congr!</code></p> <p>通过递归应用同余引理，将目标的左侧部分等同于右侧对应部分。例如，对于 <code>⊢ f as = g bs</code>，可能得到两个目标 <code>⊢ f = g</code> 和 <code>⊢ as = bs</code>。</p> <p>语法： <div class=highlight><pre><span></span><code><span class=n>congr</span><span class=bp>!</span>
<span class=n>congr</span><span class=bp>!</span><span class=w> </span><span class=n>n</span>
<span class=n>congr</span><span class=bp>!</span><span class=w> </span><span class=k>with</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=n>z</span>
<span class=n>congr</span><span class=bp>!</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=k>with</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=n>z</span>
</code></pre></div> 其中，<code>n</code> 为自然数，<code>x</code>、<code>y</code>、<code>z</code> 为 <code>rintro</code> 模式（如 <code>h</code>、<code>rfl</code>、<code>⟨x, y⟩</code>、<code>_</code>、<code>-</code>、<code>(h | h)</code> 等）。</p> <p><code>congr!</code> 策略类似于 <code>congr</code>，但在尝试将目标左侧等同于右侧时更为坚持。以下是其可能尝试的方法：</p> <ul> <li> <p>若目标 <code>⊢ R x y</code> 中的 <code>R</code> 为自反关系，则在可能的情况下将目标转换为 <code>⊢ x = y</code>。自反关系列表通过 <code>@[refl]</code> 属性维护。作为特例，<code>⊢ p ↔ q</code> 在同余处理期间转换为 <code>⊢ p = q</code>，并在最后恢复为 <code>⊢ p ↔ q</code>。</p> </li> <li> <p>若有用户同余引理与目标关联（例如，应用 <code>@[congr]</code> 标记的引理至 <code>⊢ List.map f xs = List.map g ys</code>），则使用该引理。</p> </li> <li> <p>使用至少与 <code>congr</code> 和 <code>simp</code> 同等的同余引理生成器。若有子表达式可通过 <code>simp</code> 重写，则 <code>congr!</code> 应能为其生成等式。</p> </li> <li> <p>可使用如 <code>implies_congr</code> 和 <code>pi_congr</code> 的引理进行 Pi 类型的同余。</p> </li> <li> <p>在应用同余前，自动运行 <code>intros</code> 策略。引入的变量可通过 <code>with</code> 子句命名，有助于同余引理在假设中提供额外条件时使用。</p> </li> <li> <p>当函数间存在等式时，只要至少有一个明显为 lambda，应用 <code>funext</code> 或 <code>Function.hfunext</code>，允许 lambda 体的同余。</p> </li> <li> <p>尝试通过几种策略关闭目标，包括检查定义等式、应用 <code>Subsingleton.elim</code> 或 <code>proof_irrel_heq</code>，以及使用 <code>assumption</code> 策略。</p> </li> </ul> <p>可选参数是递归应用的深度。这在<code>congr!</code>过于激进地分解目标时非常有用。例如，给定<code>⊢ f (g (x + y)) = f (g (y + x))</code>，<code>congr!</code>会生成目标<code>⊢ x = y</code>和<code>⊢ y = x</code>，而<code>congr! 2</code>则生成预期的<code>⊢ x + y = y + x</code>。</p> <p><code>congr!</code>策略还接受配置选项，例如： <div class=highlight><pre><span></span><code><span class=n>congr</span><span class=bp>!</span><span class=w> </span><span class=o>(</span><span class=n>config</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=o>{</span><span class=n>transparency</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=bp>.</span><span class=n>default</span><span class=o>})</span><span class=w> </span><span class=mi>2</span>
</code></pre></div> 这会覆盖默认设置，即在可约透明度下应用协变引理。</p> <p><code>congr!</code>策略在等式两边非常积极。有一个预定义配置使用不同的策略： 尝试 <div class=highlight><pre><span></span><code><span class=n>congr</span><span class=bp>!</span><span class=w> </span><span class=o>(</span><span class=n>config</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=bp>.</span><span class=n>unfoldSameFun</span><span class=o>)</span>
</code></pre></div> 这仅允许在定义上相等的函数应用之间进行协变，并在默认透明度（而非仅可约透明度）下应用协变引理。这类似于<code>congr</code>。</p> <p>有关所有选项，请参见<code>Congr!.Config</code>。</p> <h2 id=congrm>congrm<a class=headerlink href=#congrm title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.congrM</code></p> <p><code>congrm e</code>是用于证明形如<code>lhs = rhs</code>、<code>lhs ↔ rhs</code>、<code>HEq lhs rhs</code>或当<code>R</code>是自反关系时的<code>R lhs rhs</code>目标的策略。表达式<code>e</code>是一个包含占位符<code>?_</code>的模式，此模式会同时与<code>lhs</code>和<code>rhs</code>匹配。这些占位符生成新的目标，声明<code>lhs</code>和<code>rhs</code>中的对应子表达式相等。如果占位符有名称（如<code>?m</code>），则新目标将带有这些名称的标签。</p> <p>示例： <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>{</span><span class=n>a</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=n>d</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℕ</span><span class=o>}</span><span class=w> </span><span class=o>:</span>
<span class=w>    </span><span class=n>Nat.pred</span><span class=w> </span><span class=n>a.succ</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=o>(</span><span class=n>d</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=o>(</span><span class=n>c</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>a.pred</span><span class=o>))</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>Nat.pred</span><span class=w> </span><span class=n>b.succ</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=o>(</span><span class=n>b</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=o>(</span><span class=n>c</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>d.pred</span><span class=o>))</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>congrm</span><span class=w> </span><span class=n>Nat.pred</span><span class=w> </span><span class=o>(</span><span class=n>Nat.succ</span><span class=w> </span><span class=bp>?</span><span class=n>h1</span><span class=o>)</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=o>(</span><span class=bp>?</span><span class=n>h2</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=bp>?</span><span class=n>h3</span><span class=o>)</span>
<span class=w>  </span><span class=c>/-</span><span class=cm> 剩余目标：</span>
<span class=cm>  case h1 ⊢ a = b</span>
<span class=cm>  case h2 ⊢ d = b</span>
<span class=cm>  case h3 ⊢ c + a.pred = c + d.pred</span>
<span class=cm>  -/</span>
<span class=w>  </span><span class=gr>sorry</span>
<span class=w>  </span><span class=gr>sorry</span>
<span class=w>  </span><span class=gr>sorry</span>

<span class=kd>example</span><span class=w> </span><span class=o>{</span><span class=n>a</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℕ</span><span class=o>}</span><span class=w> </span><span class=o>(</span><span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>b</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=o>(</span><span class=k>fun</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℕ</span><span class=w> </span><span class=bp>=&gt;</span><span class=w> </span><span class=bp>∀</span><span class=w> </span><span class=n>z</span><span class=o>,</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>z</span><span class=o>)</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=o>(</span><span class=k>fun</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>=&gt;</span><span class=w> </span><span class=bp>∀</span><span class=w> </span><span class=n>z</span><span class=o>,</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>z</span><span class=o>)</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>congrm</span><span class=w> </span><span class=k>fun</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>=&gt;</span><span class=w> </span><span class=bp>∀</span><span class=w> </span><span class=n>w</span><span class=o>,</span><span class=w> </span><span class=bp>?</span><span class=n>_</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>w</span>
<span class=w>  </span><span class=c1>-- ⊢ a = b</span>
<span class=w>  </span><span class=n>exact</span><span class=w> </span><span class=n>h</span>
</code></pre></div></p> <p><code>congrm</code>命令是<code>congr(...)</code>协变引用的便捷前端。如果目标是等式，<code>congrm e</code>等价于<code>refine congr(e')</code>，其中<code>e'</code>通过将每个占位符<code>?m</code>替换为<code>$(?m)</code>构建而成。模式<code>e</code>允许包含<code>$(...)</code>表达式，以便像协变引用一样立即将等式证明代入协变。</p> <h2 id=congrm_1>congrm?<a class=headerlink href=#congrm_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>tacticCongrm?</code></p> <p>显示一个小部件面板，允许通过选择目标中的子表达式生成带有指定孔的<code>congrm</code>调用。</p> <h2 id=constructor>constructor<a class=headerlink href=#constructor title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.constructor</code></p> <p>如果主目标的目标类型是归纳类型，<code>constructor</code>使用第一个匹配的构造函数解决它，否则失败。</p> <h2 id=constructorm>constructorm<a class=headerlink href=#constructorm title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.constructorM</code></p> <ul> <li><code>constructorm p_1, ..., p_n</code>将<code>constructor</code>策略应用于主目标，如果<code>type</code>匹配任一给定模式。</li> <li><code>constructorm* p</code>是<code>· repeat constructorm p</code>的更高效紧凑版本。由于模式仅编译一次，因此更高效。</li> </ul> <p>示例：以下策略证明了任何由和/或/真构成的定理，如<code>True ∧ (True ∨ True)</code>： <div class=highlight><pre><span></span><code><span class=n>constructorm</span><span class=bp>*</span><span class=w> </span><span class=n>_</span><span class=w> </span><span class=bp>∨</span><span class=w> </span><span class=n>_</span><span class=o>,</span><span class=w> </span><span class=n>_</span><span class=w> </span><span class=bp>∧</span><span class=w> </span><span class=n>_</span><span class=o>,</span><span class=w> </span><span class=n>True</span>
</code></pre></div></p> <h2 id=continuity>continuity<a class=headerlink href=#continuity title="Permanent link">&para;</a></h2> <p>定义于：<code>tacticContinuity</code></p> <p><code>continuity</code>策略通过应用带有<code>continuity</code>用户属性的引理来解决形如<code>Continuous f</code>的目标。</p> <h2 id=continuity_1>continuity?<a class=headerlink href=#continuity_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>tacticContinuity?</code></p> <p><code>continuity</code>策略通过应用带有<code>continuity</code>用户属性的引理来解决形如<code>Continuous f</code>的目标。</p> <h2 id=contradiction>contradiction<a class=headerlink href=#contradiction title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.contradiction</code></p> <p>如果假设“显然矛盾”，<code>contradiction</code>将关闭主目标。</p> <ul> <li>无适用构造函数的归纳类型/族 <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>False</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>p</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span><span class=w> </span><span class=n>contradiction</span>
</code></pre></div></li> <li>构造函数的注入性 <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>none</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>some</span><span class=w> </span><span class=n>true</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>p</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span><span class=w> </span><span class=n>contradiction</span><span class=w>  </span><span class=c1>--</span>
</code></pre></div></li> <li>可判定的假命题 <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=mi>3</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>p</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span><span class=w> </span><span class=n>contradiction</span>
</code></pre></div></li> <li>矛盾的假设 <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>p</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>h&#39;</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=bp>¬</span><span class=w> </span><span class=n>p</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>q</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span><span class=w> </span><span class=n>contradiction</span>
</code></pre></div></li> <li>其他简单矛盾，如 <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>x</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Nat</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>≠</span><span class=w> </span><span class=n>x</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>p</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span><span class=w> </span><span class=n>contradiction</span>
</code></pre></div></li> </ul> <h2 id=contrapose>contrapose<a class=headerlink href=#contrapose title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.Contrapose.contrapose</code></p> <p>将目标转换为其逆否命题。 * <code>contrapose</code> 将目标<code>P → Q</code>转换为<code>¬ Q → ¬ P</code> * <code>contrapose h</code> 首先还原局部假设<code>h</code>，然后使用<code>contrapose</code>和<code>intro h</code> * <code>contrapose h with new_h</code>使用名称<code>new_h</code>引入假设</p> <h2 id=contrapose_1>contrapose!<a class=headerlink href=#contrapose_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.Contrapose.contrapose!</code></p> <p>将目标转换为其逆否命题，并将否定推入<code>P</code>和<code>Q</code>内部。用法与<code>contrapose</code>相同。</p> <h2 id=conv>conv<a class=headerlink href=#conv title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.Conv.conv</code></p> <p><code>conv =&gt; ...</code>允许用户通过聚焦特定子表达式，在目标或假设上执行针对性重写。</p> <p>详见<a href=https://lean-lang.org/theorem_proving_in_lean4/conv.html>https://lean-lang.org/theorem_proving_in_lean4/conv.html</a>。</p> <p>基本形式： * <code>conv =&gt; cs</code>将用转换策略<code>cs</code>重写目标。 * <code>conv at h =&gt; cs</code>将重写假设<code>h</code>。 * <code>conv in pat =&gt; cs</code>将重写第一个匹配<code>pat</code>的子表达式（参见<code>pattern</code>）。</p> <h2 id=conv_1>conv'<a class=headerlink href=#conv_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.Conv.convTactic</code></p> <p>执行给定的转换块，而不将常规目标转换为<code>conv</code>目标。</p> <h2 id=conv_2>conv?<a class=headerlink href=#conv_2 title="Permanent link">&para;</a></h2> <p>定义于：<code>tacticConv?</code></p> <p>显示一个小部件面板，允许生成聚焦到目标中选定子表达式的<code>conv</code>调用。</p> <h2 id=conv_lhs>conv_lhs<a class=headerlink href=#conv_lhs title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.Conv.convLHS</code></p> <h2 id=conv_rhs>conv_rhs<a class=headerlink href=#conv_rhs title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.Conv.convRHS</code></p> <h2 id=convert>convert<a class=headerlink href=#convert title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.convert</code></p> <p><code>exact e</code>和<code>refine e</code>策略需要类型与目标定义上相等的项<code>e</code>。<code>convert e</code>类似于<code>refine e</code>，但<code>e</code>的类型不需要完全匹配目标。相反，使用与<code>congr!</code>策略相同的策略为<code>e</code>的类型与目标之间的差异创建新目标。例如，在证明状态</p> <div class=highlight><pre><span></span><code><span class=n>n</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℕ</span><span class=o>,</span>
<span class=n>e</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Prime</span><span class=w> </span><span class=o>(</span><span class=mi>2</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>1</span><span class=o>)</span>
<span class=bp>⊢</span><span class=w> </span><span class=n>Prime</span><span class=w> </span><span class=o>(</span><span class=n>n</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>1</span><span class=o>)</span>
</code></pre></div> <p>中，策略<code>convert e using 2</code>将目标更改为</p> <div class=highlight><pre><span></span><code><span class=bp>⊢</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=n>n</span>
</code></pre></div> <p>在此示例中，新目标可使用<code>ring</code>解决。</p> <p><code>using 2</code>表示应迭代协变算法最多两次，而<code>convert e</code>将使用无限制的迭代次数，导致两个不可能的目标：<code>⊢ HAdd.hAdd = HMul.hMul</code>和<code>⊢ n = 2</code>。</p> <p>一种变体配置是<code>convert (config := .unfoldSameFun) e</code>，它仅对同一函数的函数应用等式化（同时在更高的<code>default</code>透明度下进行）。这在不需要<code>using 2</code>的情况下给出相同目标<code>⊢ n + n = 2 * n</code>。</p> <p><code>convert</code>策略在简化之前急切地应用协变引理，因此在<code>exact</code>成功的情况下可能失败： <div class=highlight><pre><span></span><code><span class=kd>def</span><span class=w> </span><span class=n>p</span><span class=w> </span><span class=o>(</span><span class=n>n</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℕ</span><span class=o>)</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=n>True</span>
<span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>p</span><span class=w> </span><span class=mi>0</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>p</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span><span class=w> </span><span class=n>exact</span><span class=w> </span><span class=n>h</span><span class=w> </span><span class=c1>-- 成功</span>
<span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>p</span><span class=w> </span><span class=mi>0</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>p</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span><span class=w> </span><span class=n>convert</span><span class=w> </span><span class=n>h</span><span class=w> </span><span class=c1>-- 失败，剩余目标`1 = 0`</span>
</code></pre></div> 限制递归深度可以帮助解决此问题。例如，在此情况下<code>convert h using 1</code>将有效。</p> <p>语法<code>convert ← e</code>将反转新目标的方向（在此示例中生成<code>⊢ 2 * n = n + n</code>）。</p> <p>内部上，<code>convert e</code>通过创建一个断言目标等于<code>e</code>类型的新目标，然后使用<code>congr!</code>简化它。语法<code>convert e using n</code>可用于控制匹配深度（如<code>congr! n</code>）。在示例中，<code>convert e using 1</code>将生成新目标<code>⊢ n + n + 1 = 2 * n + 1</code>。</p> <p>有关协变操作，请参考<code>congr!</code>策略。其众多功能之一是，如果<code>x y : t</code>且作用域中有实例<code>Subsingleton t</code>，则任何形如<code>x = y</code>的目标将自动解决。</p> <p>与<code>congr!</code>类似，<code>convert</code>接受可选的<code>with</code>子句（<code>rintro</code>模式），例如<code>convert e using n with x y z</code>。</p> <p><code>convert</code>策略还接受配置选项，例如 <div class=highlight><pre><span></span><code><span class=n>convert</span><span class=w> </span><span class=o>(</span><span class=n>config</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=o>{</span><span class=n>transparency</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=bp>.</span><span class=n>default</span><span class=o>})</span><span class=w> </span><span class=n>h</span>
</code></pre></div> 这些选项传递给<code>congr!</code>。有关选项，请参见<code>Congr!.Config</code>。</p> <h2 id=convert_to>convert_to<a class=headerlink href=#convert_to title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.convertTo</code></p> <p><code>convert_to</code> 策略用于改变目标或局部假设的类型，但与<code>change</code>策略不同，它会通过<code>congr!</code>生成等式证明义务来解决差异。</p> <ul> <li><code>convert_to ty</code> 将目标改为<code>ty</code></li> <li><code>convert_to ty using n</code> 使用<code>congr! n</code>而非<code>congr! 1</code></li> <li><code>convert_to ty at h</code> 将局部假设<code>h</code>的类型改为<code>ty</code>。剩余的<code>congr!</code>目标会优先处理。</li> </ul> <p>作用于目标时，策略<code>convert_to ty using n</code>等同于<code>convert (?_ : ty) using n</code>。区别在于<code>convert_to</code>接受类型而<code>convert</code>接受证明项。</p> <p>除了能够操作局部假设外，<code>convert_to</code>的语法与<code>convert</code>相同，并具有如<code>convert_to ← g</code>和<code>convert_to (config := {transparency := .default}) g</code>等变体。</p> <p>注意，<code>convert_to ty at h</code>可能会保留<code>h</code>的副本，如果后续的局部假设或目标依赖于它，这与<code>rw</code>或<code>simp</code>中的情况类似。</p> <h2 id=count_heartbeats_2>count_heartbeats<a class=headerlink href=#count_heartbeats_2 title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.CountHeartbeats.tacticCount_heartbeats</code></p> <p>自“2025-01-12”起，<code>count_heartbeats</code>已弃用，推荐使用<code>#count_heartbeats</code></p> <h2 id=dbg_trace>dbg_trace<a class=headerlink href=#dbg_trace title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.dbgTrace</code></p> <p><code>dbg_trace "foo"</code>在代码被详细阐述时打印<code>foo</code>。对调试策略控制流很有用： <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>False</span><span class=w> </span><span class=bp>∨</span><span class=w> </span><span class=n>True</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>first</span>
<span class=w>  </span><span class=bp>|</span><span class=w> </span><span class=n>apply</span><span class=w> </span><span class=n>Or.inl</span><span class=bp>;</span><span class=w> </span><span class=n>trivial</span><span class=bp>;</span><span class=w> </span><span class=n>dbg_trace</span><span class=w> </span><span class=s2>&quot;left&quot;</span>
<span class=w>  </span><span class=bp>|</span><span class=w> </span><span class=n>apply</span><span class=w> </span><span class=n>Or.inr</span><span class=bp>;</span><span class=w> </span><span class=n>trivial</span><span class=bp>;</span><span class=w> </span><span class=n>dbg_trace</span><span class=w> </span><span class=s2>&quot;right&quot;</span>
</code></pre></div></p> <h2 id=decide>decide<a class=headerlink href=#decide title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.decide</code></p> <p><code>decide</code>尝试通过合成一个<code>Decidable p</code>的实例并缩减该实例以评估<code>p</code>的真值来证明主目标（目标类型为<code>p</code>）。若缩减为<code>isTrue h</code>，则<code>h</code>即为关闭目标的<code>p</code>的证明。</p> <p>目标中不允许包含局部变量或元变量。若存在局部变量，可先使用<code>revert</code>策略将这些局部变量移至目标中，或使用<code>+revert</code>选项（见下文）。</p> <p>选项： - <code>decide +revert</code>首先还原目标依赖的局部变量，并清理无关变量的局部上下文。若变量出现在目标中、相关变量中，或作为涉及相关变量的命题，则视为*相关*。 - <code>decide +kernel</code>使用内核而非详细阐述器进行缩减。其关键特性为：(1) 因使用内核，故忽略透明度并可展开所有内容；(2) 仅缩减<code>Decidable</code>实例一次而非两次。 - <code>decide +native</code>使用原生代码编译器（<code>#eval</code>）评估<code>Decidable</code>实例，通过<code>Lean.ofReduceBool</code>公理接受结果。此方式可能比缩减更高效，但代价是增大可信代码库规模。即，其依赖于Lean编译器及所有带<code>@[implemented_by]</code>属性的定义的正确性。与<code>+kernel</code>类似，<code>Decidable</code>实例仅评估一次。</p> <p>限制：在默认模式或<code>+kernel</code>模式下，由于<code>decide</code>使用缩减评估项，基于良基递归定义的<code>Decidable</code>实例可能无效，因其评估需要缩减证明。缩减也可能在处理含<code>Eq.rec</code>项的<code>Decidable</code>实例时卡住。这些项可能出现在使用策略（如<code>rw</code>和<code>simp</code>）定义的实例中。为避免此问题，请使用如<code>decidable_of_iff</code>等定义来创建此类实例。</p> <p>示例：</p> <p>证明不等式： <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=bp>≠</span><span class=w> </span><span class=mi>5</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span><span class=w> </span><span class=n>decide</span>
</code></pre></div></p> <p>尝试证明错误命题： <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=bp>≠</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span><span class=w> </span><span class=n>decide</span>
<span class=c>/-</span>
<span class=cm>策略 &#39;decide&#39; 证明命题</span>
<span class=cm>  1 ≠ 1</span>
<span class=cm>为假</span>
<span class=cm>-/</span>
</code></pre></div></p> <p>尝试证明<code>Decidable</code>实例未能缩减的命题： <div class=highlight><pre><span></span><code><span class=n>opaque</span><span class=w> </span><span class=n>unknownProp</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=kt>Prop</span>

<span class=kn>open</span><span class=w> </span><span class=n>scoped</span><span class=w> </span><span class=n>Classical</span><span class=w> </span><span class=k>in</span>
<span class=kd>example</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>unknownProp</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span><span class=w> </span><span class=n>decide</span>
<span class=c>/-</span>
<span class=cm>策略 &#39;decide&#39; 对命题</span>
<span class=cm>  unknownProp</span>
<span class=cm>失败，因其 &#39;Decidable&#39; 实例缩减为</span>
<span class=cm>  Classical.choice ⋯</span>
<span class=cm>而非 &#39;isTrue&#39; 构造子。</span>
<span class=cm>-/</span>
</code></pre></div></p> <h2 id=_11>性质与关系<a class=headerlink href=#_11 title="Permanent link">&para;</a></h2> <p>对于具有可判定相等性的类型的等式目标，通常可用<code>rfl</code>替代<code>decide</code>。 <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span><span class=w> </span><span class=n>decide</span>
<span class=kd>example</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span><span class=w> </span><span class=n>rfl</span>
</code></pre></div></p> <h2 id=decreasing_tactic>decreasing_tactic<a class=headerlink href=#decreasing_tactic title="Permanent link">&para;</a></h2> <p>定义于：<code>tacticDecreasing_tactic</code></p> <p>默认情况下，<code>decreasing_tactic</code>在良基递归中被调用，以合成递归调用沿选定良基关系递减的证明。可通过在递归定义中使用<code>decreasing_by tac</code>局部覆盖，或通过添加更多<code>decreasing_tactic</code>（或调用此策略的<code>decreasing_trivial</code>）的定义全局扩展。</p> <h2 id=decreasing_trivial>decreasing_trivial<a class=headerlink href=#decreasing_trivial title="Permanent link">&para;</a></h2> <p>定义于：<code>tacticDecreasing_trivial</code></p> <p>可扩展的<code>decreasing_tactic</code>辅助策略。此策略处理应用字典序引理后的“基本情况”推理。可通过添加更多宏定义进行扩展，例如： <div class=highlight><pre><span></span><code><span class=n>macro_rules</span><span class=w> </span><span class=bp>|</span><span class=w> </span><span class=bp>`</span><span class=o>(</span><span class=n>tactic</span><span class=bp>|</span><span class=w> </span><span class=n>decreasing_trivial</span><span class=o>)</span><span class=w> </span><span class=bp>=&gt;</span><span class=w> </span><span class=bp>`</span><span class=o>(</span><span class=n>tactic</span><span class=bp>|</span><span class=w> </span><span class=n>linarith</span><span class=o>)</span>
</code></pre></div></p> <h2 id=decreasing_trivial_pre_omega>decreasing_trivial_pre_omega<a class=headerlink href=#decreasing_trivial_pre_omega title="Permanent link">&para;</a></h2> <p>定义于：<code>tacticDecreasing_trivial_pre_omega</code></p> <p><code>decreasing_trivial</code>的变体，不使用<code>omega</code>，旨在核心模块中<code>omega</code>不可用时使用。</p> <h2 id=decreasing_with>decreasing_with<a class=headerlink href=#decreasing_with title="Permanent link">&para;</a></h2> <p>定义于：<code>tacticDecreasing_with_</code></p> <p>通过简化后应用字典序引理，最后使用<code>ts</code>解决基本情况，构造沿良基关系递减的证明。若失败，则打印信息以帮助用户诊断非良基递归定义。</p> <h2 id=delta>delta<a class=headerlink href=#delta title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.delta</code></p> <p><code>delta id1 id2 ...</code>对定义<code>id1</code>, <code>id2</code>, ...进行delta展开。此为底层策略，将暴露Lean如何编译递归定义。</p> <h2 id=discrete_cases>discrete_cases<a class=headerlink href=#discrete_cases title="Permanent link">&para;</a></h2> <p>定义于：<code>CategoryTheory.Discrete.tacticDiscrete_cases</code></p> <p>对任何<code>Discrete α</code>假设执行<code>cases</code>的简单策略。</p> <h2 id=done>done<a class=headerlink href=#done title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.done</code></p> <p><code>done</code>在无剩余目标时成功。</p> <h2 id=dsimp>dsimp<a class=headerlink href=#dsimp title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.dsimp</code></p> <p><code>dsimp</code>策略为定义简化器。其类似于<code>simp</code>但仅应用通过自反性成立的定理。因此，结果保证与输入定义相等。</p> <h2 id=dsimp_1>dsimp!<a class=headerlink href=#dsimp_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.dsimpAutoUnfold</code></p> <p><code>dsimp!</code>为<code>dsimp</code>的简写，设置<code>autoUnfold := true</code>。这将用所有等式引理重写，可用于部分评估许多定义。</p> <h2 id=dsimp_2>dsimp?<a class=headerlink href=#dsimp_2 title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.dsimpTrace</code></p> <p><code>simp?</code>接受与<code>simp</code>相同的参数，但报告足以关闭目标的等效<code>simp only</code>调用。此有助于减少局部调用中的simp集大小以加速处理。 <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>x</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Nat</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=o>(</span><span class=k>if</span><span class=w> </span><span class=n>True</span><span class=w> </span><span class=k>then</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=mi>3</span><span class=o>)</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>simp</span><span class=bp>?</span><span class=w> </span><span class=c1>-- 输出 &quot;Try this: simp only [ite_true]&quot;</span>
</code></pre></div></p> <p>此命令也可用于<code>simp_all</code>和<code>dsimp</code>。</p> <h2 id=dsimp_3>dsimp?!<a class=headerlink href=#dsimp_3 title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.tacticDsimp?!_</code></p> <p><code>simp?</code>接受与<code>simp</code>相同的参数，但报告足以关闭目标的等效<code>simp only</code>调用。此有助于减少局部调用中的simp集大小以加速处理。 <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>x</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Nat</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=o>(</span><span class=k>if</span><span class=w> </span><span class=n>True</span><span class=w> </span><span class=k>then</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=mi>3</span><span class=o>)</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>simp</span><span class=bp>?</span><span class=w> </span><span class=c1>-- 输出 &quot;Try this: simp only [ite_true]&quot;</span>
</code></pre></div></p> <p>此命令也可用于<code>simp_all</code>和<code>dsimp</code>。</p> <h2 id=eapply>eapply<a class=headerlink href=#eapply title="Permanent link">&para;</a></h2> <p>定义于：<code>Batteries.Tactic.tacticEapply_</code></p> <p><code>eapply e</code>类似于<code>apply e</code>，但不会为出现在其他目标类型中的变量添加子目标。注意，这可能导致无剩余目标但项中仍有元变量的失败： <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=bp>∀</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Nat</span><span class=o>,</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>True</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>True</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>eapply</span><span class=w> </span><span class=n>h</span>
<span class=w>  </span><span class=n>rfl</span>
<span class=w>  </span><span class=c1>-- 无目标</span>
<span class=c1>-- (内核) 声明存在元变量 &#39;_example&#39;</span>
</code></pre></div></p> <h2 id=econstructor>econstructor<a class=headerlink href=#econstructor title="Permanent link">&para;</a></h2> <p>定义于：<code>tacticEconstructor</code></p> <p><code>econstructor</code>应用构造函数，但不会为出现在其他目标中的元变量添加新目标。此策略对存在量词目标特别有用。 <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=bp>∃</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Nat</span><span class=o>,</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>econstructor</span>
<span class=w>  </span><span class=n>exact</span><span class=w> </span><span class=mi>0</span>
<span class=w>  </span><span class=n>rfl</span>
</code></pre></div></p> <p><code>econstructor</code> 类似于 <code>constructor</code> （它使用归纳数据类型的第一个匹配构造器调用 <code>apply</code>） 但仅将非依赖前提作为新目标添加。</p> <h2 id=elementwise>elementwise<a class=headerlink href=#elementwise title="Permanent link">&para;</a></h2> <p>定义于：<code>Tactic.Elementwise.tacticElementwise___</code></p> <h2 id=elementwise_1>elementwise!<a class=headerlink href=#elementwise_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Tactic.Elementwise.tacticElementwise!___</code></p> <h2 id=else>else<a class=headerlink href=#else title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.tacDepIfThenElse</code></p> <p>在策略模式中，<code>if h : t then tac1 else tac2</code> 可作为以下语法的替代： <div class=highlight><pre><span></span><code><span class=n>by_cases</span><span class=w> </span><span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>t</span>
<span class=bp>·</span><span class=w> </span><span class=n>tac1</span>
<span class=bp>·</span><span class=w> </span><span class=n>tac2</span>
</code></pre></div> 它根据 <code>h : t</code> 或 <code>h : ¬t</code> 进行情况分析，<code>tac1</code> 和 <code>tac2</code> 为子证明。</p> <p>可使用 <code>?_</code> 或 <code>_</code> 延迟任一子证明至策略之后，但如果为 <code>tac1</code> 或 <code>tac2</code> 提供了策略序列，则要求该块结束时目标必须闭合。</p> <h2 id=else_1>else<a class=headerlink href=#else_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.tacIfThenElse</code></p> <p>在策略模式中，<code>if t then tac1 else tac2</code> 是以下语法的替代： <div class=highlight><pre><span></span><code><span class=n>by_cases</span><span class=w> </span><span class=n>t</span>
<span class=bp>·</span><span class=w> </span><span class=n>tac1</span>
<span class=bp>·</span><span class=w> </span><span class=n>tac2</span>
</code></pre></div> 它根据匿名假设 <code>h† : t</code> 或 <code>h† : ¬t</code> 进行情况分析，<code>tac1</code> 和 <code>tac2</code> 为子证明。（实际上未使用非依赖 <code>if</code>，因这不会向上下文中添加任何内容，故对定理证明无用。要实际插入 <code>ite</code> 应用，请使用 <code>refine if t then ?_ else ?_</code>。）</p> <h2 id=enat_to_nat>enat_to_nat<a class=headerlink href=#enat_to_nat title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.ENatToNat.tacticEnat_to_nat</code></p> <p><code>enat_to_nat</code> 将上下文中的所有 <code>ENat</code> 转换为 <code>Nat</code>，并重写相关命题。典型用例为 <code>enat_to_nat; omega</code>。</p> <h2 id=eq_refl>eq_refl<a class=headerlink href=#eq_refl title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.eqRefl</code></p> <p><code>eq_refl</code> 等效于 <code>exact rfl</code>，但进行了一些优化。</p> <h2 id=erw>erw<a class=headerlink href=#erw title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.tacticErw___</code></p> <p><code>erw [rules]</code> 是 <code>rw (transparency := .default) [rules]</code> 的简写。此操作通过常规定义展开进行重写（相比常规 <code>rw</code> 仅展开 <code>@[reducible]</code> 定义）。</p> <h2 id=erw_1>erw?<a class=headerlink href=#erw_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.Erw?.erw?</code></p> <p><code>erw? [r]</code> 调用 <code>erw [r]</code>（注意仅允许单步操作），随后尝试识别可能阻碍使用 <code>rw</code> 的子表达式。通过识别在可约透明度下定义等价但非完全等价的子表达式实现。</p> <h2 id=eta_expand>eta_expand<a class=headerlink href=#eta_expand title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.etaExpandStx</code></p> <p><code>eta_expand at loc</code> 对给定位置的所有子表达式进行 eta 展开。同时 beta 归约任何 eta 展开项的应用，故将其置于 eta 展开的“正规形式”。此策略亦存在于 <code>conv</code> 模式。</p> <p>例如，若 <code>f</code> 接受两个参数，则 <code>f</code> 变为 <code>fun x y =&gt; f x y</code>，而 <code>f x</code> 变为 <code>fun y =&gt; f x y</code>。</p> <p>此操作可用于将例如原始 <code>HAdd.hAdd</code> 转换为 <code>fun x y =&gt; x + y</code>。</p> <h2 id=eta_reduce>eta_reduce<a class=headerlink href=#eta_reduce title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.etaReduceStx</code></p> <p><code>eta_reduce at loc</code> 对给定位置的所有子表达式进行 eta 归约。此策略亦存在于 <code>conv</code> 模式。</p> <p>例如，<code>fun x y =&gt; f x y</code> 经 eta 归约后变为 <code>f</code>。</p> <h2 id=eta_struct>eta_struct<a class=headerlink href=#eta_struct title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.etaStructStx</code></p> <p><code>eta_struct at loc</code> 将结构构造器应用如 <code>S.mk x.1 ... x.n</code>（例如漂亮打印为 <code>{a := x.a, b := x.b, ...}</code>）转换为 <code>x</code>。此策略亦存在于 <code>conv</code> 模式。</p> <p>此转换称为结构的 eta 归约，生成定义相等的表达式。</p> <p>例如，给定 <code>x : α × β</code>，则 <code>(x.1, x.2)</code> 经此转换后变为 <code>x</code>。</p> <h2 id=exact>exact<a class=headerlink href=#exact title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.exact</code></p> <p><code>exact e</code> 在主目标类型与 <code>e</code> 的类型匹配时闭合该目标。</p> <h2 id=exact_1>exact?<a class=headerlink href=#exact_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.exact?</code></p> <p>在环境中搜索可通过 <code>exact</code> 结合 <code>solve_by_elim</code> 解决条件来闭合目标的定义或定理。</p> <p>可选 <code>using</code> 子句提供局部上下文中必须被 <code>exact?</code> 用于闭合目标的标识符。这在存在多种闭合目标方式且需指导使用特定引理时尤为有用。</p> <h2 id=exact_mod_cast>exact_mod_cast<a class=headerlink href=#exact_mod_cast title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.tacticExact_mod_cast_</code></p> <p>规范化目标及给定表达式中的强制转换，随后使用 <code>exact</code> 闭合目标。</p> <h2 id=exacts>exacts<a class=headerlink href=#exacts title="Permanent link">&para;</a></h2> <p>定义于：<code>Batteries.Tactic.exacts</code></p> <p>类似 <code>exact</code>，但接受一系列项并检查所有目标在策略后均已闭合。</p> <h2 id=exfalso>exfalso<a class=headerlink href=#exfalso title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.tacticExfalso</code></p> <p><code>exfalso</code> 通过应用 <code>False.elim</code> 将目标 <code>⊢ tgt</code> 转换为 <code>⊢ False</code>。</p> <h2 id=exists>exists<a class=headerlink href=#exists title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.«tacticExists_,,»</code></p> <p><code>exists e₁, e₂, ...</code> 是 <code>refine ⟨e₁, e₂, ...⟩; try trivial</code> 的简写，适用于存在目标。</p> <h2 id=existsi>existsi<a class=headerlink href=#existsi title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.«tacticExistsi_,,»</code></p> <p><code>existsi e₁, e₂, ⋯</code> 应用策略 <code>refine ⟨e₁, e₂, ⋯, ?_⟩</code>，其目的在于实例化存在量词。</p> <p>示例：</p> <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=bp>∃</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Nat</span><span class=o>,</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>existsi</span><span class=w> </span><span class=mi>42</span>
<span class=w>  </span><span class=n>rfl</span>

<span class=kd>example</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=bp>∃</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Nat</span><span class=o>,</span><span class=w> </span><span class=bp>∃</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Nat</span><span class=o>,</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>existsi</span><span class=w> </span><span class=mi>42</span><span class=o>,</span><span class=w> </span><span class=mi>42</span>
<span class=w>  </span><span class=n>rfl</span>
</code></pre></div> <h2 id=expose_names>expose_names<a class=headerlink href=#expose_names title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.exposeNames</code></p> <p><code>expose_names</code> 将所有不可访问变量重命名为可访问名称，使其在生成策略中可引用。但此重命名引入的机器生成名称不完全受用户控制。<code>expose_names</code> 主要用作自动生成终局策略脚本的前导。其亦可作为 <code>set_option tactic.hygienic false</code> 的替代。若需在策略脚本中间显式控制重命名，可考虑使用带用户定义名称的结构化策略脚本，如 <code>match .. with</code>、<code>induction .. with</code> 或带显式名称的 <code>intro</code>，以及 <code>next</code>、<code>case</code> 和 <code>rename_i</code> 等策略。</p> <h2 id=ext>ext<a class=headerlink href=#ext title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Elab.Tactic.Ext.ext</code></p> <p>应用通过 <code>@[ext]</code> 属性注册的外延性引理。 * <code>ext pat*</code> 尽可能应用外延性定理，使用模式 <code>pat*</code> 通过 <code>rintro</code> 引入外延性定理中的变量。例如，模式用于命名由 <code>funext</code> 等引理引入的变量。 * 无模式时，<code>ext</code> 尽可能应用外延性引理，但必要时引入匿名假设。 * <code>ext pat* : n</code> 仅应用外延性定理至深度 <code>n</code>。</p> <p><code>ext1 pat*</code> 策略类似 <code>ext pat*</code>，但仅应用单一外延性定理而非递归应用尽可能多。</p> <p>未使用的模式将生成警告。不匹配变量的模式通常导致匿名假设的引入。</p> <h2 id=ext1>ext1<a class=headerlink href=#ext1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Elab.Tactic.Ext.tacticExt1___</code></p> <p><code>ext1 pat*</code> 类似 <code>ext pat*</code>，但仅应用单一外延性定理而非递归应用尽可能多。</p> <p><code>pat*</code> 模式通过 <code>rintro</code> 策略处理。若未提供模式，则通过 <code>intros</code> 策略匿名引入变量。</p> <h2 id=extract_goal>extract_goal<a class=headerlink href=#extract_goal title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.ExtractGoal.extractGoal</code></p> <ul> <li><code>extract_goal</code> 将当前目标格式化为独立定理或定义，清理局部上下文中的无关变量。变量*相关*若满足以下条件：(1) 出现于目标类型，(2) 存在依赖其的相关变量，或 (3) 变量类型为依赖相关变量的命题。</li> </ul> <p>若目标为 <code>False</code>，则出于便利 <code>extract_goal</code> 包含所有变量。 - <code>extract_goal *</code> 格式化当前目标但不清理局部上下文。 - <code>extract_goal a b c ...</code> 格式化当前目标，移除给定变量 <code>a</code>、<code>b</code>、<code>c</code>、... 不依赖的所有内容。 - <code>extract_goal ... using name</code> 使用名称 <code>name</code> 而非自动生成名称命名定理或定义。</p> <p>此策略尝试生成可复制粘贴且直接可用的输出，但其成功取决于表达式是否适合无歧义漂亮打印。</p> <p>策略响应漂亮打印选项。例如，<code>set_option pp.all true in extract_goal</code> 提供 <code>pp.all</code> 形式。</p> <h2 id=extract_lets>extract_lets<a class=headerlink href=#extract_lets title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.extractLets</code></p> <p><code>extract_lets at h</code> 策略接受一个形式为 <code>h : let x := v; b</code> 的局部假设，并引入一个新的局部定义 <code>x := v</code>，同时将 <code>h</code> 修改为 <code>h : b</code>。可以将其视为针对 <code>let</code> 表达式的 <code>cases</code> 策略，或类似于针对 <code>let</code> 表达式的 <code>intros at h</code>。</p> <p>例如，若 <code>h : let x := 1; x = x</code>，则执行 <code>extract_lets x at h</code> 会引入 <code>x : Nat := 1</code> 并将 <code>h</code> 修改为 <code>h : x = x</code>。</p> <p>与 <code>intros</code> 类似，<code>extract_lets</code> 策略要么接受一个名称列表（此时指定必须提取的 <code>let</code> 绑定数量），要么不指定名称（此时提取所有 <code>let</code> 绑定）。</p> <p>不带 <code>at</code> 的 <code>extract_lets</code> 策略或 <code>extract_lets at h ⊢</code> 可视为对目标执行较弱的 <code>intros</code>，仅引入明显的 <code>let</code> 绑定。</p> <h2 id=fail>fail<a class=headerlink href=#fail title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.fail</code></p> <p><code>fail msg</code> 是一个始终失败的策略，并使用给定消息生成错误。</p> <h2 id=fail_if_no_progress>fail_if_no_progress<a class=headerlink href=#fail_if_no_progress title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.failIfNoProgress</code></p> <p><code>fail_if_no_progress tacs</code> 执行 <code>tacs</code>，若在主目标或可约透明度的局部上下文中未取得进展则失败。</p> <h2 id=fail_if_success>fail_if_success<a class=headerlink href=#fail_if_success title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.failIfSuccess</code></p> <p><code>fail_if_success t</code> 在策略 <code>t</code> 成功时失败。</p> <h2 id=false_or_by_contra>false_or_by_contra<a class=headerlink href=#false_or_by_contra title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.falseOrByContra</code></p> <p>将目标更改为 <code>False</code>，尽可能保留信息：</p> <ul> <li>若目标为 <code>False</code>，则不做任何操作。</li> <li>若目标为蕴含或函数类型，则引入参数并重新开始。（特别地，若目标为 <code>x ≠ y</code>，则引入 <code>x = y</code>。）</li> <li>否则，对于命题目标 <code>P</code>，将其替换为 <code>¬ ¬ P</code>（尝试寻找 <code>Decidable</code> 实例，否则退化为经典方式处理）并引入 <code>¬ P</code>。</li> <li>对于非命题目标，使用 <code>False.elim</code>。</li> </ul> <h2 id=fapply>fapply<a class=headerlink href=#fapply title="Permanent link">&para;</a></h2> <p>定义于：<code>Batteries.Tactic.tacticFapply_</code></p> <p><code>fapply e</code> 类似于 <code>apply e</code>，但按出现顺序添加目标，而非将依赖目标置于首位。</p> <h2 id=fconstructor>fconstructor<a class=headerlink href=#fconstructor title="Permanent link">&para;</a></h2> <p>定义于：<code>tacticFconstructor</code></p> <p><code>fconstructor</code> 类似于 <code>constructor</code>（它调用第一个匹配的归纳数据类型构造子的 <code>apply</code>），不同之处在于它不会重新排序目标。</p> <h2 id=field_simp>field_simp<a class=headerlink href=#field_simp title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.FieldSimp.fieldSimp</code></p> <p><code>field_simp</code> 的目标是通过使用名为 <code>field_simps</code> 的精心设计的简化集，将域中的表达式简化为形式 <code>n / d</code>，其中 <code>n</code> 和 <code>d</code> 均不含任何除法符号。其迭代步骤如下：</p> <ul> <li>将逆元写为除法</li> <li>在任何乘积中将除法移至右侧</li> <li>若乘积中有多个除法，则将其分组至末尾并写为单一除法</li> <li>将和式化为公分母</li> </ul> <p>若目标为等式，此简化集还将清除分母，从而通常可通过应用 <code>ring</code> 完成证明。</p> <p><code>field_simp [hx, hy]</code> 是以下形式的简写： <code>simp (disch := field_simp_discharge) [-one_div, -one_divp, -mul_eq_zero, hx, hy, field_simps]</code></p> <p>注意此简单算法不会尝试检测分母中的公因子以降低结果表达式的复杂度，而是依赖 <code>ring</code> 在后续步骤中处理复杂表达式。</p> <p>与简化器一贯行为相同，仅当前提条件可验证时才会应用归约步骤。这意味着应包含分母非零的证明。乘积非零当且仅当其因子均非零，以及非零数的幂非零等事实已包含在简化集中，但更复杂的断言（尤其涉及和式）需显式给出。若表达式未被完全简化，请检查结果表达式的分母并提供非零证明以继续。</p> <p>为验证分母非零，<code>field_simp</code> 将查找上下文中的事实，并尝试应用 <code>norm_num</code> 以闭合数值目标。</p> <p><code>field_simp</code> 调用会从简化集中移除 <code>one_div</code> 引理，因该引理与上述算法冲突。同时移除 <code>mul_eq_zero : x * y = 0 ↔ x = 0 ∨ y = 0</code>（因 <code>norm_num</code> 无法处理析取以闭合形如 <code>24 ≠ 0</code> 的目标），并以 <code>mul_ne_zero : x ≠ 0 → y ≠ 0 → x * y ≠ 0</code> 替代，从而创建两个目标而非析取。</p> <p>例如： <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=n>d</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℂ</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>hx</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>≠</span><span class=w> </span><span class=mi>0</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>hy</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=bp>≠</span><span class=w> </span><span class=mi>0</span><span class=o>)</span><span class=w> </span><span class=o>:</span>
<span class=w>    </span><span class=n>a</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=bp>/</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=bp>/</span><span class=w> </span><span class=n>x</span><span class=bp>^</span><span class=mi>2</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>d</span><span class=w> </span><span class=bp>/</span><span class=w> </span><span class=n>x</span><span class=bp>^</span><span class=mi>3</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>x</span><span class=bp>⁻¹</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=o>(</span><span class=n>y</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=bp>/</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=o>(</span><span class=n>d</span><span class=w> </span><span class=bp>/</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>c</span><span class=o>)</span><span class=w> </span><span class=bp>/</span><span class=w> </span><span class=n>x</span><span class=o>)</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>field_simp</span>
<span class=w>  </span><span class=n>ring</span>
</code></pre></div></p> <p>此外，<code>field_simp</code> 策略还可处理一般（交换）幺半群/环中的单位逆及偏除法 <code>/ₚ</code>，参见 <code>Algebra.Group.Units</code> 定义。类似地，移除 <code>one_divp</code> 引理以避免与算法冲突。若存在具有 <code>IsUnit x</code> 实例的对象如 <code>(x : R) (hx : IsUnit x)</code>，应在使用 <code>field_simp</code> 前通过 <code>lift x to Rˣ using id hx; rw [IsUnit.unit_of_val_units] clear hx</code> 提升。</p> <p>另见 <code>cancel_denoms</code> 策略，其尝试对含数值分母的表达式进行类似简化。两者无关联：<code>cancel_denoms</code> 仅处理数值分母，并通过乘以因子尝试完全移除（数值）除法。</p> <h2 id=field_simp_discharge>field_simp_discharge<a class=headerlink href=#field_simp_discharge title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.FieldSimp.tacticField_simp_discharge</code></p> <p><code>field_simp</code> 策略的放电策略。</p> <h2 id=filter_upwards>filter_upwards<a class=headerlink href=#filter_upwards title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.filterUpwards</code></p> <p><code>filter_upwards [h₁, ⋯, hₙ]</code> 将形如 <code>s ∈ f</code> 的目标及项 <code>h₁ : t₁ ∈ f, ⋯, hₙ : tₙ ∈ f</code> 替换为 <code>∀ x, x ∈ t₁ → ⋯ → x ∈ tₙ → x ∈ s</code>。列表为可选参数，默认值为 <code>[]</code>。</p> <p><code>filter_upwards [h₁, ⋯, hₙ] with a₁ a₂ ⋯ aₖ</code> 是 <code>{ filter_upwards [h₁, ⋯, hₙ], intros a₁ a₂ ⋯ aₖ }</code> 的简写。</p> <p><code>filter_upwards [h₁, ⋯, hₙ] using e</code> 是 <code>{ filter_upwards [h1, ⋯, hn], exact e }</code> 的简写。</p> <p>组合两种简写可写作 <code>filter_upwards [h₁, ⋯, hₙ] with a₁ a₂ ⋯ aₖ using e</code>。注意此时 <code>aᵢ</code> 可在 <code>e</code> 中使用。</p> <h2 id=fin_cases>fin_cases<a class=headerlink href=#fin_cases title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Elab.Tactic.finCases</code></p> <p><code>fin_cases h</code> 对假设 <code>h : A</code>（其中 <code>[Fintype A]</code> 可用）或 <code>h : a ∈ A</code>（其中 <code>A : Finset X</code>、<code>A : Multiset X</code> 或 <code>A : List X</code>）执行案例分析。</p> <p>例如： <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>f</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℕ</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=kt>Prop</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>p</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Fin</span><span class=w> </span><span class=mi>3</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>h0</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=mi>0</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>h1</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=mi>1</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>h2</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=mi>2</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=n>p.val</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>fin_cases</span><span class=w> </span><span class=n>p</span><span class=bp>;</span><span class=w> </span><span class=n>simp</span>
<span class=w>  </span><span class=n>all_goals</span><span class=w> </span><span class=n>assumption</span>
</code></pre></div> 执行 <code>fin_cases p; simp</code> 后，将生成三个目标：<code>f 0</code>、<code>f 1</code> 和 <code>f 2</code>。</p> <h2 id=fin_omega>fin_omega<a class=headerlink href=#fin_omega title="Permanent link">&para;</a></h2> <p>定义于：<code>Fin.tacticFin_omega</code></p> <p><code>omega</code> 的前处理器，用于处理 <code>Fin</code> 中的不等式。注意此过程涉及大量情况分割，可能较慢。</p> <h2 id=find_1>find<a class=headerlink href=#find_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.Find.tacticFind</code></p> <h2 id=finiteness>finiteness<a class=headerlink href=#finiteness title="Permanent link">&para;</a></h2> <p>定义于：<code>finiteness</code></p> <p>解决扩展非负实数（<code>ℝ≥0∞</code>）中形如 <code>*** &lt; ∞</code> 或等效的 <code>*** ≠ ∞</code> 目标的策略。</p> <h2 id=finiteness_1>finiteness?<a class=headerlink href=#finiteness_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>finiteness?</code></p> <p>解决扩展非负实数（<code>ℝ≥0∞</code>）中形如 <code>*** &lt; ∞</code> 或等效的 <code>*** ≠ ∞</code> 目标的策略。</p> <h2 id=finiteness_nonterminal>finiteness_nonterminal<a class=headerlink href=#finiteness_nonterminal title="Permanent link">&para;</a></h2> <p>定义于：<code>finiteness_nonterminal</code></p> <p>解决扩展非负实数（<code>ℝ≥0∞</code>）中形如 <code>*** &lt; ∞</code> 或等效的 <code>*** ≠ ∞</code> 目标的策略。</p> <h2 id=first>first<a class=headerlink href=#first title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.first</code></p> <p><code>first | tac | ...</code> 依次运行每个 <code>tac</code> 直到其中一个成功，否则失败。</p> <h2 id=focus>focus<a class=headerlink href=#focus title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.focus</code></p> <p><code>focus tac</code> 聚焦于主目标，抑制所有其他目标，并对其运行 <code>tac</code>。通常更推荐使用 <code>· tac</code>，其强制 <code>tac</code> 闭合目标。</p> <h2 id=forward>forward<a class=headerlink href=#forward title="Permanent link">&para;</a></h2> <p>定义于：<code>Aesop.Frontend.tacticForward___</code></p> <h2 id=forward_1>forward?<a class=headerlink href=#forward_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Aesop.Frontend.tacticForward?___</code></p> <h2 id=frac_tac>frac_tac<a class=headerlink href=#frac_tac title="Permanent link">&para;</a></h2> <p>定义于：<code>RatFunc.tacticFrac_tac</code></p> <p>通过操作 <code>FractionRing K[X]</code> 来求解 <code>RatFunc K</code> 的方程。</p> <h2 id=fun_cases>fun_cases<a class=headerlink href=#fun_cases title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.funCases</code></p> <p><code>fun_cases</code> 策略是使用函数式案例分析原理时 <code>cases</code> 策略的便捷包装。</p> <p>策略调用 <div class=highlight><pre><span></span><code>fun_cases f x ... y ...
</code></pre></div> 等价于 <div class=highlight><pre><span></span><code>cases y, ... using f.fun_cases x ...
</code></pre></div> 其中 <code>f</code> 的参数被用作 <code>f.fun_cases</code> 的参数或案例分析的目标，视情况而定。</p> <p>形式 <div class=highlight><pre><span></span><code>fun_cases f
</code></pre></div> （无参数传递给 <code>f</code>）会在目标中寻找 <code>f</code> 的唯一的合格应用，并使用这些参数。当应用是饱和的且将成为目标的参数是自由变量时，该应用是合格的。</p> <p>形式 <code>fun_cases f x y with | case1 =&gt; tac₁ | case2 x' ih =&gt; tac₂</code> 的工作方式与 <code>cases</code> 相同。</p> <h2 id=fun_induction>fun_induction<a class=headerlink href=#fun_induction title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.funInduction</code></p> <p><code>fun_induction</code> 策略是使用函数式归纳原理时 <code>induction</code> 策略的便捷包装。</p> <p>策略调用 <div class=highlight><pre><span></span><code>fun_induction f x₁ ... xₙ y₁ ... yₘ
</code></pre></div> 其中 <code>f</code> 是通过非互结构或良基递归定义的函数，等价于 <div class=highlight><pre><span></span><code>induction y₁, ... yₘ using f.induct x₁ ... xₙ
</code></pre></div> 其中 <code>f</code> 的参数被用作 <code>f.induct</code> 的参数或归纳的目标，视情况而定。</p> <p>形式 <div class=highlight><pre><span></span><code>fun_induction f
</code></pre></div> （无参数传递给 <code>f</code>）会在目标中寻找 <code>f</code> 的唯一的合格应用，并使用这些参数。当应用是饱和的且将成为目标的参数是自由变量时，该应用是合格的。</p> <p>形式 <code>fun_induction f x y generalizing z₁ ... zₙ</code> 和 <code>fun_induction f x y with | case1 =&gt; tac₁ | case2 x' ih =&gt; tac₂</code> 的工作方式与 <code>induction</code> 相同。</p> <h2 id=fun_prop>fun_prop<a class=headerlink href=#fun_prop title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Meta.FunProp.funPropTacStx</code></p> <p>用于证明函数属性的策略</p> <h2 id=funext>funext<a class=headerlink href=#funext title="Permanent link">&para;</a></h2> <p>定义于：<code>tacticFunext___</code></p> <p>应用函数外延性并引入新假设。 策略 <code>funext</code> 将持续应用 <code>funext</code> 引理，直到目标不再可简化为 <div class=highlight><pre><span></span><code>  |-  ((fun x =&gt; ...) = (fun x =&gt; ...))
</code></pre></div> 变体 <code>funext h₁ ... hₙ</code> 应用 <code>funext</code> <code>n</code> 次，并使用给定的标识符命名新假设。 可以像在 <code>intro</code> 策略中一样使用模式。例如，给定目标 <div class=highlight><pre><span></span><code>  |-  ((fun x : Nat × Bool =&gt; ...) = (fun x =&gt; ...))
</code></pre></div> <code>funext (a, b)</code> 应用一次 <code>funext</code> 并对新引入的对进行模式匹配。</p> <h2 id=gcongr>gcongr<a class=headerlink href=#gcongr title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.GCongr.tacticGcongr__With__</code></p> <p><code>gcongr</code> 策略应用“广义同余”规则，将匹配同一模式的 LHS 和 RHS 之间的关系目标简化为不同输入之间的子关系目标。例如， <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>{</span><span class=n>a</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=n>d</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℝ</span><span class=o>}</span><span class=w> </span><span class=o>(</span><span class=n>h1</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=bp>≤</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>1</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>h2</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=bp>≤</span><span class=w> </span><span class=n>d</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>2</span><span class=o>)</span><span class=w> </span><span class=o>:</span>
<span class=w>    </span><span class=n>x</span><span class=w> </span><span class=bp>^</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=bp>≤</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>^</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>d</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>gcongr</span>
<span class=w>  </span><span class=bp>·</span><span class=w> </span><span class=n>linarith</span>
<span class=w>  </span><span class=bp>·</span><span class=w> </span><span class=n>linarith</span>
</code></pre></div> 该示例的目标是证明模式 <div class=highlight><pre><span></span><code>x ^ 2 * ?_ + ?_
</code></pre></div> 的 LHS 和 RHS 之间的 <code>≤</code> 关系（左侧输入为 <code>a</code> 和 <code>c</code>，右侧为 <code>b</code> 和 <code>d</code>）；使用 <code>gcongr</code> 后，我们得到更简单的目标 <code>a ≤ b</code> 和 <code>c ≤ d</code>。</p> <p>可以显式提供模式；这在需要非最大匹配时很有用： <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>{</span><span class=n>a</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=n>d</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℝ</span><span class=o>}</span><span class=w> </span><span class=o>(</span><span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=bp>≤</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>d</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>1</span><span class=o>)</span><span class=w> </span><span class=o>:</span>
<span class=w>    </span><span class=n>x</span><span class=w> </span><span class=bp>^</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>c</span><span class=o>)</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>5</span><span class=w> </span><span class=bp>≤</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>^</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=o>(</span><span class=n>b</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>d</span><span class=o>)</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>5</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>gcongr</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>^</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=bp>?</span><span class=n>_</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>5</span>
<span class=w>  </span><span class=n>linarith</span>
</code></pre></div></p> <p>所使用的“广义同余”规则是带有 <code>@[gcongr]</code> 属性的库引理。例如，第一个示例使用广义同余引理 <code>add_le_add</code> 和 <code>mul_le_mul_of_nonneg_left</code> 构建证明项 <div class=highlight><pre><span></span><code>add_le_add (mul_le_mul_of_nonneg_left _ (pow_bit0_nonneg x 1)) _
</code></pre></div></p> <p>策略尝试使用 <code>gcongr_discharger</code> 策略（封装了 <code>positivity</code> 但也可扩展）来消除这些“广义同余”引理的次要目标（如上述 <code>mul_le_mul_of_nonneg_left</code> 应用中的次要目标 <code>0 ≤ x ^ 2</code>）。无法以此方式消除的次要目标将留给用户处理。</p> <h2 id=gcongr_1>gcongr?<a class=headerlink href=#gcongr_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>tacticGcongr?</code></p> <p>显示一个部件面板，允许通过选择目标中的子表达式生成带有孔的 <code>gcongr</code> 调用。</p> <h2 id=gcongr_discharger>gcongr_discharger<a class=headerlink href=#gcongr_discharger title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.GCongr.tacticGcongr_discharger</code></p> <h2 id=generalize>generalize<a class=headerlink href=#generalize title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.generalize</code></p> <ul> <li><code>generalize ([h :] e = x),+</code> 用新假设 <code>x</code> 替换主目标中所有 <code>e</code> 的出现。如果给出 <code>h</code>，则引入 <code>h : e = x</code>。</li> <li><code>generalize e = x at h₁ ... hₙ</code> 也泛化 <code>h₁</code>, ..., <code>hₙ</code> 中的 <code>e</code> 出现。</li> <li><code>generalize e = x at *</code> 将泛化所有位置的 <code>e</code> 出现。</li> </ul> <h2 id=generalize_1>generalize'<a class=headerlink href=#generalize_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>«tacticGeneralize'_:_=_»</code></p> <p><code>generalize</code> 的向后兼容垫片。</p> <h2 id=generalize_proofs>generalize_proofs<a class=headerlink href=#generalize_proofs title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.generalizeProofsElab</code></p> <p><code>generalize_proofs ids* [at locs]?</code> 泛化当前目标中的证明，将其转换为新的局部假设。</p> <ul> <li><code>generalize_proofs</code> 泛化目标中的证明。</li> <li><code>generalize_proofs at h₁ h₂</code> 泛化假设 <code>h₁</code> 和 <code>h₂</code> 中的证明。</li> <li><code>generalize_proofs at *</code> 泛化整个局部上下文中的证明。</li> <li><code>generalize_proofs pf₁ pf₂ pf₃</code> 使用名称 <code>pf₁</code>、<code>pf₂</code> 和 <code>pf₃</code> 命名泛化的证明。可以使用 <code>_</code> 来不命名证明。</li> </ul> <p>如果证明已存在于局部上下文中，则使用该证明而不是创建新的局部假设。</p> <p>当执行 <code>generalize_proofs at h</code> 时，如果 <code>h</code> 是一个 let 绑定，则其值被清除，且如果 <code>h</code> 重复了前面的局部假设，则被消除。</p> <p>该策略能够从绑定器下抽象证明，在局部上下文中创建全称量化的证明。要禁用此功能，使用 <code>generalize_proofs (config := { abstract := false })</code>。该策略还设置为从泛化证明的类型中递归抽象证明。可以通过 <code>maxDepth</code> 配置选项控制，<code>generalize_proofs (config := { maxDepth := 0 })</code> 关闭此功能。</p> <p>例如： <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>List.nthLe</span><span class=w> </span><span class=o>[</span><span class=mi>1</span><span class=o>,</span><span class=w> </span><span class=mi>2</span><span class=o>]</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=o>(</span><span class=kd>by</span><span class=w> </span><span class=n>simp</span><span class=o>)</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=c1>-- ⊢ [1, 2].nthLe 1 ⋯ = 2</span>
<span class=w>  </span><span class=n>generalize_proofs</span><span class=w> </span><span class=n>h</span>
<span class=w>  </span><span class=c1>-- h : 1 &lt; [1, 2].length</span>
<span class=w>  </span><span class=c1>-- ⊢ [1, 2].nthLe 1 h = 2</span>
</code></pre></div></p> <h2 id=get_elem_tactic>get_elem_tactic<a class=headerlink href=#get_elem_tactic title="Permanent link">&para;</a></h2> <p>定义于：<code>tacticGet_elem_tactic</code></p> <p><code>get_elem_tactic</code> 是符号 <code>arr[i]</code> 自动调用的策略，用于证明构造项时出现的任何次要条件（例如索引在数组边界内）。它只是委托给 <code>get_elem_tactic_trivial</code> 并在其他情况下给出诊断错误消息；鼓励用户扩展 <code>get_elem_tactic_trivial</code> 而不是此策略。</p> <h2 id=get_elem_tactic_trivial>get_elem_tactic_trivial<a class=headerlink href=#get_elem_tactic_trivial title="Permanent link">&para;</a></h2> <p>定义于：<code>tacticGet_elem_tactic_trivial</code></p> <p><code>get_elem_tactic_trivial</code> 是一个可扩展的策略，由符号 <code>arr[i]</code> 自动调用，用于证明构造项时出现的任何次要条件（例如索引在数组边界内）。默认行为是尝试 <code>trivial</code>（处理上下文中存在 <code>i &lt; arr.size</code> 的情况）、<code>simp +arith</code> 和 <code>omega</code>（用于进行索引的线性算术）。</p> <h2 id=ghost_calc>ghost_calc<a class=headerlink href=#ghost_calc title="Permanent link">&para;</a></h2> <p>定义于：<code>WittVector.Tactic.ghostCalc</code></p> <p><code>ghost_calc</code> 是用于证明多项式函数间恒等式的策略。通常，当面对像 <div class=highlight><pre><span></span><code><span class=bp>∀</span><span class=w> </span><span class=o>(</span><span class=n>x</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>𝕎</span><span class=w> </span><span class=n>R</span><span class=o>),</span><span class=w> </span><span class=n>verschiebung</span><span class=w> </span><span class=o>(</span><span class=n>x</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=n>frobenius</span><span class=w> </span><span class=n>y</span><span class=o>)</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>verschiebung</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=n>y</span>
</code></pre></div> 这样的目标时，你可以： 1. 调用 <code>ghost_calc</code> 2. 进行少量手动工作——可能无需操作，可能需要 <code>rintro</code> 等 3. 调用 <code>ghost_simp</code></p> <p>这将关闭目标。</p> <p><code>ghost_calc</code> 无法检测你处理的是单变量还是多变量多项式函数。你必须提供参数来确定这一点。如果要证明像上面这样的全称量化目标，调用 <code>ghost_calc _ _</code>。如果变量已引入，调用 <code>ghost_calc x y</code>。在单变量情况下，使用 <code>ghost_calc _</code> 或 <code>ghost_calc x</code>。</p> <p><code>ghost_calc</code> 是围绕类型类推断的轻量包装。它所做的只是应用适当的外延性引理并尝试推断结果目标。由于涉及高阶统一，Lean 的 elaborator 不喜欢这种操作，因此在策略脚本中使用它更容易（且更美观）。</p> <h2 id=ghost_fun_tac>ghost_fun_tac<a class=headerlink href=#ghost_fun_tac title="Permanent link">&para;</a></h2> <p>定义于：<code>WittVector.«tacticGhost_fun_tac_,_»</code></p> <p>用于证明<code>ghostFun</code>保持环运算的辅助策略。</p> <h2 id=ghost_simp>ghost_simp<a class=headerlink href=#ghost_simp title="Permanent link">&para;</a></h2> <p>定义于：<code>WittVector.Tactic.ghostSimp</code></p> <p>在通过幽灵分量方程进行重写时常用的简化宏。</p> <h2 id=grind>grind<a class=headerlink href=#grind title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.grind</code></p> <h2 id=grind_1>grind?<a class=headerlink href=#grind_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.grindTrace</code></p> <h2 id=group>group<a class=headerlink href=#group title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.Group.group</code></p> <p>用于在乘法群中规范化表达式的策略，不假设交换性，仅使用群公理而不涉及具体群的信息。</p> <p>（对于加法交换群，请使用<code>abel</code>策略。）</p> <p>示例： <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>{</span><span class=n>G</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=kt>Type</span><span class=o>}</span><span class=w> </span><span class=o>[</span><span class=n>Group</span><span class=w> </span><span class=n>G</span><span class=o>]</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=n>d</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>G</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=bp>*</span><span class=n>b</span><span class=bp>^</span><span class=mi>2</span><span class=o>)</span><span class=bp>*</span><span class=o>((</span><span class=n>b</span><span class=bp>*</span><span class=n>b</span><span class=o>)</span><span class=bp>⁻¹*</span><span class=n>a</span><span class=bp>⁻¹</span><span class=o>)</span><span class=bp>*</span><span class=n>d</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>a</span><span class=bp>*</span><span class=n>c</span><span class=bp>*</span><span class=n>d</span><span class=bp>⁻¹</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>group</span><span class=w> </span><span class=n>at</span><span class=w> </span><span class=n>h</span><span class=w> </span><span class=c1>-- 规范化`h`，使其变为`h : c = d`</span>
<span class=w>  </span><span class=n>rw</span><span class=w> </span><span class=o>[</span><span class=n>h</span><span class=o>]</span><span class=w>     </span><span class=c1>-- 目标现在为`a*d*d⁻¹ = a`</span>
<span class=w>  </span><span class=n>group</span><span class=w>      </span><span class=c1>-- 再次规范化并闭合目标</span>
</code></pre></div></p> <h2 id=guard_expr>guard_expr<a class=headerlink href=#guard_expr title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.guardExpr</code></p> <p>检查两个表达式是否相等的策略。 * <code>guard_expr e = e'</code> 检查<code>e</code>和<code>e'</code>在可约透明度下是否定义等价。 * <code>guard_expr e =~ e'</code> 检查<code>e</code>和<code>e'</code>在默认透明度下是否定义等价。 * <code>guard_expr e =ₛ e'</code> 检查<code>e</code>和<code>e'</code>是否句法等价。 * <code>guard_expr e =ₐ e'</code> 检查<code>e</code>和<code>e'</code>是否α等价。</p> <p>在检查相等性前，<code>e</code>和<code>e'</code>会被实例化其元变量。它们的类型会在处理合成元变量前通过<code>isDefEqGuarded</code>进行统一，以处理默认实例。</p> <h2 id=guard_goal_nums>guard_goal_nums<a class=headerlink href=#guard_goal_nums title="Permanent link">&para;</a></h2> <p>定义于：<code>guardGoalNums</code></p> <p><code>guard_goal_nums n</code> 在当前目标数为<code>n</code>时成功，否则失败。</p> <h2 id=guard_hyp>guard_hyp<a class=headerlink href=#guard_hyp title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.guardHyp</code></p> <p>检查指定假设是否具有给定类型和/或值的策略。</p> <ul> <li><code>guard_hyp h : t</code> 检查类型是否在可约定义等价下匹配。</li> <li><code>guard_hyp h :~ t</code> 检查类型是否在默认定义等价下匹配。</li> <li><code>guard_hyp h :ₛ t</code> 检查类型是否句法等价。</li> <li><code>guard_hyp h :ₐ t</code> 检查类型是否α等价。</li> <li><code>guard_hyp h := v</code> 检查值是否在可约定义等价下匹配。</li> <li><code>guard_hyp h :=~ v</code> 检查值是否在默认定义等价下匹配。</li> <li><code>guard_hyp h :=ₛ v</code> 检查值是否句法等价。</li> <li><code>guard_hyp h :=ₐ v</code> 检查值是否α等价。</li> </ul> <p>值<code>v</code>会以假设<code>h</code>的类型作为预期类型进行推导。</p> <h2 id=guard_hyp_nums>guard_hyp_nums<a class=headerlink href=#guard_hyp_nums title="Permanent link">&para;</a></h2> <p>定义于：<code>guardHypNums</code></p> <p><code>guard_hyp_nums n</code> 在当前假设数为<code>n</code>时成功，否则失败。</p> <p>注意：根据设置选项的不同，某些假设可能不会显示在目标视图中。此策略计算总假设数，而非可见假设数。</p> <h2 id=guard_target>guard_target<a class=headerlink href=#guard_target title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.guardTarget</code></p> <p>检查目标是否与给定表达式一致的策略。 * <code>guard_target = e</code> 检查目标在可约透明度下是否与<code>e</code>定义等价。 * <code>guard_target =~ e</code> 检查目标在默认透明度下是否与<code>e</code>定义等价。 * <code>guard_target =ₛ e</code> 检查目标是否与<code>e</code>句法等价。 * <code>guard_target =ₐ e</code> 检查目标是否与<code>e</code>α等价。</p> <p><code>e</code>会以目标的类型作为预期类型进行推导，这在<code>conv</code>模式中尤为有用。</p> <h2 id=have>have<a class=headerlink href=#have title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.tacticHave_</code></p> <p><code>have</code>策略用于向主目标的本地上下文中添加假设。 * <code>have h : t := e</code> 若<code>e</code>是类型<code>t</code>的项，则添加假设<code>h : t</code>。 * <code>have h := e</code> 使用<code>e</code>的类型作为<code>t</code>。 * <code>have : t := e</code> 和 <code>have := e</code> 使用<code>this</code>作为假设名称。 * <code>have pat := e</code> 对于模式<code>pat</code>等同于<code>match e with | pat =&gt; _</code>， 其中<code>_</code>代表后续策略。适用于仅有一个适用构造器的类型。 例如，给定<code>h : p ∧ q ∧ r</code>，<code>have ⟨h₁, h₂, h₃⟩ := h</code> 生成假设<code>h₁ : p</code>、<code>h₂ : q</code>和<code>h₃ : r</code>。</p> <h2 id=have_1>have<a class=headerlink href=#have_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.tacticHave_</code></p> <h2 id=have_2>have!?<a class=headerlink href=#have_2 title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.Propose.«tacticHave!?:_Using__»</code></p> <ul> <li><code>have? using a, b, c</code> 尝试查找使用本地假设<code>a, b, c</code>的引理， 并通过追踪消息报告结果。</li> <li><code>have? : h using a, b, c</code> 仅返回类型匹配<code>h</code>（可含<code>_</code>）的引理。</li> <li><code>have?! using a, b, c</code> 还会调用<code>have</code>将结果添加至本地目标状态。</li> </ul> <p>注意：<code>have?</code>（与<code>apply?</code>不同）不会检查目标，仅检查<code>using</code>子句中引理的类型。</p> <p><code>have?</code>不应留在最终证明中；它是类似于<code>apply?</code>的搜索工具。</p> <p>建议以<code>have := f a b c</code>形式打印。</p> <h2 id=have_3>have'<a class=headerlink href=#have_3 title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.tacticHave'_</code></p> <p>类似于<code>have</code>，但使用<code>refine'</code></p> <h2 id=have_4>have'<a class=headerlink href=#have_4 title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.«tacticHave'_:=_»</code></p> <p>类似于<code>have</code>，但使用<code>refine'</code></p> <h2 id=have_5>have?<a class=headerlink href=#have_5 title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.Propose.propose'</code></p> <ul> <li><code>have? using a, b, c</code> 尝试查找使用本地假设<code>a, b, c</code>的引理， 并通过追踪消息报告结果。</li> <li><code>have? : h using a, b, c</code> 仅返回类型匹配<code>h</code>（可含<code>_</code>）的引理。</li> <li><code>have?! using a, b, c</code> 还会调用<code>have</code>将结果添加至本地目标状态。</li> </ul> <p>注意：<code>have?</code>（与<code>apply?</code>不同）不会检查目标，仅检查<code>using</code>子句中引理的类型。</p> <p><code>have?</code>不应留在最终证明中；它是类似于<code>apply?</code>的搜索工具。</p> <p>建议以<code>have := f a b c</code>形式打印。</p> <h2 id=have_6>have?!<a class=headerlink href=#have_6 title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.Propose.«tacticHave?!:_Using__»</code></p> <ul> <li><code>have? using a, b, c</code> 尝试查找使用本地假设<code>a, b, c</code>的引理， 并通过追踪消息报告结果。</li> <li><code>have? : h using a, b, c</code> 仅返回类型匹配<code>h</code>（可含<code>_</code>）的引理。</li> <li><code>have?! using a, b, c</code> 还会调用<code>have</code>将结果添加至本地目标状态。</li> </ul> <p>注意：<code>have?</code>（与<code>apply?</code>不同）不会检查目标，仅检查<code>using</code>子句中引理的类型。</p> <p><code>have?</code>不应留在最终证明中；它是类似于<code>apply?</code>的搜索工具。</p> <p>建议以<code>have := f a b c</code>形式打印。</p> <h2 id=havei>haveI<a class=headerlink href=#havei title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.tacticHaveI_</code></p> <p><code>haveI</code>行为类似<code>have</code>，但会内联值而非生成<code>let_fun</code>项。</p> <h2 id=hint>hint<a class=headerlink href=#hint title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.Hint.hintStx</code></p> <p><code>hint</code>策略尝试所有通过<code>register_hint tac</code>注册的策略，并报告所有成功执行的策略。</p> <h2 id=induction>induction<a class=headerlink href=#induction title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.induction</code></p> <p>假设本地上下文中变量<code>x</code>具有归纳类型，<code>induction x</code>对主目标应用归纳法，为归纳类型的每个构造器生成一个子目标，其中目标被替换为该构造器的一般实例，并为每个递归参数添加归纳假设。若本地上下文中的某个元素类型依赖于<code>x</code>，该元素会被临时移除并在之后重新引入，以确保归纳假设包含该元素。</p> <p>例如，给定<code>n : Nat</code>及目标假设<code>h : P n</code>和目标<code>Q n</code>，<code>induction n</code>生成一个假设<code>h : P 0</code>和目标<code>Q 0</code>的子目标，以及一个假设<code>h : P (Nat.succ a)</code>和归纳假设<code>ih₁ : P a → Q a</code>，目标为<code>Q (Nat.succ a)</code>。此处<code>a</code>和<code>ih₁</code>自动命名且不可访问。可通过<code>with</code>为每个构造器指定变量名。 - <code>induction e</code>（<code>e</code>为表达式而非变量）在目标中泛化<code>e</code>后对结果变量应用归纳。 - <code>induction e using r</code>允许用户指定应使用的归纳原则。<code>r</code>的类型需为<code>C t</code>形式， 其中<code>C</code>为绑定变量，<code>t</code>为（可能为空的）绑定变量序列。 - <code>induction e generalizing z₁ ... zₙ</code>在应用归纳前泛化本地上下文中的变量<code>z₁ ... zₙ</code>， 之后在每个子目标中重新引入。净效应为每个归纳假设被泛化。 - 给定<code>x : Nat</code>，<code>induction x with | zero =&gt; tac₁ | succ x' ih =&gt; tac₂</code> 对<code>zero</code>情况使用策略<code>tac₁</code>，对<code>succ</code>情况使用<code>tac₂</code>。</p> <h2 id=induction_1>induction'<a class=headerlink href=#induction_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.induction'</code></p> <p><code>induction'</code> 策略与 Lean 4 核心中的 <code>induction</code> 策略类似，但语法略有不同（例如，无需为构造函数命名）。</p> <div class=highlight><pre><span></span><code><span class=kn>open</span><span class=w> </span><span class=n>Nat</span>

<span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>n</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℕ</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=n>factorial</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>induction&#39;</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=k>with</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=n>ih</span>
<span class=w>  </span><span class=bp>·</span><span class=w> </span><span class=n>rw</span><span class=w> </span><span class=o>[</span><span class=n>factorial_zero</span><span class=o>]</span>
<span class=w>    </span><span class=n>simp</span>
<span class=w>  </span><span class=bp>·</span><span class=w> </span><span class=n>rw</span><span class=w> </span><span class=o>[</span><span class=n>factorial_succ</span><span class=o>]</span>
<span class=w>    </span><span class=n>apply</span><span class=w> </span><span class=n>mul_pos</span><span class=w> </span><span class=o>(</span><span class=n>succ_pos</span><span class=w> </span><span class=n>n</span><span class=o>)</span><span class=w> </span><span class=n>ih</span>

<span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>n</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℕ</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=n>factorial</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>induction</span><span class=w> </span><span class=n>n</span>
<span class=w>  </span><span class=n>case</span><span class=w> </span><span class=n>zero</span><span class=w> </span><span class=bp>=&gt;</span>
<span class=w>    </span><span class=n>rw</span><span class=w> </span><span class=o>[</span><span class=n>factorial_zero</span><span class=o>]</span>
<span class=w>    </span><span class=n>simp</span>
<span class=w>  </span><span class=n>case</span><span class=w> </span><span class=n>succ</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=n>ih</span><span class=w> </span><span class=bp>=&gt;</span>
<span class=w>    </span><span class=n>rw</span><span class=w> </span><span class=o>[</span><span class=n>factorial_succ</span><span class=o>]</span>
<span class=w>    </span><span class=n>apply</span><span class=w> </span><span class=n>mul_pos</span><span class=w> </span><span class=o>(</span><span class=n>succ_pos</span><span class=w> </span><span class=n>n</span><span class=o>)</span><span class=w> </span><span class=n>ih</span>
</code></pre></div> <h2 id=infer_instance>infer_instance<a class=headerlink href=#infer_instance title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.tacticInfer_instance</code></p> <p><code>infer_instance</code> 是 <code>exact inferInstance</code> 的缩写。它通过类型类推断合成目标类型的值。</p> <h2 id=infer_param>infer_param<a class=headerlink href=#infer_param title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.inferOptParam</code></p> <p>通过使用 <code>a</code> 来关闭形如 <code>optParam α a</code> 或 <code>autoParam α stx</code> 的目标。</p> <h2 id=inhabit>inhabit<a class=headerlink href=#inhabit title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Elab.Tactic.inhabit</code></p> <p><code>inhabit α</code> 尝试推导 <code>Nonempty α</code> 实例，然后利用该实例创建 <code>Inhabited α</code> 实例。若目标是 <code>Prop</code>，则以构造性方式完成；否则使用 <code>Classical.choice</code>。</p> <h2 id=init_ring>init_ring<a class=headerlink href=#init_ring title="Permanent link">&para;</a></h2> <p>定义于：<code>WittVector.initRing</code></p> <p><code>init_ring</code> 是一个辅助策略，用于通过环运算分解 <code>init</code> 的目标。</p> <h2 id=injection>injection（单射分解）<a class=headerlink href=#injection title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.injection</code></p> <p><code>injection</code> 策略基于归纳数据类型构造函数的单射性。即若 <code>c</code> 是归纳数据类型的构造函数，且 <code>(c t₁)</code> 与 <code>(c t₂)</code> 相等，则 <code>t₁</code> 与 <code>t₂</code> 也相等。若 <code>q</code> 是证明 <code>t₁ = t₂</code> 的命题，则 <code>injection</code> 应用单射性推导所有位于相同位置的参数的相等性。例如，从 <code>(a::b) = (c::d)</code> 可推导出 <code>a=c</code> 和 <code>b=d</code>。使用此策略时，<code>t₁</code> 和 <code>t₂</code> 应为同一构造函数的应用。给定 <code>h : a::b = c::d</code>，策略 <code>injection h</code> 会在主目标中添加两个新假设，类型分别为 <code>a = c</code> 和 <code>b = d</code>。策略 <code>injection h with h₁ h₂</code> 使用 <code>h₁</code> 和 <code>h₂</code> 命名新假设。</p> <h2 id=injections>injections<a class=headerlink href=#injections title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.injections</code></p> <p><code>injections</code> 递归地对所有假设应用 <code>injection</code>（因 <code>injection</code> 可能生成新假设）。适用于解构嵌套的构造函数等式，如 <code>(a::b::c) = (d::e::f)</code>。</p> <h2 id=interval_cases>interval_cases<a class=headerlink href=#interval_cases title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.intervalCases</code></p> <p><code>interval_cases n</code> 搜索变量 <code>n</code> 的上下限，若找到边界，则分割为 <code>n</code> 的每个可能值的独立案例。</p> <p>例如： <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>n</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℕ</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>w₁</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=bp>≥</span><span class=w> </span><span class=mi>3</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>w₂</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=mi>5</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=mi>3</span><span class=w> </span><span class=bp>∨</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=mi>4</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>interval_cases</span><span class=w> </span><span class=n>n</span>
<span class=w>  </span><span class=n>all_goals</span><span class=w> </span><span class=n>simp</span>
</code></pre></div> 执行 <code>interval_cases n</code> 后，目标变为 <code>3 = 3 ∨ 3 = 4</code> 和 <code>4 = 3 ∨ 4 = 4</code>。</p> <p>也可显式指定上下限，如 <code>interval_cases using hl, hu</code>。假设应形如 <code>hl : a ≤ n</code> 和 <code>hu : n &lt; b</code>，此时 <code>interval_cases</code> 会对结果 <code>n ∈ Set.Ico a b</code> 调用 <code>fin_cases</code>。</p> <p>可指定新假设的名称 <code>h</code>，如 <code>interval_cases h : n</code> 或 <code>interval_cases h : n using hl, hu</code>。</p> <h2 id=intro>intro<a class=headerlink href=#intro title="Permanent link">&para;</a></h2> <p>定义于：<code>Batteries.Tactic.introDot</code></p> <p>语法 <code>intro.</code> 已弃用，建议使用 <code>nofun</code>。</p> <h2 id=intro_1>intro<a class=headerlink href=#intro_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.intro</code></p> <p>引入一个或多个假设，可选命名或模式匹配。对于每个待引入的假设，剩余主目标的目标类型必须是 <code>let</code> 或函数类型。</p> <ul> <li>单独使用 <code>intro</code> 会引入一个匿名假设，可通过如 <code>assumption</code> 访问。</li> <li><code>intro x y</code> 引入两个假设并命名。单个假设可通过 <code>_</code> 匿名， 或进行模式匹配： <div class=highlight><pre><span></span><code><span class=c1>-- ... ⊢ α × β → ...</span>
<span class=n>intro</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=o>,</span><span class=w> </span><span class=n>b</span><span class=o>)</span>
<span class=c1>-- ..., a : α, b : β ⊢ ...</span>
</code></pre></div></li> <li>此外，<code>intro</code> 可结合模式匹配，类似 <code>fun</code>： <div class=highlight><pre><span></span><code><span class=n>intro</span>
<span class=bp>|</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>1</span><span class=o>,</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=bp>=&gt;</span><span class=w> </span><span class=n>tac</span>
<span class=bp>|</span><span class=w> </span><span class=bp>...</span>
</code></pre></div></li> </ul> <h2 id=intro_2>intro<a class=headerlink href=#intro_2 title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.introMatch</code></p> <p>策略 <div class=highlight><pre><span></span><code>intro
| pat1 =&gt; tac1
| pat2 =&gt; tac2
</code></pre></div> 等同于： <div class=highlight><pre><span></span><code><span class=n>intro</span><span class=w> </span><span class=n>x</span>
<span class=k>match</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=k>with</span>
<span class=bp>|</span><span class=w> </span><span class=n>pat1</span><span class=w> </span><span class=bp>=&gt;</span><span class=w> </span><span class=n>tac1</span>
<span class=bp>|</span><span class=w> </span><span class=n>pat2</span><span class=w> </span><span class=bp>=&gt;</span><span class=w> </span><span class=n>tac2</span>
</code></pre></div> 即 <code>intro</code> 后可跟匹配分支，在引入值时进行模式匹配。这与项模式中的 <code>fun</code> 带匹配分支类似。</p> <h2 id=intros>intros<a class=headerlink href=#intros title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.intros</code></p> <p>引入零或多个假设，可选命名。</p> <ul> <li> <p><code>intros</code> 等效于重复应用 <code>intro</code>，直至目标不再是 <code>intro</code> 的明显候选，即只要目标是 <code>let</code> 或 Pi 类型（如蕴含、函数或全称量词），<code>intros</code> 会引入匿名假设。此策略不展开定义。</p> </li> <li> <p><code>intros x y ...</code> 等效于 <code>intro x y ...</code>，为每个提供的参数引入假设，并按需展开定义。 参数可为标识符或 <code>_</code>。标识符表示对应引入假设的名称，<code>_</code> 表示匿名引入假设。</p> </li> </ul> <p>示例：</p> <p>基础属性： <div class=highlight><pre><span></span><code><span class=kd>def</span><span class=w> </span><span class=n>AllEven</span><span class=w> </span><span class=o>(</span><span class=n>f</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Nat</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>Nat</span><span class=o>)</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=bp>∀</span><span class=w> </span><span class=n>n</span><span class=o>,</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=bp>%</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=mi>0</span>

<span class=c1>-- 自动引入两个明显假设</span>
<span class=kd>example</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=bp>∀</span><span class=w> </span><span class=o>(</span><span class=n>f</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Nat</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>Nat</span><span class=o>),</span><span class=w> </span><span class=n>AllEven</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>AllEven</span><span class=w> </span><span class=o>(</span><span class=k>fun</span><span class=w> </span><span class=n>k</span><span class=w> </span><span class=bp>=&gt;</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=o>(</span><span class=n>k</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>1</span><span class=o>))</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>intros</span>
<span class=w>  </span><span class=c>/-</span><span class=cm> 策略状态</span>
<span class=cm>     f✝ : Nat → Nat</span>
<span class=cm>     a✝ : AllEven f✝</span>
<span class=cm>     ⊢ AllEven fun k =&gt; f✝ (k + 1) -/</span>
<span class=w>  </span><span class=gr>sorry</span>

<span class=c1>-- 精确引入两个假设，仅命名第一个</span>
<span class=kd>example</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=bp>∀</span><span class=w> </span><span class=o>(</span><span class=n>f</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Nat</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>Nat</span><span class=o>),</span><span class=w> </span><span class=n>AllEven</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>AllEven</span><span class=w> </span><span class=o>(</span><span class=k>fun</span><span class=w> </span><span class=n>k</span><span class=w> </span><span class=bp>=&gt;</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=o>(</span><span class=n>k</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>1</span><span class=o>))</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>intros</span><span class=w> </span><span class=n>g</span><span class=w> </span><span class=n>_</span>
<span class=w>  </span><span class=c>/-</span><span class=cm> 策略状态</span>
<span class=cm>     g : Nat → Nat</span>
<span class=cm>     a✝ : AllEven g</span>
<span class=cm>     ⊢ AllEven fun k =&gt; g (k + 1) -/</span>
<span class=w>  </span><span class=gr>sorry</span>

<span class=c1>-- 精确引入三个假设，需展开 `AllEven`</span>
<span class=kd>example</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=bp>∀</span><span class=w> </span><span class=o>(</span><span class=n>f</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Nat</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>Nat</span><span class=o>),</span><span class=w> </span><span class=n>AllEven</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>AllEven</span><span class=w> </span><span class=o>(</span><span class=k>fun</span><span class=w> </span><span class=n>k</span><span class=w> </span><span class=bp>=&gt;</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=o>(</span><span class=n>k</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>1</span><span class=o>))</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>intros</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=n>h</span><span class=w> </span><span class=n>n</span>
<span class=w>  </span><span class=c>/-</span><span class=cm> 策略状态</span>
<span class=cm>     f : Nat → Nat</span>
<span class=cm>     h : AllEven f</span>
<span class=cm>     n : Nat</span>
<span class=cm>     ⊢ (fun k =&gt; f (k + 1)) n % 2 = 0 -/</span>
<span class=w>  </span><span class=n>apply</span><span class=w> </span><span class=n>h</span>
</code></pre></div></p> <p>蕴含： <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>p</span><span class=w> </span><span class=n>q</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=kt>Prop</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>p</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>q</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>p</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>intros</span>
<span class=w>  </span><span class=c>/-</span><span class=cm> 策略状态</span>
<span class=cm>     a✝¹ : p</span>
<span class=cm>     a✝ : q</span>
<span class=cm>     ⊢ p      -/</span>
<span class=w>  </span><span class=n>assumption</span>
</code></pre></div></p> <p>Let 绑定： <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=k>let</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=mi>1</span><span class=bp>;</span><span class=w> </span><span class=k>let</span><span class=w> </span><span class=n>k</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=mi>2</span><span class=bp>;</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>k</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=mi>3</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>intros</span>
<span class=w>  </span><span class=c>/-</span><span class=cm> n✝ : Nat := 1</span>
<span class=cm>     k✝ : Nat := 2</span>
<span class=cm>     ⊢ n✝ + k✝ = 3 -/</span>
<span class=w>  </span><span class=n>rfl</span>
</code></pre></div></p> <h2 id=introv>introv<a class=headerlink href=#introv title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.introv</code></p> <p>策略 <code>introv</code> 允许用户自动引入定理的变量，并显式命名非依赖假设。依赖假设使用默认名称。</p> <p>示例： <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=bp>∀</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Nat</span><span class=o>,</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>introv</span><span class=w> </span><span class=n>h</span><span class=o>,</span>
<span class=w>  </span><span class=n>exact</span><span class=w> </span><span class=n>h.symm</span>
</code></pre></div> 执行 <code>introv h</code> 后的状态为： <div class=highlight><pre><span></span><code>a b : ℕ,
h : a = b
⊢ b = a
</code></pre></div></p> <p><div class=highlight><pre><span></span><code>example : ∀ a b : Nat, a = b → ∀ c, b = c → a = c := by
  introv h₁ h₂,
  exact h₁.trans h₂
</code></pre></div> 执行 <code>introv h₁ h₂</code> 后的状态为： <div class=highlight><pre><span></span><code>a b : ℕ,
h₁ : a = b,
c : ℕ,
h₂ : b = c
⊢ a = c
</code></pre></div></p> <h2 id=isboundeddefault>isBoundedDefault<a class=headerlink href=#isboundeddefault title="Permanent link">&para;</a></h2> <p>定义于：<code>Filter.tacticIsBoundedDefault</code></p> <p>在完全格中，滤波器自动有界或共界。为了在完全格和条件完全格中使用相同语句，但让自动化在完全格中自动填充有界性证明，我们在语句中使用策略 <code>isBoundedDefault</code>，形式为 <code>(hf : f.IsBounded (≥) := by isBoundedDefault)</code>。</p> <h2 id=itauto>itauto<a class=headerlink href=#itauto title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.ITauto.itauto</code></p> <p>直觉主义命题逻辑的决策过程。与 <code>finish</code> 和 <code>tauto!</code> 不同，此策略不使用排中律（不带 <code>!</code> 选项时），且证明搜索针对此用例优化。（<code>itauto!</code> 可作为经典 SAT 求解器，但算法在此情况下效果不佳。）</p> <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>p</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=kt>Prop</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=bp>¬</span><span class=w> </span><span class=o>(</span><span class=n>p</span><span class=w> </span><span class=bp>↔</span><span class=w> </span><span class=bp>¬</span><span class=w> </span><span class=n>p</span><span class=o>)</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span><span class=w> </span><span class=n>itauto</span>
</code></pre></div> <p><code>itauto [a, b]</code> 会额外尝试对 <code>a</code> 和 <code>b</code> 进行案例分析，前提是能推导出 <code>Decidable a</code> 和 <code>Decidable b</code>。<code>itauto *</code> 会对所有可判定的命题原子进行案例分析，<code>itauto! *</code> 会对所有命题原子进行案例分析。 <em>警告：</em> 可能导致证明搜索爆炸，需谨慎使用。</p> <h2 id=itauto_1>itauto!<a class=headerlink href=#itauto_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.ITauto.itauto!</code></p> <p>针对直觉主义命题逻辑的决策过程。与<code>finish</code>和<code>tauto!</code>不同，此策略在无<code>!</code>选项时绝不使用排中律，且其证明搜索专为此用例优化。（<code>itauto!</code>可作为经典SAT求解器使用，但在此情境下算法效率不高。）</p> <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>p</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=kt>Prop</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=bp>¬</span><span class=w> </span><span class=o>(</span><span class=n>p</span><span class=w> </span><span class=bp>↔</span><span class=w> </span><span class=bp>¬</span><span class=w> </span><span class=n>p</span><span class=o>)</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span><span class=w> </span><span class=n>itauto</span>
</code></pre></div> <p><code>itauto [a, b]</code>将额外尝试对<code>a</code>和<code>b</code>进行案例分析，前提是能推导出<code>Decidable a</code>和<code>Decidable b</code>。<code>itauto *</code>将对所有可判定的原子命题进行案例分析，而<code>itauto! *</code>则对所有命题原子进行分析。 *警告：*此操作可能导致证明搜索爆炸，故应谨慎使用。</p> <h2 id=iterate>iterate<a class=headerlink href=#iterate title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.tacticIterate____</code></p> <p><code>iterate n tac</code>精确运行<code>tac</code>策略<code>n</code>次。<code>iterate tac</code>反复运行<code>tac</code>直至失败。</p> <p><code>iterate</code>的参数为策略序列，因此可通过<code>iterate n (tac₁; tac₂; ⋯)</code>或以下方式运行多个策略： <div class=highlight><pre><span></span><code><span class=n>iterate</span><span class=w> </span><span class=n>n</span>
<span class=w>  </span><span class=n>tac₁</span>
<span class=w>  </span><span class=n>tac₂</span>
<span class=w>  </span><span class=bp>⋯</span>
</code></pre></div></p> <h2 id=left>left<a class=headerlink href=#left title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.left</code></p> <p>当目标为恰好两个构造函数的归纳类型时，应用第一个构造函数，否则失败。 <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>True</span><span class=w> </span><span class=bp>∨</span><span class=w> </span><span class=n>False</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>left</span>
<span class=w>  </span><span class=n>trivial</span>
</code></pre></div></p> <h2 id=let>let<a class=headerlink href=#let title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.letrec</code></p> <p><code>let rec f : t := e</code>向当前目标添加递归定义<code>f</code>。语法与项模式下的<code>let rec</code>相同。</p> <h2 id=let_1>let<a class=headerlink href=#let_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.tacticLet_</code></p> <h2 id=let_2>let<a class=headerlink href=#let_2 title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.tacticLet_</code></p> <p><code>let</code>策略用于向主目标的局部上下文中添加定义。 * <code>let x : t := e</code>若<code>e</code>为类型<code>t</code>的项，则添加定义<code>x : t := e</code>。 * <code>let x := e</code>使用<code>e</code>的类型作为<code>t</code>。 * <code>let : t := e</code>和<code>let := e</code>使用<code>this</code>作为假设名称。 * 对模式<code>pat</code>的<code>let pat := e</code>等价于<code>match e with | pat =&gt; _</code>，其中<code>_</code>代表后续策略。此语法适用于仅有一个适用构造函数的情况。例如，给定<code>p : α × β × γ</code>，<code>let ⟨x, y, z⟩ := p</code>将生成局部变量<code>x : α</code>、<code>y : β</code>和<code>z : γ</code>。</p> <h2 id=let_3>let'<a class=headerlink href=#let_3 title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.tacticLet'_</code></p> <p>类似<code>let</code>，但使用<code>refine'</code></p> <h2 id=leti>letI<a class=headerlink href=#leti title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.tacticLetI_</code></p> <p><code>letI</code>行为类似<code>let</code>，但内联值而非生成<code>let_fun</code>项。</p> <h2 id=lift>lift<a class=headerlink href=#lift title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.lift</code></p> <p>将表达式提升至另一类型。 * 用法：<code>'lift' expr 'to' expr ('using' expr)? ('with' id (id id?)?)?</code>。 * 若<code>n : ℤ</code>且<code>hn : n ≥ 0</code>，则策略<code>lift n to ℕ using hn</code>将创建名为<code>n</code>的<code>ℕ</code>类型新常量，并将旧变量<code>(n : ℤ)</code>的所有出现替换为<code>↑n</code>（新变量<code>n</code>）。同时从上下文中移除<code>n</code>和<code>hn</code>。 + 例如，策略<code>lift n to ℕ using hn</code>将目标<code>n : ℤ, hn : n ≥ 0, h : P n ⊢ n = 3</code>转换为<code>n : ℕ, h : P ↑n ⊢ ↑n = 3</code>（此处<code>P</code>为<code>ℤ → Prop</code>类型项）。 * 参数<code>using hn</code>可选，策略<code>lift n to ℕ</code>效果相同，但会新增子目标<code>n ≥ 0</code>（<code>n</code>为旧变量）。此子目标将置于目标列表顶端。 + 例如，策略<code>lift n to ℕ</code>将目标<code>n : ℤ, h : P n ⊢ n = 3</code>转换为两个目标：<code>n : ℤ, h : P n ⊢ n ≥ 0</code>和<code>n : ℕ, h : P ↑n ⊢ ↑n = 3</code>。 * 也可使用<code>lift n to ℕ using e</code>，其中<code>e</code>为<code>n ≥ 0</code>类型的任意表达式。 * 使用<code>lift n to ℕ with k</code>指定新变量名称。 * 使用<code>lift n to ℕ with k hk</code>同时指定等式<code>↑k = n</code>的名称。此时<code>n</code>仍保留于上下文中。可使用<code>rfl</code>作为<code>hk</code>名称以消除<code>n</code>（即默认行为）。 * 也可对<code>e : ℤ</code>类型的任意表达式使用<code>lift e to ℕ with k hk</code>。此时<code>hk</code>始终保留于上下文中，但用于重写所有假设及目标中的<code>e</code>。 + 例如，策略<code>lift n + 3 to ℕ using hn with k hk</code>将目标<code>n : ℤ, hn : n + 3 ≥ 0, h : P (n + 3) ⊢ n + 3 = 2 * n</code>转换为<code>n : ℤ, k : ℕ, hk : ↑k = n + 3, h : P ↑k ⊢ ↑k = 2 * n</code>。 * 策略<code>lift n to ℕ using h</code>将从上下文中移除<code>h</code>。若需保留，可在<code>with</code>的第三个参数中再次指定，如<code>lift n to ℕ using h with n rfl h</code>。 * 更一般地，此策略可将表达式从<code>α</code>提升至<code>β</code>，前提是存在<code>CanLift α β</code>实例。此时证明义务由<code>CanLift.prf</code>指定。 * 给定实例<code>CanLift β γ</code>，亦可提升<code>α → β</code>至<code>α → γ</code>；更一般地，给定<code>β : Π a : α, Type*</code>、<code>γ : Π a : α, Type*</code>及<code>[Π a : α, CanLift (β a) (γ a)]</code>，自动生成实例<code>CanLift (Π a, β a) (Π a, γ a)</code>。</p> <p><code>lift</code>在某种意义上与<code>zify</code>策略互为补充。<code>lift (z : ℤ) to ℕ</code>将在超类型<code>ℤ</code>中整数<code>z</code>提升至子类型<code>ℕ</code>，前提是证明<code>z ≥ 0</code>；涉及<code>z</code>的命题仍位于<code>ℤ</code>。<code>zify</code>则将子类型<code>ℕ</code>的命题转换为超类型<code>ℤ</code>的命题，且不改变任何变量类型。</p> <h2 id=lift_lets>lift_lets<a class=headerlink href=#lift_lets title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.lift_lets</code></p> <p>将表达式类型中的所有<code>let</code>绑定尽可能外提。</p> <p>应用于主目标时，此策略允许<code>intro</code>内嵌的<code>let</code>表达式。例如： <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=o>(</span><span class=k>let</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=mi>1</span><span class=bp>;</span><span class=w> </span><span class=n>x</span><span class=o>)</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>lift_lets</span>
<span class=w>  </span><span class=c1>-- ⊢ let x := 1; x = 1</span>
<span class=w>  </span><span class=n>intro</span><span class=w> </span><span class=n>x</span>
<span class=w>  </span><span class=gr>sorry</span>
</code></pre></div></p> <p>在提升过程中，类型和值相同的<code>let</code>绑定将被合并。</p> <h2 id=liftable_prefixes>liftable_prefixes<a class=headerlink href=#liftable_prefixes title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.Coherence.liftable_prefixes</code></p> <p><code>coherence</code>内部使用的策略。</p> <p>将等式<code>f = g</code>重写为<code>f₀ ≫ f₁ = g₀ ≫ g₁</code>，其中<code>f₀</code>和<code>g₀</code>为<code>f</code>和<code>g</code>（可能经重新结合后的）的最大可提升前缀（即能表示为单一化子和结合子的组合）。</p> <h2 id=linarith>linarith<a class=headerlink href=#linarith title="Permanent link">&para;</a></h2> <p>定义于：<code>linarith</code></p> <p><code>linarith</code>尝试在线性（不）等式假设间寻找矛盾。等价地，通过假设其否定并证明<code>False</code>，可证明线性不等式。</p> <p>理论上，<code>linarith</code>应能证明所有在线性算术有理数理论中成立的目标。尽管对<code>Nat</code>和<code>Int</code>等非密集序有特殊处理，此策略对这类理论并不完备，无法证明所有真命题。它将解决任意实例化<code>LinearOrderedCommRing</code>类型的目标。</p> <p>示例： <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>x</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=n>z</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℚ</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>h1</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=mi>2</span><span class=bp>*</span><span class=n>x</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=mi>3</span><span class=bp>*</span><span class=n>y</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>h2</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=bp>-</span><span class=mi>4</span><span class=bp>*</span><span class=n>x</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>2</span><span class=bp>*</span><span class=n>z</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=mi>0</span><span class=o>)</span>
<span class=w>        </span><span class=o>(</span><span class=n>h3</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=mi>12</span><span class=bp>*</span><span class=n>y</span><span class=w> </span><span class=bp>-</span><span class=w> </span><span class=mi>4</span><span class=bp>*</span><span class=w> </span><span class=n>z</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=mi>0</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>False</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>linarith</span>
</code></pre></div></p> <p><code>linarith</code>将使用所有适用假设及目标的否定（若适用）。不等性假设需分情况讨论，通常不予考虑（参见<code>splitNe</code>选项）。</p> <p><code>linarith [t1, t2, t3]</code>将额外使用证明项<code>t1, t2, t3</code>。</p> <p><code>linarith only [h1, h2, h3, t1, t2, t3]</code>仅使用目标（若相关）、局部假设<code>h1, h2, h3</code>及证明<code>t1, t2, t3</code>，忽略其余上下文。</p> <p><code>linarith!</code>将使用更强的可约简性设置以识别原子。例如： <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>x</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℚ</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>≥</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>linarith</span>
</code></pre></div> 将失败，因<code>linarith</code>无法识别<code>x</code>与<code>id x</code>。<code>linarith!</code>则能成功。此操作有时较为耗时。</p> <p><code>linarith (config := { .. })</code>接受包含五个可选参数的配置对象： * <code>discharger</code>指定用于在证明阶段简化代数方程的策略，默认为<code>ring</code>。其他选项包括基础问题的<code>simp</code>。 * <code>transparency</code>控制<code>linarith</code>尝试匹配原子的力度，默认仅展开<code>reducible</code>定义。 * 若<code>splitHypotheses</code>为<code>true</code>，<code>linarith</code>将拆分上下文中的合取为独立假设。 * 若<code>splitNe</code>为<code>true</code>，<code>linarith</code>将对不等性假设进行情况拆分。对每个<code>x ≠ y</code>假设，分别以<code>x &lt; y</code>和<code>x &gt; y</code>运行<code>linarith</code>，导致随不等性假设数量指数级增长的运行次数（默认<code>false</code>）。 * 若<code>exfalso</code>为<code>false</code>，当目标非不等式或<code>False</code>时，<code>linarith</code>将失败（默认<code>true</code>）。 * <code>restrict_type</code>（尚未在mathlib4中实现）仅使用<code>tp</code>上的不等式假设，适用于局部上下文中同时存在整数和有理数不等式的情况，避免混淆。</p> <h2 id=linarith_1>linarith!<a class=headerlink href=#linarith_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>tacticLinarith!_</code></p> <p><code>linarith</code> 尝试在线性（不）等式假设中寻找矛盾。等价地，它可以通过假设目标的否定并证明 <code>False</code> 来证明一个线性不等式。</p> <p>理论上，<code>linarith</code> 应能证明任何在有理数线性算术理论中成立的命题。尽管对于非稠密序如 <code>Nat</code> 和 <code>Int</code> 有特殊处理，此策略对这些理论并不完备，无法证明所有真命题。它能够解决实例化了 <code>LinearOrderedCommRing</code>（线性有序交换环）的任意类型上的目标。</p> <p>示例： <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>x</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=n>z</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℚ</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>h1</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=mi>2</span><span class=bp>*</span><span class=n>x</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=mi>3</span><span class=bp>*</span><span class=n>y</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>h2</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=bp>-</span><span class=mi>4</span><span class=bp>*</span><span class=n>x</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>2</span><span class=bp>*</span><span class=n>z</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=mi>0</span><span class=o>)</span>
<span class=w>        </span><span class=o>(</span><span class=n>h3</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=mi>12</span><span class=bp>*</span><span class=n>y</span><span class=w> </span><span class=bp>-</span><span class=w> </span><span class=mi>4</span><span class=bp>*</span><span class=w> </span><span class=n>z</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=mi>0</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>False</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>linarith</span>
</code></pre></div></p> <p><code>linarith</code> 将使用所有适用的假设及目标的否定（若适用）。不等式假设需要进行情况拆分，通常不被考虑（参见下方的 <code>splitNe</code> 选项）。</p> <p><code>linarith [t1, t2, t3]</code> 将额外使用证明项 <code>t1, t2, t3</code>。</p> <p><code>linarith only [h1, h2, h3, t1, t2, t3]</code> 将仅使用目标（若相关）、局部假设 <code>h1</code>、<code>h2</code>、<code>h3</code> 及证明 <code>t1</code>、<code>t2</code>、<code>t3</code>，忽略其余局部上下文。</p> <p><code>linarith!</code> 将使用更强的可约简性设置以尝试识别原子。例如： <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>x</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℚ</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>≥</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>linarith</span>
</code></pre></div> 将失败，因为 <code>linarith</code> 无法识别 <code>x</code> 与 <code>id x</code>。而 <code>linarith!</code> 可以。此操作有时可能较为耗时。</p> <p><code>linarith (config := { .. })</code> 接受一个配置对象，包含五个可选参数： * <code>discharger</code> 指定用于在证明阶段化简代数方程的策略，默认为 <code>ring</code>。其他选项包括处理基础问题的 <code>simp</code>。 * <code>transparency</code> 控制 <code>linarith</code> 尝试匹配原子的努力程度，默认仅展开 <code>reducible</code> 定义。 * 若 <code>splitHypotheses</code> 为真，<code>linarith</code> 将上下文中的合取式拆分为独立假设。 * 若 <code>splitNe</code> 为 <code>true</code>，<code>linarith</code> 将对不等式假设进行情况拆分。对于给定的 <code>x ≠ y</code> 假设，<code>linarith</code> 将分别在 <code>x &lt; y</code> 和 <code>x &gt; y</code> 下运行，这会随不等式假设数量呈指数级增加运行次数（默认为 <code>false</code>）。 * 若 <code>exfalso</code> 为 <code>false</code>，当目标既非不等式也非 <code>False</code> 时，<code>linarith</code> 将失败（默认为 <code>true</code>）。 * <code>restrict_type</code>（mathlib4 中尚未实现）将仅使用类型为 <code>tp</code> 的不等式假设。这在局部上下文中同时存在整型与有理型不等式时尤为有用，避免混淆策略。</p> <p>其变体 <code>nlinarith</code> 通过基础预处理处理部分非线性目标。</p> <p>选项 <code>set_option trace.linarith true</code> 将追踪 <code>linarith</code> 例程的特定中间阶段。</p> <h2 id=linear_combination>linear_combination<a class=headerlink href=#linear_combination title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.LinearCombination.linearCombination</code></p> <p><code>linear_combination</code> 策略尝试通过将目标展示为指定的（不）等式假设或其它（不）等式证明项的线性组合来证明（不）等式目标，模（A）项在（不）等式左右侧的移动，及（B）默认使用环归一化的归一化策略。</p> <p>示例用法： <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>{</span><span class=n>a</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℚ</span><span class=o>}</span><span class=w> </span><span class=o>(</span><span class=n>h1</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=mi>1</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>h2</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=mi>3</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>b</span><span class=o>)</span><span class=w> </span><span class=bp>/</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>linear_combination</span><span class=w> </span><span class=o>(</span><span class=n>h1</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>h2</span><span class=o>)</span><span class=w> </span><span class=bp>/</span><span class=w> </span><span class=mi>2</span>

<span class=kd>example</span><span class=w> </span><span class=o>{</span><span class=n>a</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℚ</span><span class=o>}</span><span class=w> </span><span class=o>(</span><span class=n>h1</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>≤</span><span class=w> </span><span class=mi>1</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>h2</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=bp>≤</span><span class=w> </span><span class=mi>3</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>b</span><span class=o>)</span><span class=w> </span><span class=bp>/</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=bp>≤</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>linear_combination</span><span class=w> </span><span class=o>(</span><span class=n>h1</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>h2</span><span class=o>)</span><span class=w> </span><span class=bp>/</span><span class=w> </span><span class=mi>2</span>

<span class=kd>example</span><span class=w> </span><span class=o>{</span><span class=n>a</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℚ</span><span class=o>}</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=bp>≤</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>^</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=bp>^</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>linear_combination</span><span class=w> </span><span class=n>sq_nonneg</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=bp>-</span><span class=w> </span><span class=n>b</span><span class=o>)</span>

<span class=kd>example</span><span class=w> </span><span class=o>{</span><span class=n>x</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=n>z</span><span class=w> </span><span class=n>w</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℤ</span><span class=o>}</span><span class=w> </span><span class=o>(</span><span class=n>h₁</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=n>z</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=bp>^</span><span class=w> </span><span class=mi>2</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>h₂</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=n>w</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>z</span><span class=w> </span><span class=bp>^</span><span class=w> </span><span class=mi>2</span><span class=o>)</span><span class=w> </span><span class=o>:</span>
<span class=w>    </span><span class=n>z</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=o>(</span><span class=n>x</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=n>w</span><span class=w> </span><span class=bp>-</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=n>z</span><span class=o>)</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>linear_combination</span><span class=w> </span><span class=n>w</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=n>h₁</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=n>h₂</span>

<span class=kd>example</span><span class=w> </span><span class=o>{</span><span class=n>x</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℚ</span><span class=o>}</span><span class=w> </span><span class=o>(</span><span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>≥</span><span class=w> </span><span class=mi>5</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>^</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=bp>&gt;</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>11</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>linear_combination</span><span class=w> </span><span class=o>(</span><span class=n>x</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>3</span><span class=o>)</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=n>h</span>

<span class=kd>example</span><span class=w> </span><span class=o>{</span><span class=n>R</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=kt>Type</span><span class=bp>*</span><span class=o>}</span><span class=w> </span><span class=o>[</span><span class=n>CommRing</span><span class=w> </span><span class=n>R</span><span class=o>]</span><span class=w> </span><span class=o>{</span><span class=n>a</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>R</span><span class=o>}</span><span class=w> </span><span class=o>(</span><span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>b</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>^</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=bp>^</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>linear_combination</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>b</span><span class=o>)</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=n>h</span>

<span class=kd>example</span><span class=w> </span><span class=o>{</span><span class=n>A</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=kt>Type</span><span class=bp>*</span><span class=o>}</span><span class=w> </span><span class=o>[</span><span class=n>AddCommGroup</span><span class=w> </span><span class=n>A</span><span class=o>]</span>
<span class=w>    </span><span class=o>{</span><span class=n>x</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=n>z</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>A</span><span class=o>}</span><span class=w> </span><span class=o>(</span><span class=n>h1</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=mi>10</span><span class=w> </span><span class=bp>•</span><span class=w> </span><span class=n>z</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>h2</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>-</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=mi>6</span><span class=w> </span><span class=bp>•</span><span class=w> </span><span class=n>z</span><span class=o>)</span><span class=w> </span><span class=o>:</span>
<span class=w>    </span><span class=mi>2</span><span class=w> </span><span class=bp>•</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=bp>•</span><span class=w> </span><span class=o>(</span><span class=mi>8</span><span class=w> </span><span class=bp>•</span><span class=w> </span><span class=n>z</span><span class=o>)</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>linear_combination</span><span class=w> </span><span class=o>(</span><span class=n>norm</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=n>abel</span><span class=o>)</span><span class=w> </span><span class=n>h1</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>h2</span>

<span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>x</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℤ</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>h1</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=mi>1</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>h2</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>y</span><span class=o>)</span><span class=w> </span><span class=o>:</span>
<span class=w>    </span><span class=n>x</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=bp>-</span><span class=mi>2</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>linear_combination</span><span class=w> </span><span class=o>(</span><span class=n>norm</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=n>ring_nf</span><span class=o>)</span><span class=w> </span><span class=bp>-</span><span class=mi>2</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=n>h2</span>
<span class=w>  </span><span class=c1>-- 留下目标 `⊢ x * y + x * 2 - 1 = 0`</span>
</code></pre></div></p> <p>输入 <code>e</code> 于 <code>linear_combination e</code> 中是（不）等式证明的线性组合，表现为系数乘以表达式的和/差。系数可为任意表达式（不等式时需非负）。表达式可为任意证明（不）等式的证明项，通常为假设名 <code>h1</code>、<code>h2</code> 等。</p> <p>所有（不）等式的左右侧应具相同类型 <code>α</code>，系数亦应具类型 <code>α</code>。完整功能下，<code>α</code> 应为交换环——严格而言，是具有“可消去”加法的交换半环（半环情形下，负与减将形式化处理为在包络环中的操作）。若使用非标准归一化（如 <code>abel</code> 或 <code>skip</code>），策略可工作于代数结构较弱的类型 <code>α</code>：对于等式，最低要求为实例 <code>[Add α] [IsRightCancelAdd α]</code> 及策略调用中使用操作的实例。</p> <p>变体 <code>linear_combination (norm := tac) e</code> 显式指定归一化策略 <code>tac</code> 在构建线性组合后作用于子目标。 * 默认归一化策略为 <code>ring1</code>（等式）或 <code>Mathlib.Tactic.Ring.prove{LE,LT}</code>（不等式）。这些为终结策略：成功闭合目标或失败。 * 当工作于交换环外的代数范畴（如域、交换群、模）时，使用适配这些范畴的归一化策略（<code>field_simp</code>、<code>abel</code>、<code>module</code>）有时有效。 * 跳过归一化，使用 <code>skip</code> 作为归一化策略。 * <code>linear_combination</code> 通过从左至右相加提供的（不）等式构建线性组合，故若 <code>tac</code> 对加法表达式交换不变，输入假设的顺序可能影响结果。</p> <p>变体 <code>linear_combination (exp := n) e</code> 将在减去组合 <code>e</code> 前将目标提升至 <code>n</code> 次方。即，若目标为 <code>t1 = t2</code>，<code>linear_combination (exp := n) e</code> 将目标变为 <code>(t1 - t2)^n = 0</code> 后继续处理。此变体仅实现于等式线性组合（即不适用于不等式）。</p> <h2 id=linear_combination_1>linear_combination'<a class=headerlink href=#linear_combination_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.LinearCombination'.linearCombination'</code></p> <p><code>linear_combination'</code> 尝试通过创建等式列表的线性组合并将其从目标中减去以简化目标。策略通过从左至右相加等式构建线性组合，故输入假设的顺序会影响结果。若策略的 <code>norm</code> 字段设为 <code>skip</code>，则策略将直接设置用户以使用线性组合证明目标，而非归约减法。</p> <p>注：另有类似策略 <code>linear_combination</code>（无撇号）；此版本为向后兼容提供。相比此策略，<code>linear_combination</code>： * 舍弃 <code>←</code> 语法反转等式，转而使用 <code>-</code> 语法提供此操作 * 不支持两假设相乘（<code>h1 * h2</code>）、假设相除（<code>3 / h</code>）或假设取逆（<code>h⁻¹</code>） * 在用户对假设加减常数（<code>h + 3</code>）时产生冗长输出</p> <p>注：所有等式的左右侧应具相同类型，系数亦然。需有该类型的 <code>Mul</code> 和 <code>AddGroup</code> 实例。</p> <h2 id=linear_combination_2>linear_combination'<a class=headerlink href=#linear_combination_2 title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.LinearCombination'.tacticLinear_combination2____</code></p> <p><code>linear_combination'</code> 尝试通过创建一系列等式的线性组合并将其从目标中减去来简化目标。该策略会从左到右将等式相加以形成线性组合，因此输入假设的顺序会影响结果。若将策略的 <code>norm</code> 参数设为 <code>skip</code>，则该策略将仅设置用户通过线性组合来证明目标，而不会对减法进行归一化处理。</p> <p>注意：另有一个类似的策略 <code>linear_combination</code>（无撇号），此版本为向后兼容而保留。相比本策略，<code>linear_combination</code>： * 移除了使用 <code>←</code> 语法反转等式的功能，转而通过 <code>-</code> 语法实现此操作 * 不支持两个假设相乘（<code>h1 * h2</code>）、除以假设（<code>3 / h</code>）或对假设取逆（<code>h⁻¹</code>） * 当用户对假设进行加减常数（如 <code>h + 3</code>）时会产生冗余输出</p> <p>注意：所有等式的左右两侧应具有相同类型，系数也需与此类型一致。必须存在该类型的 <code>Mul</code> 和 <code>AddGroup</code> 实例。</p> <ul> <li><code>linear_combination' e</code> 中的输入 <code>e</code> 是等式证明的线性组合，表示为系数与表达式相乘后的和/差。系数可为任意表达式，表达式则为证明等式的任意证明项，通常为假设名称 <code>h1, h2, ...</code>。</li> <li><code>linear_combination' (norm := tac) e</code> 在构建线性组合后，对子目标运行“归一化策略” <code>tac</code>。</li> <li>默认的归一化策略为 <code>ring1</code>，其将闭合目标或失败。</li> <li>若目标无法立即证明，可使用 <code>ring_nf</code> 作为归一化策略以获取子目标。</li> <li>若需完全跳过归一化，可使用 <code>skip</code> 作为归一化策略。</li> <li><code>linear_combination' (exp := n) e</code> 将在减去组合 <code>e</code> 前将目标提升至第 <code>n</code> 次幂。即，若目标为 <code>t1 = t2</code>，则 <code>linear_combination' (exp := n) e</code> 将目标更改为 <code>(t1 - t2)^n = 0</code> 后再进行后续处理。此特性不适用于 <code>linear_combination2</code>。</li> <li><code>linear_combination2 e</code> 与 <code>linear_combination' e</code> 类似，但生成两个子目标而非一个：不证明 <code>(a - b) - (a' - b') = 0</code>（其中 <code>a' = b'</code> 来自 <code>e</code> 的线性组合，<code>a = b</code> 为目标），而是尝试证明 <code>a = a'</code> 和 <code>b = b'</code>。由于不使用减法，此形式也适用于半环。</li> <li>注意，可通过 <code>linear_combination' e</code> 证明的目标可能无法通过 <code>linear_combination2 e</code> 证明；通常需向 <code>e</code> 添加系数以使两侧匹配，如 <code>linear_combination2 e + c</code>。</li> <li>可使用 <code>← h</code> 反转等式，例如若 <code>h₁ : a = b</code>，则 <code>2 * (← h)</code> 为 <code>2 * b = 2 * a</code> 的证明。</li> </ul> <p>示例用法： <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>x</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℤ</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>h1</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>x</span><span class=bp>*</span><span class=n>y</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>2</span><span class=bp>*</span><span class=n>x</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=mi>1</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>h2</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>y</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>x</span><span class=bp>*</span><span class=n>y</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=bp>-</span><span class=mi>2</span><span class=bp>*</span><span class=n>y</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>linear_combination&#39;</span><span class=w> </span><span class=mi>1</span><span class=bp>*</span><span class=n>h1</span><span class=w> </span><span class=bp>-</span><span class=w> </span><span class=mi>2</span><span class=bp>*</span><span class=n>h2</span>

<span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>x</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℤ</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>h1</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>x</span><span class=bp>*</span><span class=n>y</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>2</span><span class=bp>*</span><span class=n>x</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=mi>1</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>h2</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>y</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>x</span><span class=bp>*</span><span class=n>y</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=bp>-</span><span class=mi>2</span><span class=bp>*</span><span class=n>y</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>linear_combination&#39;</span><span class=w> </span><span class=n>h1</span><span class=w> </span><span class=bp>-</span><span class=w> </span><span class=mi>2</span><span class=bp>*</span><span class=n>h2</span>

<span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>x</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℤ</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>h1</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>x</span><span class=bp>*</span><span class=n>y</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>2</span><span class=bp>*</span><span class=n>x</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=mi>1</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>h2</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>y</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>x</span><span class=bp>*</span><span class=n>y</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=bp>-</span><span class=mi>2</span><span class=bp>*</span><span class=n>y</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>linear_combination&#39;</span><span class=w> </span><span class=o>(</span><span class=n>norm</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=n>ring_nf</span><span class=o>)</span><span class=w> </span><span class=bp>-</span><span class=mi>2</span><span class=bp>*</span><span class=n>h2</span>
<span class=w>  </span><span class=c>/-</span><span class=cm> 目标：x * y + x * 2 - 1 = 0 -/</span>

<span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>x</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=n>z</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℝ</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>ha</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>2</span><span class=bp>*</span><span class=n>y</span><span class=w> </span><span class=bp>-</span><span class=w> </span><span class=n>z</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=mi>4</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>hb</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=mi>2</span><span class=bp>*</span><span class=n>x</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>z</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=bp>-</span><span class=mi>2</span><span class=o>)</span>
<span class=w>    </span><span class=o>(</span><span class=n>hc</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>2</span><span class=bp>*</span><span class=n>y</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>z</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=mi>2</span><span class=o>)</span><span class=w> </span><span class=o>:</span>
<span class=w>    </span><span class=bp>-</span><span class=mi>3</span><span class=bp>*</span><span class=n>x</span><span class=w> </span><span class=bp>-</span><span class=w> </span><span class=mi>3</span><span class=bp>*</span><span class=n>y</span><span class=w> </span><span class=bp>-</span><span class=w> </span><span class=mi>4</span><span class=bp>*</span><span class=n>z</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>linear_combination&#39;</span><span class=w> </span><span class=n>ha</span><span class=w> </span><span class=bp>-</span><span class=w> </span><span class=n>hb</span><span class=w> </span><span class=bp>-</span><span class=w> </span><span class=mi>2</span><span class=bp>*</span><span class=n>hc</span>

<span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>x</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℚ</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>h1</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=mi>3</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>h2</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=mi>3</span><span class=bp>*</span><span class=n>x</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=mi>7</span><span class=o>)</span><span class=w> </span><span class=o>:</span>
<span class=w>    </span><span class=n>x</span><span class=bp>*</span><span class=n>x</span><span class=bp>*</span><span class=n>y</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>y</span><span class=bp>*</span><span class=n>x</span><span class=bp>*</span><span class=n>y</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>6</span><span class=bp>*</span><span class=n>x</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=mi>3</span><span class=bp>*</span><span class=n>x</span><span class=bp>*</span><span class=n>y</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>14</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>linear_combination&#39;</span><span class=w> </span><span class=n>x</span><span class=bp>*</span><span class=n>y</span><span class=bp>*</span><span class=n>h1</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>2</span><span class=bp>*</span><span class=n>h2</span>

<span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>x</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℤ</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>h1</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=bp>-</span><span class=mi>3</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>h2</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=mi>10</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=mi>2</span><span class=bp>*</span><span class=n>x</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=bp>-</span><span class=mi>6</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>linear_combination&#39;</span><span class=w> </span><span class=o>(</span><span class=n>norm</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=n>skip</span><span class=o>)</span><span class=w> </span><span class=mi>2</span><span class=bp>*</span><span class=n>h1</span>
<span class=w>  </span><span class=n>simp</span>

<span class=kd>axiom</span><span class=w> </span><span class=n>qc</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℚ</span>
<span class=kd>axiom</span><span class=w> </span><span class=n>hqc</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>qc</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=mi>2</span><span class=bp>*</span><span class=n>qc</span>

<span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℚ</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=bp>∀</span><span class=w> </span><span class=n>p</span><span class=w> </span><span class=n>q</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℚ</span><span class=o>,</span><span class=w> </span><span class=n>p</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>q</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=mi>3</span><span class=bp>*</span><span class=n>a</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>qc</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=mi>3</span><span class=bp>*</span><span class=n>b</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>2</span><span class=bp>*</span><span class=n>qc</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>linear_combination&#39;</span><span class=w> </span><span class=mi>3</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=n>h</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>hqc</span>
</code></pre></div></p> <h2 id=map_fun_tac>map_fun_tac<a class=headerlink href=#map_fun_tac title="Permanent link">&para;</a></h2> <p>定义于：<code>WittVector.mapFun.tacticMap_fun_tac</code></p> <p>用于展示 <code>mapFun</code> 遵守环运算的辅助策略。</p> <h2 id=map_tacs>map_tacs<a class=headerlink href=#map_tacs title="Permanent link">&para;</a></h2> <p>定义于：<code>Batteries.Tactic.«tacticMap_tacs[_;]»</code></p> <p>假设存在 <code>n</code> 个目标，<code>map_tacs [t1; t2; ...; tn]</code> 将各个 <code>ti</code> 应用于对应的目标，并保留生成的子目标。</p> <h2 id=match>match<a class=headerlink href=#match title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.match</code></p> <p><code>match</code> 对一个或多个表达式进行模式匹配分析。参见<a href=https://lean-lang.org/theorem_proving_in_lean4/induction_and_recursion.html>归纳与递归</a>。<code>match</code> 策略的语法与项模式 <code>match</code> 相同，但匹配分支为策略而非表达式。 <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>n</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Nat</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=k>match</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=k>with</span>
<span class=w>  </span><span class=bp>|</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=bp>=&gt;</span><span class=w> </span><span class=n>rfl</span>
<span class=w>  </span><span class=bp>|</span><span class=w> </span><span class=n>i</span><span class=bp>+</span><span class=mi>1</span><span class=w> </span><span class=bp>=&gt;</span><span class=w> </span><span class=n>simp</span>
</code></pre></div></p> <h2 id=match_1>match<a class=headerlink href=#match_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Batteries.Tactic.«tacticMatch_,,With.»</code></p> <p>语法 <code>match ⋯ with.</code> 已弃用，建议改用 <code>nomatch ⋯</code>。两者现均支持多个判别式。</p> <h2 id=match_scalars>match_scalars<a class=headerlink href=#match_scalars title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.Module.tacticMatch_scalars</code></p> <p>当目标为类型 <code>M</code>（<code>M</code> 为 <code>AddCommMonoid</code>）中的等式时，将目标的左侧和右侧解析为某半环 <code>R</code> 上 <code>M</code> 原子的线性组合，并将目标简化为各原子对应的 <code>R</code> 系数间的等式。</p> <p>例如，以下代码生成目标 <code>⊢ a * 1 + b * 1 = (b + a) * 1</code>： <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>[</span><span class=n>AddCommMonoid</span><span class=w> </span><span class=n>M</span><span class=o>]</span><span class=w> </span><span class=o>[</span><span class=n>Semiring</span><span class=w> </span><span class=n>R</span><span class=o>]</span><span class=w> </span><span class=o>[</span><span class=n>Module</span><span class=w> </span><span class=n>R</span><span class=w> </span><span class=n>M</span><span class=o>]</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>R</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>x</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>M</span><span class=o>)</span><span class=w> </span><span class=o>:</span>
<span class=w>    </span><span class=n>a</span><span class=w> </span><span class=bp>•</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=bp>•</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=o>(</span><span class=n>b</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>a</span><span class=o>)</span><span class=w> </span><span class=bp>•</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>match_scalars</span>
</code></pre></div></p> <p>以下代码生成两个目标：来自原子 <code>x</code> 的 <code>⊢ a * (a * 1) + b * (b * 1) = 1</code> 和来自原子 <code>y</code> 的 <code>⊢ a * -(b * 1) + b * (a * 1) = 0</code>： <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>[</span><span class=n>AddCommGroup</span><span class=w> </span><span class=n>M</span><span class=o>]</span><span class=w> </span><span class=o>[</span><span class=n>Ring</span><span class=w> </span><span class=n>R</span><span class=o>]</span><span class=w> </span><span class=o>[</span><span class=n>Module</span><span class=w> </span><span class=n>R</span><span class=w> </span><span class=n>M</span><span class=o>]</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>R</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>x</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>M</span><span class=o>)</span><span class=w> </span><span class=o>:</span>
<span class=w>    </span><span class=n>a</span><span class=w> </span><span class=bp>•</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=bp>•</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>-</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=bp>•</span><span class=w> </span><span class=n>y</span><span class=o>)</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=o>(</span><span class=n>b</span><span class=w> </span><span class=bp>•</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>•</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=bp>•</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=bp>•</span><span class=w> </span><span class=n>x</span><span class=o>)</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>match_scalars</span>
</code></pre></div></p> <p>以下代码生成目标 <code>⊢ -2 * (a * 1) = a * (-2 * 1)</code>： <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>[</span><span class=n>AddCommGroup</span><span class=w> </span><span class=n>M</span><span class=o>]</span><span class=w> </span><span class=o>[</span><span class=n>Ring</span><span class=w> </span><span class=n>R</span><span class=o>]</span><span class=w> </span><span class=o>[</span><span class=n>Module</span><span class=w> </span><span class=n>R</span><span class=w> </span><span class=n>M</span><span class=o>]</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>R</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>x</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>M</span><span class=o>)</span><span class=w> </span><span class=o>:</span>
<span class=w>    </span><span class=bp>-</span><span class=o>(</span><span class=mi>2</span><span class=o>:</span><span class=n>R</span><span class=o>)</span><span class=w> </span><span class=bp>•</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>•</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>•</span><span class=w> </span><span class=o>(</span><span class=bp>-</span><span class=mi>2</span><span class=o>:</span><span class=n>ℤ</span><span class=o>)</span><span class=w> </span><span class=bp>•</span><span class=w> </span><span class=n>x</span><span class=w>  </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>match_scalars</span>
</code></pre></div></p> <p><code>match_scalars</code> 策略生成的目标的标量类型是遇到的最大标量类型。例如，若 <code>ℕ</code>、<code>ℚ</code> 和特征零域 <code>K</code> 同时作为标量出现，则生成的目标为 <code>K</code> 中的等式。策略内部使用 <code>push_cast</code> 的变体将其他类型的标量解释为此最大类型。</p> <p>若遇到的标量类型集合非全序（即对于所有遇到的环 <code>R</code> 和 <code>S</code>，不存在 <code>Algebra R S</code> 或 <code>Algebra S R</code>），则 <code>match_scalars</code> 策略失败。</p> <h2 id=match_target>match_target<a class=headerlink href=#match_target title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.tacticMatch_target_</code></p> <h2 id=measurability>measurability<a class=headerlink href=#measurability title="Permanent link">&para;</a></h2> <p>定义于：<code>tacticMeasurability</code></p> <p><code>measurability</code> 策略用于解决形如 <code>Measurable f</code>、<code>AEMeasurable f</code>、<code>StronglyMeasurable f</code>、<code>AEStronglyMeasurable f μ</code> 或 <code>MeasurableSet s</code> 的目标，通过应用带有 <code>measurability</code> 用户属性的引理。</p> <h2 id=measurability_1>measurability!<a class=headerlink href=#measurability_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>measurability!</code></p> <h2 id=measurability_2>measurability!?<a class=headerlink href=#measurability_2 title="Permanent link">&para;</a></h2> <p>定义于：<code>measurability!?</code></p> <h2 id=measurability_3>measurability?<a class=headerlink href=#measurability_3 title="Permanent link">&para;</a></h2> <p>定义于：<code>tacticMeasurability?</code></p> <p><code>measurability?</code> 策略用于解决形如 <code>Measurable f</code>、<code>AEMeasurable f</code>、<code>StronglyMeasurable f</code>、<code>AEStronglyMeasurable f μ</code> 或 <code>MeasurableSet s</code> 的目标，通过应用带有 <code>measurability</code> 用户属性的引理，并在成功时建议可替换当前策略调用的更快证明脚本。</p> <h2 id=mem_tac>mem_tac<a class=headerlink href=#mem_tac title="Permanent link">&para;</a></h2> <p>定义于：<code>AlgebraicGeometry.ProjIsoSpecTopComponent.FromSpec.tacticMem_tac</code></p> <h2 id=mem_tac_aux>mem_tac_aux<a class=headerlink href=#mem_tac_aux title="Permanent link">&para;</a></h2> <p>定义于：<code>AlgebraicGeometry.ProjIsoSpecTopComponent.FromSpec.tacticMem_tac_aux</code></p> <h2 id=mfld_set_tac>mfld_set_tac<a class=headerlink href=#mfld_set_tac title="Permanent link">&para;</a></h2> <p>定义于：<code>Tactic.MfldSetTac.mfldSetTac</code></p> <p>一个基础的策略，用于证明流形中出现的集合相等或包含关系。</p> <h2 id=mod_cases>mod_cases<a class=headerlink href=#mod_cases title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.ModCases.«tacticMod_cases_:_%_»</code></p> <ul> <li>策略 <code>mod_cases h : e % 3</code> 将对 <code>e</code> 进行情况分析。若 <code>e : ℤ</code>，则生成包含假设 <code>h : e ≡ 0 [ZMOD 3]</code>、<code>h : e ≡ 1 [ZMOD 3]</code>、<code>h : e ≡ 2 [ZMOD 3]</code> 的子目标。若 <code>e : ℕ</code>，则类似处理，但使用 <code>[MOD 3]</code> 替代 <code>[ZMOD 3]</code>。</li> <li>通常，当 <code>n</code> 为正数且 <code>e</code> 为 <code>ℕ</code> 或 <code>ℤ</code> 类型表达式时，<code>mod_cases h : e % n</code> 有效。</li> <li>若省略 <code>h</code>，如 <code>mod_cases e % n</code>，将默认命名为 <code>H</code>。</li> </ul> <h2 id=module>module<a class=headerlink href=#module title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.Module.tacticModule</code></p> <p>对于目标为 <code>M</code> 类型等式（<code>M</code> 为加法交换幺半群）的情况，将目标的左侧和右侧解析为交换半环 <code>R</code> 上 <code>M</code> 原子的线性组合，并通过检查每个原子的左右系数在 <code>R</code> 中环归一化后相同来证明目标。</p> <p>（若系数相等性证明需要比环归一化更复杂的推理，请使用 <code>match_scalars</code> 策略，并手动证明系数相等性。）</p> <p><code>module</code> 策略示例： <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>[</span><span class=n>AddCommMonoid</span><span class=w> </span><span class=n>M</span><span class=o>]</span><span class=w> </span><span class=o>[</span><span class=n>CommSemiring</span><span class=w> </span><span class=n>R</span><span class=o>]</span><span class=w> </span><span class=o>[</span><span class=n>Module</span><span class=w> </span><span class=n>R</span><span class=w> </span><span class=n>M</span><span class=o>]</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>R</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>x</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>M</span><span class=o>)</span><span class=w> </span><span class=o>:</span>
<span class=w>    </span><span class=n>a</span><span class=w> </span><span class=bp>•</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=bp>•</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=o>(</span><span class=n>b</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>a</span><span class=o>)</span><span class=w> </span><span class=bp>•</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>module</span>

<span class=kd>example</span><span class=w> </span><span class=o>[</span><span class=n>AddCommMonoid</span><span class=w> </span><span class=n>M</span><span class=o>]</span><span class=w> </span><span class=o>[</span><span class=n>Field</span><span class=w> </span><span class=n>K</span><span class=o>]</span><span class=w> </span><span class=o>[</span><span class=n>CharZero</span><span class=w> </span><span class=n>K</span><span class=o>]</span><span class=w> </span><span class=o>[</span><span class=n>Module</span><span class=w> </span><span class=n>K</span><span class=w> </span><span class=n>M</span><span class=o>]</span><span class=w> </span><span class=o>(</span><span class=n>x</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>M</span><span class=o>)</span><span class=w> </span><span class=o>:</span>
<span class=w>    </span><span class=o>(</span><span class=mi>2</span><span class=o>:</span><span class=n>K</span><span class=o>)</span><span class=bp>⁻¹</span><span class=w> </span><span class=bp>•</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=o>(</span><span class=mi>3</span><span class=o>:</span><span class=n>K</span><span class=o>)</span><span class=bp>⁻¹</span><span class=w> </span><span class=bp>•</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=o>(</span><span class=mi>6</span><span class=o>:</span><span class=n>K</span><span class=o>)</span><span class=bp>⁻¹</span><span class=w> </span><span class=bp>•</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>module</span>

<span class=kd>example</span><span class=w> </span><span class=o>[</span><span class=n>AddCommGroup</span><span class=w> </span><span class=n>M</span><span class=o>]</span><span class=w> </span><span class=o>[</span><span class=n>CommRing</span><span class=w> </span><span class=n>R</span><span class=o>]</span><span class=w> </span><span class=o>[</span><span class=n>Module</span><span class=w> </span><span class=n>R</span><span class=w> </span><span class=n>M</span><span class=o>]</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>R</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>v</span><span class=w> </span><span class=n>w</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>M</span><span class=o>)</span><span class=w> </span><span class=o>:</span>
<span class=w>    </span><span class=o>(</span><span class=mi>1</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>^</span><span class=w> </span><span class=mi>2</span><span class=o>)</span><span class=w> </span><span class=bp>•</span><span class=w> </span><span class=o>(</span><span class=n>v</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>w</span><span class=o>)</span><span class=w> </span><span class=bp>-</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>•</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=bp>•</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=bp>-</span><span class=w> </span><span class=n>w</span><span class=o>)</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=o>(</span><span class=mi>1</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>^</span><span class=w> </span><span class=mi>2</span><span class=o>)</span><span class=w> </span><span class=bp>•</span><span class=w> </span><span class=n>w</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>module</span>

<span class=kd>example</span><span class=w> </span><span class=o>[</span><span class=n>AddCommGroup</span><span class=w> </span><span class=n>M</span><span class=o>]</span><span class=w> </span><span class=o>[</span><span class=n>CommRing</span><span class=w> </span><span class=n>R</span><span class=o>]</span><span class=w> </span><span class=o>[</span><span class=n>Module</span><span class=w> </span><span class=n>R</span><span class=w> </span><span class=n>M</span><span class=o>]</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=n>μ</span><span class=w> </span><span class=n>ν</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>R</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>x</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>M</span><span class=o>)</span><span class=w> </span><span class=o>:</span>
<span class=w>    </span><span class=o>(</span><span class=n>μ</span><span class=w> </span><span class=bp>-</span><span class=w> </span><span class=n>ν</span><span class=o>)</span><span class=w> </span><span class=bp>•</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>•</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=bp>•</span><span class=w> </span><span class=n>μ</span><span class=w> </span><span class=bp>•</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=bp>•</span><span class=w> </span><span class=n>ν</span><span class=w> </span><span class=bp>•</span><span class=w> </span><span class=n>y</span><span class=o>)</span><span class=w> </span><span class=bp>-</span><span class=w> </span><span class=n>ν</span><span class=w> </span><span class=bp>•</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=bp>•</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=bp>•</span><span class=w> </span><span class=n>y</span><span class=o>)</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>module</span>
</code></pre></div></p> <h2 id=monicity>monicity<a class=headerlink href=#monicity title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.ComputeDegree.monicityMacro</code></p> <p><code>monicity</code> 尝试解决形如 <code>Monic f</code> 的目标。它将目标转换为 <code>natDegree f ≤ n</code> 和 <code>f.coeff n = 1</code>，并在这些子目标上调用 <code>compute_degree</code>。</p> <p>变体 <code>monicity!</code> 类似 <code>monicity</code>，但调用 <code>compute_degree!</code> 处理子目标。</p> <h2 id=monicity_1>monicity!<a class=headerlink href=#monicity_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.ComputeDegree.tacticMonicity!</code></p> <h2 id=mono>mono<a class=headerlink href=#mono title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.Monotonicity.mono</code></p> <p><code>mono</code> 重复应用单调性规则和局部假设。例如： <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>x</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=n>z</span><span class=w> </span><span class=n>k</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℤ</span><span class=o>)</span>
<span class=w>    </span><span class=o>(</span><span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=mi>3</span><span class=w> </span><span class=bp>≤</span><span class=w> </span><span class=o>(</span><span class=mi>4</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℤ</span><span class=o>))</span>
<span class=w>    </span><span class=o>(</span><span class=n>h&#39;</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>z</span><span class=w> </span><span class=bp>≤</span><span class=w> </span><span class=n>y</span><span class=o>)</span><span class=w> </span><span class=o>:</span>
<span class=w>    </span><span class=o>(</span><span class=n>k</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>3</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>x</span><span class=o>)</span><span class=w> </span><span class=bp>-</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=bp>≤</span><span class=w> </span><span class=o>(</span><span class=n>k</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>4</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>x</span><span class=o>)</span><span class=w> </span><span class=bp>-</span><span class=w> </span><span class=n>z</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>mono</span>
</code></pre></div></p> <h2 id=monoidal>monoidal<a class=headerlink href=#monoidal title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.Monoidal.tacticMonoidal</code></p> <p>利用幺半范畴的连贯定理解决幺半范畴中的方程，其中两边仅通过用不同但同源同目标的幺半结构态射（结合子、单位子、恒等态射）替换字符串而不同。</p> <p>例如，<code>monoidal</code> 可处理形如 <code>a ≫ f ≫ b ≫ g ≫ c = a' ≫ f ≫ b' ≫ g ≫ c'</code> 的目标，其中 <code>a = a'</code>、<code>b = b'</code> 和 <code>c = c'</code> 可通过 <code>monoidal_coherence</code> 证明。</p> <h2 id=monoidal_coherence>monoidal_coherence<a class=headerlink href=#monoidal_coherence title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.Monoidal.tacticMonoidal_coherence</code></p> <p>关闭形如 <code>η = θ</code> 的目标，其中 <code>η</code> 和 <code>θ</code> 为由结合子、单位子和恒等态射组成的2-同构。 <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>{</span><span class=n>C</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=kt>Type</span><span class=o>}</span><span class=w> </span><span class=o>[</span><span class=n>Category</span><span class=w> </span><span class=n>C</span><span class=o>]</span><span class=w> </span><span class=o>[</span><span class=n>MonoidalCategory</span><span class=w> </span><span class=n>C</span><span class=o>]</span><span class=w> </span><span class=o>:</span>
<span class=w>  </span><span class=o>(</span><span class=bp>λ</span><span class=n>_</span><span class=w> </span><span class=o>(</span><span class=mi>𝟙</span><span class=n>_</span><span class=w> </span><span class=n>C</span><span class=o>))</span><span class=bp>.</span><span class=n>hom</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=o>(</span><span class=n>ρ_</span><span class=w> </span><span class=o>(</span><span class=mi>𝟙</span><span class=n>_</span><span class=w> </span><span class=n>C</span><span class=o>))</span><span class=bp>.</span><span class=n>hom</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>monoidal_coherence</span>
</code></pre></div></p> <h2 id=monoidal_nf>monoidal_nf<a class=headerlink href=#monoidal_nf title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.Monoidal.tacticMonoidal_nf</code></p> <p>将等式的两边规范化。</p> <h2 id=monoidal_simps>monoidal_simps<a class=headerlink href=#monoidal_simps title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.Coherence.monoidal_simps</code></p> <p>用于将幺半范畴中的态射重写为范式的简化规则。</p> <h2 id=move_add>move_add<a class=headerlink href=#move_add title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.MoveAdd.tacticMove_add_</code></p> <p><code>move_add</code> 策略重新排列表达式中的加数。调用 <code>move_add [a, ← b, ...]</code> 将 <code>a, b,...</code> 与主目标中的加数匹配，并将 <code>a</code> 移至每个加法的最右端，<code>b</code> 移至最左端。箭头 <code>←</code> 决定移动方向。</p> <p>输入 <code>a, b,...</code> 可为任意项，含占位符。策略使用与每个输入项统一的首个“新”加数。</p> <p>乘法变体为 <code>move_mul</code>。</p> <p>通用二元结合交换操作策略为 <code>move_oper</code>，需提供操作符首符号的项。例如，<code>move_oper HAdd.hAdd [...]</code> 等效于 <code>move_add</code>，而 <code>move_oper Max.max [...]</code> 重新排列 <code>max</code>。</p> <h2 id=move_mul>move_mul<a class=headerlink href=#move_mul title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.MoveAdd.tacticMove_mul_</code></p> <p><code>move_mul</code> 策略重新排列表达式中的乘数，操作方式与 <code>move_add</code> 类似，但针对乘法项。</p> <p>存在一个称为 <code>move_mul</code> 的乘法变体。</p> <p>还有一种针对“二元结合交换运算”的通用策略：<code>move_oper</code>。在这种情况下，语法要求首先提供一个头符号为该运算的项。例如，<code>move_oper HAdd.hAdd [...]</code> 与 <code>move_add</code> 相同，而 <code>move_oper Max.max [...]</code>则会重新排列 <code>max</code>。</p> <h2 id=move_oper>move_oper<a class=headerlink href=#move_oper title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.MoveAdd.moveOperTac</code></p> <p>策略 <code>move_add</code> 用于重新排列表达式中的加数。调用 <code>move_add [a, ← b, ...]</code> 会将 <code>a, b, ...</code> 与主目标中的加数进行匹配。然后将每个加法中出现的 <code>a</code> 移动到最右侧，<code>b</code> 移动到最左侧。加数移动的方向由箭头 <code>←</code> 的存在与否决定。</p> <p>输入 <code>a, b, ...</code> 可以是任何项，也可以包含下划线。该策略使用第一个与每个给定输入项统一的新加数。</p> <p>存在一个乘法变体，称为 <code>move_mul</code>。</p> <p>还有一种针对“二元结合交换运算”的通用策略：<code>move_oper</code>。在这种情况下，语法要求首先提供一个头符号为该运算的项。例如，<code>move_oper HAdd.hAdd [...]</code> 与 <code>move_add</code> 相同，而 <code>move_oper Max.max [...]</code>则会重新排列 <code>max</code>。</p> <h2 id=mv_bisim>mv_bisim<a class=headerlink href=#mv_bisim title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.MvBisim.tacticMv_bisim___With___</code></p> <p>通过双模拟进行证明的策略</p> <h2 id=native_decide>native_decide<a class=headerlink href=#native_decide title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.nativeDecide</code></p> <p><code>native_decide</code> 是 <code>decide +native</code> 的同义词。它将尝试通过合成一个 <code>Decidable p</code> 的实例并评估为 <code>isTrue ..</code> 来证明类型为 <code>p</code> 的目标。与 <code>decide</code> 不同，此方法使用 <code>#eval</code> 来评估可判定性实例。</p> <p>由于此方法将整个 Lean 编译器添加到可信部分，并且定理使用此方法或间接依赖它们的定理在 <code>#print axioms</code> 中会显示 <code>Lean.ofReduceBool</code> 公理，因此需谨慎使用。然而，由于它是编译的，因此在处理非常大的计算时，这可能比使用 <code>decide</code> 更高效，这也是信任外部程序运行结果的一种方式。 <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=o>(</span><span class=n>List.range</span><span class=w> </span><span class=mi>1000</span><span class=o>)</span><span class=bp>.</span><span class=n>length</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=mi>1000</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span><span class=w> </span><span class=n>native_decide</span>
</code></pre></div></p> <h2 id=next>next<a class=headerlink href=#next title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.«tacticNext_=&gt;_»</code></p> <p><code>next =&gt; tac</code> 聚焦于下一个目标并使用 <code>tac</code> 解决它，否则失败。 <code>next x₁ ... xₙ =&gt; tac</code> 还会将最近 <code>n</code> 个具有不可访问名称的假设重命名为给定名称。</p> <h2 id=nlinarith>nlinarith<a class=headerlink href=#nlinarith title="Permanent link">&para;</a></h2> <p>定义于：<code>nlinarith</code></p> <p><code>linarith</code> 的扩展，通过一些预处理使其能够解决某些非线性算术问题。（基于 Coq 的 <code>nra</code> 策略。）有关选项的可用语法，请参见 <code>linarith</code>，这些选项由 <code>nlinarith</code> 继承；即 <code>nlinarith!</code> 和 <code>nlinarith only [h1, h2]</code> 均与 <code>linarith</code> 中相同。预处理如下：</p> <ul> <li>对于假设或目标中的每个子项 <code>a ^ 2</code> 或 <code>a * a</code>，将假设 <code>0 ≤ a ^ 2</code> 或 <code>0 ≤ a * a</code> 添加到上下文中。</li> <li>对于上下文中的每对假设 <code>a1 R1 b1</code> 和 <code>a2 R2 b2</code>，其中 <code>R1, R2 ∈ {&lt;, ≤, =}</code>，将假设 <code>0 R' (b1 - a1) * (b2 - a2)</code> 添加到上下文中（非递归地），其中 <code>R ∈ {&lt;, ≤, =}</code> 是从 <code>R1, R2</code> 派生的适当比较。</li> </ul> <h2 id=nlinarith_1>nlinarith!<a class=headerlink href=#nlinarith_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>tacticNlinarith!_</code></p> <p><code>linarith</code> 的扩展，通过一些预处理使其能够解决某些非线性算术问题。（基于 Coq 的 <code>nra</code> 策略。）有关选项的可用语法，请参见 <code>linarith</code>，这些选项由 <code>nlinarith</code> 继承；即 <code>nlinarith!</code> 和 <code>nlinarith only [h1, h2]</code> 均与 <code>linarith</code> 中相同。预处理如下：</p> <ul> <li>对于假设或目标中的每个子项 <code>a ^ 2</code> 或 <code>a * a</code>，将假设 <code>0 ≤ a ^ 2</code> 或 <code>0 ≤ a * a</code> 添加到上下文中。</li> <li>对于上下文中的每对假设 <code>a1 R1 b1</code> 和 <code>a2 R2 b2</code>，其中 <code>R1, R2 ∈ {&lt;, ≤, =}</code>，将假设 <code>0 R' (b1 - a1) * (b2 - a2)</code> 添加到上下文中（非递归地），其中 <code>R ∈ {&lt;, ≤, =}</code> 是从 <code>R1, R2</code> 派生的适当比较。</li> </ul> <h2 id=nofun>nofun<a class=headerlink href=#nofun title="Permanent link">&para;</a></h2> <p>定义于：`Lean.Parser.Tactic.tacticNofun_</p> <p>策略 <code>nofun</code> 是 <code>exact nofun</code> 的简写：它引入假设，然后执行空模式匹配，如果引入的模式不可能，则关闭目标。</p> <h2 id=nomatch>nomatch<a class=headerlink href=#nomatch title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.«tacticNomatch_,,»</code></p> <p>策略 <code>nomatch h</code> 是 <code>exact nomatch h</code> 的简写。</p> <h2 id=noncomm_ring>noncomm_ring<a class=headerlink href=#noncomm_ring title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.NoncommRing.noncomm_ring</code></p> <p>用于简化非交换环中等式的策略。</p> <p>示例： <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>{</span><span class=n>R</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=kt>Type</span><span class=bp>*</span><span class=o>}</span><span class=w> </span><span class=o>[</span><span class=n>Ring</span><span class=w> </span><span class=n>R</span><span class=o>]</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>R</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=o>(</span><span class=n>b</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=bp>-</span><span class=w> </span><span class=n>b</span><span class=o>)</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>noncomm_ring</span>
</code></pre></div></p> <p>您可以使用 <code>noncomm_ring [h]</code> 来同时利用 <code>h</code> 进行简化。</p> <h2 id=nontriviality>nontriviality<a class=headerlink href=#nontriviality title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.Nontriviality.nontriviality</code></p> <p>尝试生成 <code>Nontrivial α</code> 假设。</p> <p>该策略首先检查是否已存在 <code>Nontrivial α</code> 实例，然后再尝试使用其他技术合成一个。</p> <p>如果目标是一个（不）等式，则类型 <code>α</code> 从目标中推断得出。否则，需要在策略调用中指定类型，如 <code>nontriviality α</code>。</p> <p><code>nontriviality</code> 策略首先查找假设中的严格不等式，并使用这些直接推导 <code>Nontrivial</code> 实例。</p> <p>否则，它将执行 <code>Subsingleton α ∨ Nontrivial α</code> 的情况分割，并尝试使用 <code>simp [h₁, h₂, ..., hₙ, nontriviality]</code> 解除 <code>Subsingleton</code> 目标，其中 <code>[h₁, h₂, ..., hₙ]</code> 是可以传递给 <code>nontriviality</code> 的附加 <code>simp</code> 引理列表，使用语法 <code>nontriviality α using h₁, h₂, ..., hₙ</code>。</p> <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>{</span><span class=n>R</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=kt>Type</span><span class=o>}</span><span class=w> </span><span class=o>[</span><span class=n>OrderedRing</span><span class=w> </span><span class=n>R</span><span class=o>]</span><span class=w> </span><span class=o>{</span><span class=n>a</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>R</span><span class=o>}</span><span class=w> </span><span class=o>(</span><span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=n>a</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>nontriviality</span><span class=w> </span><span class=c1>-- 现在有一个 `Nontrivial R` 假设可用。</span>
<span class=w>  </span><span class=n>assumption</span>
</code></pre></div> <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>{</span><span class=n>R</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=kt>Type</span><span class=o>}</span><span class=w> </span><span class=o>[</span><span class=n>CommRing</span><span class=w> </span><span class=n>R</span><span class=o>]</span><span class=w> </span><span class=o>{</span><span class=n>r</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>R</span><span class=o>}</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>r</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=n>r</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>nontriviality</span><span class=w> </span><span class=c1>-- 现在有一个 `Nontrivial R` 假设可用。</span>
<span class=w>  </span><span class=n>apply</span><span class=w> </span><span class=n>mul_comm</span>
</code></pre></div> <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>{</span><span class=n>R</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=kt>Type</span><span class=o>}</span><span class=w> </span><span class=o>[</span><span class=n>OrderedRing</span><span class=w> </span><span class=n>R</span><span class=o>]</span><span class=w> </span><span class=o>{</span><span class=n>a</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>R</span><span class=o>}</span><span class=w> </span><span class=o>(</span><span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=n>a</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=o>(</span><span class=mi>2</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℕ</span><span class=o>)</span><span class=w> </span><span class=bp>∣</span><span class=w> </span><span class=mi>4</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>nontriviality</span><span class=w> </span><span class=n>R</span><span class=w> </span><span class=c1>-- 现在有一个 `Nontrivial R` 假设可用。</span>
<span class=w>  </span><span class=n>dec_trivial</span>
</code></pre></div> <div class=highlight><pre><span></span><code><span class=kd>def</span><span class=w> </span><span class=n>myeq</span><span class=w> </span><span class=o>{</span><span class=n>α</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=kt>Type</span><span class=o>}</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>α</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=kt>Prop</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>b</span>

<span class=kd>example</span><span class=w> </span><span class=o>{</span><span class=n>α</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=kt>Type</span><span class=o>}</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>α</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>b</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>myeq</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>success_if_fail</span><span class=w> </span><span class=n>nontriviality</span><span class=w> </span><span class=n>α</span><span class=w> </span><span class=c1>-- 失败</span>
<span class=w>  </span><span class=n>nontriviality</span><span class=w> </span><span class=n>α</span><span class=w> </span><span class=n>using</span><span class=w> </span><span class=n>myeq</span><span class=w> </span><span class=c1>-- 现在有一个 `Nontrivial α` 假设可用</span>
<span class=w>  </span><span class=n>assumption</span>
</code></pre></div> <h2 id=norm_cast>norm_cast<a class=headerlink href=#norm_cast title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.tacticNorm_cast__</code></p> <p><code>norm_cast</code> 系列策略用于规范化表达式中的某些强制转换（<em>casts</em>）。 - <code>norm_cast</code> 规范化目标中的强制转换。 - <code>norm_cast at h</code> 规范化假设 <code>h</code> 中的强制转换。</p> <p>该策略基本上是 <code>simp</code> 的一个版本，使用一组特定的引理将强制转换向上移动到表达式中。因此，即使在通常不鼓励使用非终止 <code>simp</code> 调用的情况下（由于脆弱性），<code>norm_cast</code> 也被认为是安全的。它还对数字有特殊处理。</p> <p>例如，给定假设 <div class=highlight><pre><span></span><code><span class=n>a</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℤ</span>
<span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=bp>↑</span><span class=n>a</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=bp>↑</span><span class=n>b</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=o>(</span><span class=mi>10</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℚ</span><span class=o>)</span>
</code></pre></div> 编写 <code>norm_cast at h</code> 将 <code>h</code> 转换为 <div class=highlight><pre><span></span><code><span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=mi>10</span>
</code></pre></div></p> <p>还有一些基本策略的变体，它们在操作过程中使用 <code>norm_cast</code> 规范化表达式，使其更灵活地接受表达式（我们称其为*模* <code>norm_cast</code> 效果的策略）： - <code>exact_mod_cast</code> 对应 <code>exact</code>，<code>apply_mod_cast</code> 对应 <code>apply</code>。编写 <code>exact_mod_cast h</code> 和 <code>apply_mod_cast h</code> 将在使用 <code>exact h</code> 或 <code>apply h</code> 之前规范化目标和 <code>h</code> 中的强制转换。 - <code>rw_mod_cast</code> 对应 <code>rw</code>。它在重写之间应用 <code>norm_cast</code>。 - <code>assumption_mod_cast</code> 对应 <code>assumption</code>。这实际上是 <code>norm_cast at *; assumption</code>，但更高效。它规范化目标中的强制转换，并对上下文中的每个假设 <code>h</code>，尝试规范化 <code>h</code> 中的强制转换并使用 <code>exact h</code>。</p> <p>另请参见 <code>push_cast</code>，它将强制转换向内移动而非向外提升。</p> <h2 id=norm_num>norm_num<a class=headerlink href=#norm_num title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.normNum</code></p> <p>规范化数值表达式。支持在<code>ℕ</code>、<code>ℤ</code>、<code>ℚ</code>、<code>ℝ</code>、<code>ℂ</code>等数值类型及部分通用代数类型上进行<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>⁻¹</code>、<code>^</code>和<code>%</code>运算，并能证明形如<code>A = B</code>、<code>A ≠ B</code>、<code>A &lt; B</code>及<code>A ≤ B</code>的目标（其中<code>A</code>和<code>B</code>为数值表达式）。此外，还包含一个相对简单的质数证明器。</p> <h2 id=norm_num1>norm_num1<a class=headerlink href=#norm_num1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.normNum1</code></p> <p><code>norm_num</code>的基础版本，不调用<code>simp</code>。</p> <h2 id=nth_rewrite>nth_rewrite<a class=headerlink href=#nth_rewrite title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.nthRewriteSeq</code></p> <p><code>nth_rewrite</code>是<code>rewrite</code>的变体，仅修改表达式第<code>n₁, ..., nₖ</code>次出现的匹配项。<code>nth_rewrite n₁ ... nₖ [eq₁, eq₂,..., eqₘ]</code>会按顺序对每个等式<code>eqᵢ</code>的第<code>n₁, ..., nₖ</code>次_出现_进行重写。计数从<code>1</code>开始，按优先顺序排列。</p> <p>例如： <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=mi>1</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=mi>5</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>nth_rewrite</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=mi>3</span><span class=w> </span><span class=o>[</span><span class=n>h</span><span class=o>]</span>
<span class=c>/-</span>
<span class=cm>a: ℕ</span>
<span class=cm>h: a = 1</span>
<span class=cm>⊢ a + 1 + 1 + a + a = 5</span>
<span class=cm>-/</span>
</code></pre></div> 可见左侧第二和第三个<code>a</code>被<code>nth_rewrite</code>重写。</p> <p>理解优先顺序的重要性，参考下例： <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Nat</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>b</span><span class=o>)</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=o>(</span><span class=n>b</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>a</span><span class=o>)</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>nth_rewrite</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=o>[</span><span class=n>Nat.add_comm</span><span class=o>]</span><span class=w> </span><span class=c1>-- ⊢ (b + a) + c = (b + a) + c</span>
</code></pre></div> 此处尽管出现参数为<code>2</code>，<code>(a + b)</code>仍被重写为<code>(b + a)</code>。这是因为在优先顺序中，第一个<code>_ + _</code>出现是将<code>a + b</code>与<code>c</code>相加，而<code>a + b</code>中的出现计为第二次。</p> <p>若通过<code>eqᵢ</code>重写引入新项<code>t</code>，则此<code>t</code>的实例在后续使用<code>eqⱼ</code>（<code>j &gt; i</code>）重写时将被计为<code>t</code>的出现。如下例所示： <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>b</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>nth_rewrite</span><span class=w> </span><span class=mi>3</span><span class=w> </span><span class=o>[</span><span class=n>h</span><span class=o>,</span><span class=w> </span><span class=n>h</span><span class=o>]</span>
<span class=c>/-</span>
<span class=cm>a b: ℕ</span>
<span class=cm>h: a = a + b</span>
<span class=cm>⊢ a + a + (a + b + b) + a + a = 0</span>
<span class=cm>-/</span>
</code></pre></div> 第一次使用<code>h</code>重写后，目标变为： <div class=highlight><pre><span></span><code><span class=c>/-</span>
<span class=cm>a b: ℕ</span>
<span class=cm>h: a = a + b</span>
<span class=cm>⊢ a + a + (a + b) + a + a = 0</span>
<span class=cm>-/</span>
</code></pre></div> 新引入的<code>a</code>恰好成为第三次出现，因此后续的<code>nth_rewrite</code>会重写该<code>a</code>。</p> <h2 id=nth_rw>nth_rw<a class=headerlink href=#nth_rw title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.nthRwSeq</code></p> <p><code>nth_rw</code>是<code>rw</code>的变体，仅修改表达式第<code>n₁, ..., nₖ</code>次出现的匹配项。类似<code>rw</code>，但不同于<code>nth_rewrite</code>，它会在重写后尝试使用<code>rfl</code>闭合目标。<code>nth_rw n₁ ... nₖ [eq₁, eq₂,..., eqₘ]</code>会按顺序对每个等式<code>eqᵢ</code>的第<code>n₁, ..., nₖ</code>次_出现_进行重写。计数从<code>1</code>开始，按优先顺序排列。例如： <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=mi>1</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=mi>5</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>nth_rw</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=mi>3</span><span class=w> </span><span class=o>[</span><span class=n>h</span><span class=o>]</span>
<span class=c>/-</span>
<span class=cm>a: ℕ</span>
<span class=cm>h: a = 1</span>
<span class=cm>⊢ a + 1 + 1 + a + a = 5</span>
<span class=cm>-/</span>
</code></pre></div> 可见左侧第二和第三个<code>a</code>被<code>nth_rw</code>重写。</p> <p>理解优先顺序的重要性，参考下例： <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Nat</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>b</span><span class=o>)</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=o>(</span><span class=n>b</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>a</span><span class=o>)</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>nth_rewrite</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=o>[</span><span class=n>Nat.add_comm</span><span class=o>]</span><span class=w> </span><span class=c1>-- ⊢ (b + a) + c = (b + a) + c</span>
</code></pre></div> 此处尽管出现参数为<code>2</code>，<code>(a + b)</code>仍被重写为<code>(b + a)</code>。这是因为在优先顺序中，第一个<code>_ + _</code>出现是将<code>a + b</code>与<code>c</code>相加，而<code>a + b</code>中的出现计为第二次。</p> <p>若通过<code>eqᵢ</code>重写引入新项<code>t</code>，则此<code>t</code>的实例在后续使用<code>eqⱼ</code>（<code>j &gt; i</code>）重写时将被计为<code>t</code>的出现。如下例所示： <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>b</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>nth_rw</span><span class=w> </span><span class=mi>3</span><span class=w> </span><span class=o>[</span><span class=n>h</span><span class=o>,</span><span class=w> </span><span class=n>h</span><span class=o>]</span>
<span class=c>/-</span>
<span class=cm>a b: ℕ</span>
<span class=cm>h: a = a + b</span>
<span class=cm>⊢ a + a + (a + b + b) + a + a = 0</span>
<span class=cm>-/</span>
</code></pre></div> 第一次使用<code>h</code>重写后，目标变为： <div class=highlight><pre><span></span><code><span class=c>/-</span>
<span class=cm>a b: ℕ</span>
<span class=cm>h: a = a + b</span>
<span class=cm>⊢ a + a + (a + b) + a + a = 0</span>
<span class=cm>-/</span>
</code></pre></div> 新引入的<code>a</code>恰好成为第三次出现，因此后续的<code>nth_rw</code>会重写该<code>a</code>。</p> <p>此外，<code>nth_rw</code>会在可能时使用<code>rfl</code>闭合剩余目标。</p> <h2 id=observe>observe<a class=headerlink href=#observe title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.LibrarySearch.observe</code></p> <p><code>observe hp : p</code>断言命题<code>p</code>，并尝试使用<code>exact?</code>进行证明。若未找到证明，则策略失败。等效于<code>have hp : p := by exact?</code>。</p> <p>若省略<code>hp</code>，则使用占位符<code>this</code>。</p> <p>变体<code>observe? hp : p</code>会输出形如<code>have hp : p := proof_term</code>的追踪信息，有助于加速证明过程。</p> <h2 id=observe_1>observe?<a class=headerlink href=#observe_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.LibrarySearch.«tacticObserve?__:_Using__,,»</code></p> <p><code>observe hp : p</code>断言命题<code>p</code>，并尝试使用<code>exact?</code>进行证明。若未找到证明，则策略失败。等效于<code>have hp : p := by exact?</code>。</p> <p>若省略<code>hp</code>，则使用占位符<code>this</code>。</p> <p>变体<code>observe? hp : p</code>会输出形如<code>have hp : p := proof_term</code>的追踪信息，有助于加速证明过程。</p> <h2 id=observe_2>observe?<a class=headerlink href=#observe_2 title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.LibrarySearch.«tacticObserve?__:_»</code></p> <p><code>observe hp : p</code>断言命题<code>p</code>，并尝试使用<code>exact?</code>进行证明。若未找到证明，则策略失败。等效于<code>have hp : p := by exact?</code>。</p> <p>若省略<code>hp</code>，则使用占位符<code>this</code>。</p> <p>变体<code>observe? hp : p</code>会输出形如<code>have hp : p := proof_term</code>的追踪信息，有助于加速证明过程。</p> <h2 id=obtain>obtain<a class=headerlink href=#obtain title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.obtain</code></p> <p><code>obtain</code>策略结合了<code>have</code>和<code>rcases</code>。关于模式支持的描述，请参考<code>rcases</code>。</p> <p><div class=highlight><pre><span></span><code><span class=n>obtain</span><span class=w> </span><span class=o>⟨</span><span class=n>patt</span><span class=o>⟩</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>type</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=n>proof</span>
</code></pre></div> 等效于： <div class=highlight><pre><span></span><code><span class=k>have</span><span class=w> </span><span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>type</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=n>proof</span>
<span class=n>rcases</span><span class=w> </span><span class=n>h</span><span class=w> </span><span class=k>with</span><span class=w> </span><span class=o>⟨</span><span class=n>patt</span><span class=o>⟩</span>
</code></pre></div></p> <p>若省略<code>⟨patt⟩</code>，<code>rcases</code>将尝试推断模式。</p> <p>若省略<code>type</code>，则必须提供<code>:= proof</code>。</p> <h2 id=omega>omega<a class=headerlink href=#omega title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.omega</code></p> <p><code>omega</code>策略用于解决整数和自然数的线性算术问题。</p> <p>目前尚未成为完整的决策过程（无“dark”或“grey” shadows），但对许多问题有效。</p> <p>我们处理形如<code>x = y</code>、<code>x &lt; y</code>、<code>x ≤ y</code>及<code>k ∣ x</code>（<code>x</code>和<code>y</code>属于<code>Nat</code>或<code>Int</code>，<code>k</code>为字面量）的假设，以及这些陈述的否定形式。</p> <p>我们将不等式两侧分解为原子的线性组合。</p> <p>遇到字面整数<code>k</code>的<code>x / k</code>或<code>x % k</code>时，引入新的辅助变量及相关不等式。</p> <p>首次处理时，不执行自然数减法的分情况。若<code>omega</code>失败，则递归地对假设中的自然数减法进行分情况处理，并重试。</p> <p>选项： <div class=highlight><pre><span></span><code>omega +splitDisjunctions +splitNatSub +splitNatAbs +splitMinMax
</code></pre></div> 用于： * <code>splitDisjunctions</code>：若问题无法通过其他方式解决，拆分上下文中的任何析取。 * <code>splitNatSub</code>：对每个<code>((a - b : Nat) : Int)</code>的出现，必要时拆分<code>a ≤ b</code>。 * <code>splitNatAbs</code>：对每个<code>Int.natAbs a</code>的出现，必要时拆分<code>0 ≤ a</code>。 * <code>splitMinMax</code>：对每个<code>min a b</code>的出现，拆分<code>min a b = a ∨ min a b = b</code>。 当前所有选项默认启用。</p> <h2 id=on_goal>on_goal<a class=headerlink href=#on_goal title="Permanent link">&para;</a></h2> <p>定义于：<code>Batteries.Tactic.«tacticOn_goal-_=&gt;_»</code></p> <p><code>on_goal n =&gt; tacSeq</code>为第<code>n</code>个目标创建块作用域，并尝试在该目标上应用策略序列<code>tacSeq</code>。</p> <p><code>on_goal -n =&gt; tacSeq</code>类似，但第<code>n</code>个目标从底部开始计数。</p> <p>不要求目标必须被解决，任何生成的子目标将重新插入目标列表，替换原目标。</p> <h2 id=open>open<a class=headerlink href=#open title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.open</code></p> <p>策略<code>open Foo in tacs</code>类似于命令级的<code>open Foo</code>，但仅在策略<code>tacs</code>中打开命名空间。</p> <h2 id=order>order<a class=headerlink href=#order title="Permanent link">&para;</a></h2> <p>定义于: <code>Mathlib.Tactic.Order.tacticOrder</code></p> <p>用于在任意<code>Preorder</code>、<code>PartialOrder</code>或<code>LinearOrder</code>中解决目标的收尾策略。</p> <h2 id=peel>peel<a class=headerlink href=#peel title="Permanent link">&para;</a></h2> <p>定义于: <code>Mathlib.Tactic.Peel.peel</code></p> <p>剥离给定项和目标中的匹配量词，并引入相关变量。</p> <ul> <li><code>peel e</code> 剥离所有可还原透明度的量词，使用<code>this</code>作为剥离假设的名称。</li> <li><code>peel e with h</code> 类似<code>peel e</code>，但将剥离的假设命名为<code>h</code>。若<code>h</code>为<code>_</code>，则使用<code>this</code>作为名称。</li> <li><code>peel n e</code> 剥离<code>n</code>个量词（默认透明度）。</li> <li><code>peel n e with x y z ... h</code> 剥离<code>n</code>个量词，命名剥离的假设为<code>h</code>，并使用<code>x</code>、<code>y</code>、<code>z</code>等命名引入的变量；这些名称可为<code>_</code>。若<code>h</code>为<code>_</code>，则使用<code>this</code>作为名称。变量列表的长度无需与<code>n</code>相等。</li> <li><code>peel e with x₁ ... xₙ h</code> 等同于<code>peel n e with x₁ ... xₙ h</code>。</li> </ul> <p>另有适用于目标中iff的变体： - <code>peel n</code> 剥离iff中的<code>n</code>个量词。 - <code>peel with x₁ ... xₙ</code> 剥离iff中的<code>n</code>个量词并命名。</p> <p>给定<code>p q : ℕ → Prop</code>、<code>h : ∀ x, p x</code>及目标<code>⊢ : ∀ x, q x</code>，策略<code>peel h with x h'</code>将引入<code>x : ℕ</code>和<code>h' : p x</code>至上下文中，新目标为<code>⊢ q x</code>。此策略适用于<code>∃</code>、<code>∀ᶠ</code>及<code>∃ᶠ</code>，并可应用于一系列量词。注意，此设置逻辑上较弱，故使用此策略并非总可行。</p> <p>更复杂示例，给定假设及目标： <div class=highlight><pre><span></span><code><span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=bp>∀</span><span class=w> </span><span class=n>ε</span><span class=w> </span><span class=bp>&gt;</span><span class=w> </span><span class=o>(</span><span class=mi>0</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℝ</span><span class=o>),</span><span class=w> </span><span class=bp>∃</span><span class=w> </span><span class=n>N</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℕ</span><span class=o>,</span><span class=w> </span><span class=bp>∀</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=bp>≥</span><span class=w> </span><span class=n>N</span><span class=o>,</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=bp>/</span><span class=w> </span><span class=o>(</span><span class=n>n</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℝ</span><span class=o>)</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=n>ε</span>
<span class=bp>⊢</span><span class=w> </span><span class=bp>∀</span><span class=w> </span><span class=n>ε</span><span class=w> </span><span class=bp>&gt;</span><span class=w> </span><span class=o>(</span><span class=mi>0</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℝ</span><span class=o>),</span><span class=w> </span><span class=bp>∃</span><span class=w> </span><span class=n>N</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℕ</span><span class=o>,</span><span class=w> </span><span class=bp>∀</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=bp>≥</span><span class=w> </span><span class=n>N</span><span class=o>,</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=bp>/</span><span class=w> </span><span class=o>(</span><span class=n>n</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℝ</span><span class=o>)</span><span class=w> </span><span class=bp>≤</span><span class=w> </span><span class=n>ε</span>
</code></pre></div> （仅在<code>&lt;</code>/<code>≤</code>上不同），应用<code>peel h with ε hε N n hn h_peel</code>将得到策略状态： <div class=highlight><pre><span></span><code><span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=bp>∀</span><span class=w> </span><span class=n>ε</span><span class=w> </span><span class=bp>&gt;</span><span class=w> </span><span class=o>(</span><span class=mi>0</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℝ</span><span class=o>),</span><span class=w> </span><span class=bp>∃</span><span class=w> </span><span class=n>N</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℕ</span><span class=o>,</span><span class=w> </span><span class=bp>∀</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=bp>≥</span><span class=w> </span><span class=n>N</span><span class=o>,</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=bp>/</span><span class=w> </span><span class=o>(</span><span class=n>n</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℝ</span><span class=o>)</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=n>ε</span>
<span class=n>ε</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℝ</span>
<span class=n>hε</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=n>ε</span>
<span class=n>N</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℕ</span>
<span class=n>hn</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>N</span><span class=w> </span><span class=bp>≤</span><span class=w> </span><span class=n>n</span>
<span class=n>h_peel</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=bp>/</span><span class=w> </span><span class=o>(</span><span class=n>n</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℝ</span><span class=o>)</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=n>ε</span>
<span class=bp>⊢</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=bp>/</span><span class=w> </span><span class=o>(</span><span class=n>n</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℝ</span><span class=o>)</span><span class=w> </span><span class=bp>≤</span><span class=w> </span><span class=n>ε</span>
</code></pre></div> 目标可通过<code>exact h_peel.le</code>关闭。注意在此例中，<code>h</code>与目标逻辑等价，但<code>peel</code>无法直接用于证明目标蕴含<code>h</code>。</p> <p>此外，<code>peel</code>支持形如<code>(∀ x, p x) ↔ ∀ x, q x</code>的目标，或其它量词类似形式。此时无需提供假设或项，语法相同。因此，对此类目标，语法为<code>peel 1</code>或<code>peel with x</code>，应用后目标变为<code>p x ↔ q x</code>。<code>congr!</code>策略亦可使用<code>congr! 1 with x</code>应用于此类目标。尽管<code>congr!</code>通常应用同余引理，<code>peel</code>则专门用于最外层量词。</p> <p>用户可通过<code>... using e</code>提供项<code>e</code>以立即关闭目标。例如，<code>peel h using e</code>等价于<code>peel h; exact e</code>。<code>using</code>语法可与<code>peel</code>的其它特性结合使用。</p> <p>此策略通过反复应用如<code>forall_imp</code>、<code>Exists.imp</code>、<code>Filter.Eventually.mp</code>、<code>Filter.Frequently.mp</code>及<code>Filter.Eventually.of_forall</code>等引理实现。</p> <h2 id=pgame_wf_tac>pgame_wf_tac<a class=headerlink href=#pgame_wf_tac title="Permanent link">&para;</a></h2> <p>定义于: <code>SetTheory.PGame.tacticPgame_wf_tac</code></p> <p>处理在使用<code>PGame</code>上的良基递归定义时产生的<code>⊢ Subsequent ..</code>形式的证明义务。</p> <h2 id=pi_lower_bound>pi_lower_bound<a class=headerlink href=#pi_lower_bound title="Permanent link">&para;</a></h2> <p>定义于: <code>Real.«tacticPi_lower_bound[_,,]»</code></p> <p>为固定有理数<code>a</code>创建<code>a &lt; π</code>的证明，给定见证为满足<code>√(2 + r i) ≤ r(i+1)</code>（其中<code>r 0 = 0</code>）及<code>√(2 - r n) ≥ a/2^(n+1)</code>的有理数序列<code>√2 &lt; r 1 &lt; r 2 &lt; ... &lt; r n &lt; 2</code>。</p> <h2 id=pi_upper_bound>pi_upper_bound<a class=headerlink href=#pi_upper_bound title="Permanent link">&para;</a></h2> <p>定义于: <code>Real.«tacticPi_upper_bound[_,,]»</code></p> <p>为固定有理数<code>a</code>创建<code>π &lt; a</code>的证明，给定见证为满足<code>√(2 + r i) ≥ r(i+1)</code>（其中<code>r 0 = 0</code>）及<code>√(2 - r n) ≤ (a - 1/4^n) / 2^(n+1)</code>的有理数序列<code>√2 &lt; r 1 &lt; r 2 &lt; ... &lt; r n &lt; 2</code>。</p> <h2 id=pick_goal>pick_goal<a class=headerlink href=#pick_goal title="Permanent link">&para;</a></h2> <p>定义于: <code>Batteries.Tactic.«tacticPick_goal-_»</code></p> <p><code>pick_goal n</code>将第<code>n</code>个目标移至前端。</p> <p><code>pick_goal -n</code>将倒数第<code>n</code>个目标移至前端。</p> <p>另见<code>Tactic.rotate_goals</code>，该策略将目标从前移至后或反之。</p> <h2 id=plausible>plausible<a class=headerlink href=#plausible title="Permanent link">&para;</a></h2> <p>定义于: <code>plausibleSyntax</code></p> <p><code>plausible</code>考虑证明目标并尝试生成反驳陈述的示例。</p> <p>考虑以下证明目标：</p> <div class=highlight><pre><span></span><code><span class=n>xs</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>List</span><span class=w> </span><span class=n>Nat</span><span class=o>,</span>
<span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=bp>∃</span><span class=w> </span><span class=o>(</span><span class=n>x</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Nat</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>H</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>∈</span><span class=w> </span><span class=n>xs</span><span class=o>),</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=mi>3</span>
<span class=bp>⊢</span><span class=w> </span><span class=bp>∀</span><span class=w> </span><span class=o>(</span><span class=n>y</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Nat</span><span class=o>),</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=bp>∈</span><span class=w> </span><span class=n>xs</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=mi>5</span>
</code></pre></div> <p>局部常量将被还原，并找到<code>Testable (∀ (xs : List Nat), (∃ x ∈ xs, x &lt; 3) → (∀ y ∈ xs, y &lt; 5))</code>的实例。<code>Testable</code>实例由<code>Sampleable (List Nat)</code>、<code>Decidable (x &lt; 3)</code>及<code>Decidable (y &lt; 5)</code>的实例支持。</p> <p>示例将按大小升序创建（大致如此）。</p> <p>找到的首个反例将被打印并导致错误：</p> <div class=highlight><pre><span></span><code>===================
Found problems!
xs := [1, 28]
x := 1
y := 28
-------------------
</code></pre></div> <p>若<code>plausible</code>成功测试100个示例，其行为类似<code>admit</code>。若放弃或找到反例，则报告错误。</p> <p>有关编写自定义<code>Sampleable</code>及<code>Testable</code>实例的更多信息，请参阅<code>Testing.Plausible.Testable</code>。</p> <p>可选参数通过<code>plausible (config : { ... })</code>提供： * <code>numInst</code>（默认100）：测试属性所用的示例数量 * <code>maxSize</code>（默认100）：最终大小参数</p> <p>选项： * <code>set_option trace.plausible.decoration true</code>：打印带量词注解的命题 * <code>set_option trace.plausible.discarded true</code>：打印因不满足假设而被丢弃的示例 * <code>set_option trace.plausible.shrink.steps true</code>：追踪反例的收缩步骤 * <code>set_option trace.plausible.shrink.candidates true</code>：打印收缩每个变量时考虑的候选列表 * <code>set_option trace.plausible.instance true</code>：打印用于测试命题的<code>testable</code>实例 * <code>set_option trace.plausible.success true</code>：打印满足属性的已测试样本</p> <h2 id=pnat_positivity>pnat_positivity<a class=headerlink href=#pnat_positivity title="Permanent link">&para;</a></h2> <p>定义于: <code>Mathlib.Tactic.PNatToNat.tacticPnat_positivity</code></p> <p>为上下文中的每个<code>x : PNat</code>添加假设<code>0 &lt; (↑x : ℕ)</code>。</p> <h2 id=pnat_to_nat>pnat_to_nat<a class=headerlink href=#pnat_to_nat title="Permanent link">&para;</a></h2> <p>定义于: <code>Mathlib.Tactic.PNatToNat.tacticPnat_to_nat</code></p> <p><code>pnat_to_nat</code>将上下文中的所有<code>PNat</code>转换为<code>Nat</code>，重写相关命题。典型用例为<code>pnat_to_nat; omega</code>。</p> <h2 id=polyrith>polyrith<a class=headerlink href=#polyrith title="Permanent link">&para;</a></h2> <p>定义于: <code>Mathlib.Tactic.Polyrith.«tacticPolyrithOnly[_]»</code></p> <p>尝试通过假设（及用户指定的额外证明项）的多项式算术证明多项式等式目标。通过生成对<code>linear_combination</code>策略的适当调用来证明目标。若调用成功，则向用户建议此调用。</p> <ul> <li><code>polyrith</code>将使用本地上下文中所有相关假设。</li> <li><code>polyrith [t1, t2, t3]</code>将添加证明项t1、t2、t3至本地上下文。</li> <li><code>polyrith only [h1, h2, h3, t1, t2, t3]</code>将仅使用本地假设<code>h1</code>、<code>h2</code>、<code>h3</code>及证明项<code>t1</code>、<code>t2</code>、<code>t3</code>，忽略其余本地上下文。</li> </ul> <p>注： * 此策略需网络连接，因其通过<a href=https://sagecell.sagemath.org/ >https://sagecell.sagemath.org/</a>调用Sage的SageCell网络API。衷心感谢Sage团队及组织允许此使用。 * 此策略假设用户路径中可用<code>curl</code>。</p> <p>示例：</p> <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>x</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℚ</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>h1</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>x</span><span class=bp>*</span><span class=n>y</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>2</span><span class=bp>*</span><span class=n>x</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=mi>1</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>h2</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>y</span><span class=o>)</span><span class=w> </span><span class=o>:</span>
<span class=w>    </span><span class=n>x</span><span class=bp>*</span><span class=n>y</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=bp>-</span><span class=mi>2</span><span class=bp>*</span><span class=n>y</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>polyrith</span>
<span class=c1>-- 建议尝试：linear_combination h1 - 2 * h2</span>

<span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>x</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=n>z</span><span class=w> </span><span class=n>w</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℚ</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>hzw</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>z</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>w</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>x</span><span class=bp>*</span><span class=n>z</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>2</span><span class=bp>*</span><span class=n>y</span><span class=bp>*</span><span class=n>z</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>x</span><span class=bp>*</span><span class=n>w</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>2</span><span class=bp>*</span><span class=n>y</span><span class=bp>*</span><span class=n>w</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>polyrith</span>
<span class=c1>-- 建议尝试：linear_combination (2 * y + x) * hzw</span>

<span class=kd>axiom</span><span class=w> </span><span class=n>scary</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=bp>∀</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℚ</span><span class=o>,</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=mi>0</span>

<span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=n>d</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℚ</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=mi>0</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>h2</span><span class=o>:</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=mi>0</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>d</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>polyrith</span><span class=w> </span><span class=n>only</span><span class=w> </span><span class=o>[</span><span class=n>scary</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=n>d</span><span class=o>,</span><span class=w> </span><span class=n>h</span><span class=o>]</span>
<span class=c1>-- 建议尝试：linear_combination scary c d + h</span>
<span class=bp>```##</span><span class=w> </span><span class=n>positivity</span>
<span class=bp>定义于：</span><span class=ss>`Mathlib.Tactic.Positivity.positivity</span><span class=bp>`</span>

<span class=bp>用于解决形如</span><span class=w> </span><span class=bp>`</span><span class=mi>0</span><span class=w> </span><span class=bp>≤</span><span class=w> </span><span class=n>x</span><span class=bp>`、`</span><span class=mi>0</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=n>x</span><span class=bp>`</span><span class=w> </span><span class=bp>和</span><span class=w> </span><span class=ss>`x</span><span class=w> </span><span class=bp>≠</span><span class=w> </span><span class=mi>0</span><span class=bp>`</span><span class=w> </span><span class=bp>目标的策略。该策略根据表达式</span><span class=w> </span><span class=ss>`x</span><span class=bp>`</span><span class=w> </span><span class=bp>的语法递归工作，如果组成表达式的所有原子都能通过</span><span class=w> </span><span class=ss>`norm_num</span><span class=bp>`</span><span class=w> </span><span class=bp>证明具有正数/非负/非零的数值下界。此策略要么关闭目标，要么失败。</span>

<span class=bp>示例：</span>
<span class=bp>`</span><span class=ss>``lean</span>
<span class=kd>example</span><span class=w> </span><span class=o>{</span><span class=n>a</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℤ</span><span class=o>}</span><span class=w> </span><span class=o>(</span><span class=n>ha</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=mi>3</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=n>a</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=bp>≤</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>^</span><span class=w> </span><span class=mi>3</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>positivity</span>

<span class=kd>example</span><span class=w> </span><span class=o>{</span><span class=n>a</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℤ</span><span class=o>}</span><span class=w> </span><span class=o>(</span><span class=n>ha</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=n>a</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=bp>|</span><span class=o>(</span><span class=mi>3</span><span class=o>:</span><span class=n>ℤ</span><span class=o>)</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>a</span><span class=bp>|</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>positivity</span>

<span class=kd>example</span><span class=w> </span><span class=o>{</span><span class=n>b</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℤ</span><span class=o>}</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=bp>≤</span><span class=w> </span><span class=n>max</span><span class=w> </span><span class=o>(</span><span class=bp>-</span><span class=mi>3</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>b</span><span class=w> </span><span class=bp>^</span><span class=w> </span><span class=mi>2</span><span class=o>)</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>positivity</span>
</code></pre></div> <h2 id=pure_coherence>pure_coherence<a class=headerlink href=#pure_coherence title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.Coherence.pure_coherence</code></p> <p><code>pure_coherence</code> 利用幺半范畴的连贯性定理来证明目标。它可以证明仅由结合子、单位子和恒等态射组成的任何等式。 <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>{</span><span class=n>C</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=kt>Type</span><span class=o>}</span><span class=w> </span><span class=o>[</span><span class=n>Category</span><span class=w> </span><span class=n>C</span><span class=o>]</span><span class=w> </span><span class=o>[</span><span class=n>MonoidalCategory</span><span class=w> </span><span class=n>C</span><span class=o>]</span><span class=w> </span><span class=o>:</span>
<span class=w>  </span><span class=o>(</span><span class=bp>λ</span><span class=n>_</span><span class=w> </span><span class=o>(</span><span class=mi>𝟙</span><span class=n>_</span><span class=w> </span><span class=n>C</span><span class=o>))</span><span class=bp>.</span><span class=n>hom</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=o>(</span><span class=n>ρ_</span><span class=w> </span><span class=o>(</span><span class=mi>𝟙</span><span class=n>_</span><span class=w> </span><span class=n>C</span><span class=o>))</span><span class=bp>.</span><span class=n>hom</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>pure_coherence</span>
</code></pre></div></p> <p>用户通常只需使用 <code>coherence</code> 策略，该策略还能处理形如 <code>a ≫ f ≫ b ≫ g ≫ c = a' ≫ f ≫ b' ≫ g ≫ c'</code> 的恒等式，其中 <code>a = a'</code>、<code>b = b'</code> 和 <code>c = c'</code> 可使用 <code>pure_coherence</code> 证明。</p> <h2 id=push_cast>push_cast<a class=headerlink href=#push_cast title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.pushCast</code></p> <p><code>push_cast</code> 重写目标以将某些强制转换（<em>casts</em>）向叶节点方向内移。这使用 <code>norm_cast</code> 引理的前向方向。例如，<code>↑(a + b)</code> 将被重写为 <code>↑a + ↑b</code>。 - <code>push_cast</code> 将目标中的强制转换内移。 - <code>push_cast at h</code> 将假设 <code>h</code> 中的强制转换内移。 可结合额外简化引理使用，例如 <code>push_cast [Int.add_zero]</code>。</p> <p>示例： <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Nat</span><span class=o>)</span>
<span class=w>    </span><span class=o>(</span><span class=n>h1</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=o>((</span><span class=n>a</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Nat</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Int</span><span class=o>)</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=mi>10</span><span class=o>)</span>
<span class=w>    </span><span class=o>(</span><span class=n>h2</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=o>((</span><span class=n>a</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Nat</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Int</span><span class=o>)</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=mi>10</span><span class=o>)</span><span class=w> </span><span class=o>:</span>
<span class=w>    </span><span class=o>((</span><span class=n>a</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Nat</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Int</span><span class=o>)</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=mi>10</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=c>/-</span>
<span class=cm>  h1 : ↑(a + b) = 10</span>
<span class=cm>  h2 : ↑(a + b + 0) = 10</span>
<span class=cm>  ⊢ ↑(a + b) = 10</span>
<span class=cm>  -/</span>
<span class=w>  </span><span class=n>push_cast</span>
<span class=w>  </span><span class=c>/-</span><span class=cm> 现在</span>
<span class=cm>  ⊢ ↑a + ↑b = 10</span>
<span class=cm>  -/</span>
<span class=w>  </span><span class=n>push_cast</span><span class=w> </span><span class=n>at</span><span class=w> </span><span class=n>h1</span>
<span class=w>  </span><span class=n>push_cast</span><span class=w> </span><span class=o>[</span><span class=n>Int.add_zero</span><span class=o>]</span><span class=w> </span><span class=n>at</span><span class=w> </span><span class=n>h2</span>
<span class=w>  </span><span class=c>/-</span><span class=cm> 现在</span>
<span class=cm>  h1 h2 : ↑a + ↑b = 10</span>
<span class=cm>  -/</span>
<span class=w>  </span><span class=n>exact</span><span class=w> </span><span class=n>h1</span>
</code></pre></div></p> <p>另见 <code>norm_cast</code>。</p> <h2 id=push_neg>push_neg<a class=headerlink href=#push_neg title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.PushNeg.tacticPush_neg_</code></p> <p>将否定推入假设的结论中。例如，假设 <code>h : ¬ ∀ x, ∃ y, x ≤ y</code> 将被 <code>push_neg at h</code> 转换为 <code>h : ∃ x, ∀ y, y &lt; x</code>。变量名称保持不变。 此策略将否定推入表达式内部。例如，给定假设 <div class=highlight><pre><span></span><code><span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=bp>¬</span><span class=w> </span><span class=bp>∀</span><span class=w> </span><span class=n>ε</span><span class=w> </span><span class=bp>&gt;</span><span class=w> </span><span class=mi>0</span><span class=o>,</span><span class=w> </span><span class=bp>∃</span><span class=w> </span><span class=n>δ</span><span class=w> </span><span class=bp>&gt;</span><span class=w> </span><span class=mi>0</span><span class=o>,</span><span class=w> </span><span class=bp>∀</span><span class=w> </span><span class=n>x</span><span class=o>,</span><span class=w> </span><span class=bp>|</span><span class=n>x</span><span class=w> </span><span class=bp>-</span><span class=w> </span><span class=n>x₀</span><span class=bp>|</span><span class=w> </span><span class=bp>≤</span><span class=w> </span><span class=n>δ</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=bp>|</span><span class=n>f</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>-</span><span class=w> </span><span class=n>y₀</span><span class=bp>|</span><span class=w> </span><span class=bp>≤</span><span class=w> </span><span class=n>ε</span>
</code></pre></div> 执行 <code>push_neg at h</code> 会将 <code>h</code> 转换为 <div class=highlight><pre><span></span><code><span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=bp>∃</span><span class=w> </span><span class=n>ε</span><span class=o>,</span><span class=w> </span><span class=n>ε</span><span class=w> </span><span class=bp>&gt;</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=bp>∧</span><span class=w> </span><span class=bp>∀</span><span class=w> </span><span class=n>δ</span><span class=o>,</span><span class=w> </span><span class=n>δ</span><span class=w> </span><span class=bp>&gt;</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=o>(</span><span class=bp>∃</span><span class=w> </span><span class=n>x</span><span class=o>,</span><span class=w> </span><span class=bp>|</span><span class=n>x</span><span class=w> </span><span class=bp>-</span><span class=w> </span><span class=n>x₀</span><span class=bp>|</span><span class=w> </span><span class=bp>≤</span><span class=w> </span><span class=n>δ</span><span class=w> </span><span class=bp>∧</span><span class=w> </span><span class=n>ε</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=bp>|</span><span class=n>f</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>-</span><span class=w> </span><span class=n>y₀</span><span class=bp>|</span><span class=o>)</span>
</code></pre></div> （漂亮的打印器不使用缩写 <code>∀ δ &gt; 0</code> 和 <code>∃ ε &gt; 0</code>，但此问题与 <code>push_neg</code> 无关）。</p> <p>注意，与此策略相比，使用相关引理的 <code>simp</code> 不会保留名称。可以使用 <code>push_neg</code> 在目标处应用此策略，或在所有假设和目标处使用 <code>push_neg at *</code>，或在选定的假设和目标处使用如 <code>push_neg at h h' ⊢</code>。</p> <p>此策略有两种模式：标准模式下，它将 <code>¬(p ∧ q)</code> 转换为 <code>p → ¬q</code>；分配模式下，它生成 <code>¬p ∨ ¬q</code>。要使用分配模式，请设置 <code>set_option push_neg.use_distrib true</code>。</p> <h2 id=qify>qify<a class=headerlink href=#qify title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.Qify.qify</code></p> <p><code>qify</code> 策略用于将命题从 <code>ℕ</code> 或 <code>ℤ</code> 转移到 <code>ℚ</code>。这通常很有用，因为 <code>ℚ</code> 具有良好的除法行为。 <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=n>z</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℕ</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=bp>¬</span><span class=w> </span><span class=n>x</span><span class=bp>*</span><span class=n>y</span><span class=bp>*</span><span class=n>z</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=mi>0</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>3</span><span class=bp>*</span><span class=n>b</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>qify</span>
<span class=w>  </span><span class=n>qify</span><span class=w> </span><span class=n>at</span><span class=w> </span><span class=n>h</span>
<span class=w>  </span><span class=c>/-</span>
<span class=cm>  h : ¬↑x * ↑y * ↑z &lt; 0</span>
<span class=cm>  ⊢ ↑c &lt; ↑a + 3 * ↑b</span>
<span class=cm>  -/</span>
<span class=w>  </span><span class=gr>sorry</span>
</code></pre></div> <code>qify</code> 可以接受额外的引理用于简化。这在存在自然数减法时特别有用：传递 <code>≤</code> 参数将允许 <code>push_cast</code> 完成更多工作。 <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℤ</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>/</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>c</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>hab</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=bp>∣</span><span class=w> </span><span class=n>a</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>hb</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=bp>≠</span><span class=w> </span><span class=mi>0</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>qify</span><span class=w> </span><span class=o>[</span><span class=n>hab</span><span class=o>]</span><span class=w> </span><span class=n>at</span><span class=w> </span><span class=n>h</span><span class=w> </span><span class=n>hb</span><span class=w> </span><span class=bp>⊢</span>
<span class=w>  </span><span class=n>exact</span><span class=w> </span><span class=o>(</span><span class=n>div_eq_iff</span><span class=w> </span><span class=n>hb</span><span class=o>)</span><span class=bp>.</span><span class=mi>1</span><span class=w> </span><span class=n>h</span>
</code></pre></div> <code>qify</code> 利用 <code>@[zify_simps]</code> 和 <code>@[qify_simps]</code> 属性来转移命题，并使用 <code>push_cast</code> 策略简化 <code>ℚ</code> 值表达式。</p> <h2 id=rcases>rcases<a class=headerlink href=#rcases title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.rcases</code></p> <p><code>rcases</code> 是一个根据模式递归执行 <code>cases</code> 的策略。它用于解构由归纳类型组成的假设或表达式，如 <code>h1 : a ∧ b ∧ c ∨ d</code> 或 <code>h2 : ∃ x y, trans_rel R x y</code>。常见用法如 <code>rcases h1 with ⟨ha, hb, hc⟩ | hd</code> 或 <code>rcases h2 with ⟨x, y, _ | ⟨z, hxz, hzy⟩⟩</code>。</p> <p><code>rcases</code> 模式的每个元素与特定的局部假设（其中大部分在 <code>rcases</code> 执行期间生成，表示从输入表达式解构出的单个元素）匹配。<code>rcases</code> 模式的语法如下：</p> <ul> <li>名称如 <code>x</code>，将活动假设命名为 <code>x</code>。</li> <li>空白 <code>_</code>，不执行任何操作（让 <code>cases</code> 使用的自动命名系统命名假设）。</li> <li>连字符 <code>-</code>，清除活动假设及其依赖项。</li> <li>关键字 <code>rfl</code>，期望假设为 <code>h : a = b</code>，并对假设调用 <code>subst</code>（效果为在所有地方用 <code>a</code> 替换 <code>b</code> 或反之）。</li> <li>类型归属 <code>p : ty</code>，将假设的类型设置为 <code>ty</code> 然后将其与 <code>p</code> 匹配（当然，<code>ty</code> 必须与 <code>h</code> 的实际类型统一）。</li> <li>元组模式 <code>⟨p1, p2, p3⟩</code>，匹配具有多个参数的构造函数，或一系列嵌套的合取或存在。例如，如果活动假设为 <code>a ∧ b ∧ c</code>，则将解构合取，<code>p1</code> 匹配 <code>a</code>，<code>p2</code> 匹配 <code>b</code> 等。</li> <li>在元组模式前加 <code>@</code> 如 <code>@⟨p1, p2, p3⟩</code> 将绑定构造函数中的所有参数，而省略 <code>@</code> 将仅在显式参数上使用模式。</li> <li>交替模式 <code>p1 | p2 | p3</code>，匹配具有多个构造函数的归纳类型，或嵌套的析取如 <code>a ∨ b ∨ c</code>。</li> </ul> <p>像 <code>⟨a, b, c⟩ | ⟨d, e⟩</code> 这样的模式将对归纳数据类型进行拆分，将第一个构造器的前三个参数命名为 <code>a,b,c</code>，第二个构造器的前两个参数命名为 <code>d,e</code>。如果列表长度与构造器的参数数量或构造器数量不符，剩余变量将自动命名。如果有嵌套括号如 <code>⟨⟨a⟩, b | c⟩ | d</code>，这些将根据需要引起更多的案例分析。如果参数过多，如对 <code>∃ x, ∃ y, p x</code> 使用 <code>⟨a, b, c⟩</code>，则将被视为 <code>⟨a, ⟨b, c⟩⟩</code>，必要时拆分最后一个参数。</p> <p><code>rcases</code> 对商类型有特殊支持：商归纳到 Prop 的工作方式类似于匹配构造器 <code>quot.mk</code>。</p> <p><code>rcases h : e with PAT</code> 将执行与 <code>rcases e with PAT</code> 相同的操作，但会在上下文中添加假设 <code>h : e = PAT</code>。</p> <h2 id=rcongr>rcongr<a class=headerlink href=#rcongr title="Permanent link">&para;</a></h2> <p>定义于：<code>Batteries.Tactic.rcongr</code></p> <p>重复应用 <code>congr</code> 和 <code>ext</code>，使用给定模式作为 <code>ext</code> 的参数。</p> <p>此策略在以下两种情况下停止： * <code>congr</code> 失败（未取得进展），在已应用 <code>ext</code> 后。 * <code>congr</code> 取消了上一次 <code>ext</code> 的使用。此时，状态将恢复到应用 <code>congr</code> 之前。</p> <p>例如，当目标为 <div class=highlight><pre><span></span><code>⊢ (fun x =&gt; f x + 3) &#39;&#39; s = (fun x =&gt; g x + 3) &#39;&#39; s
</code></pre></div> 时，<code>rcongr x</code> 将生成目标 <div class=highlight><pre><span></span><code>x : α ⊢ f x = g x
</code></pre></div> 这与 <code>congr; ext x; congr</code> 产生的结果相同。</p> <p>相比之下，<code>congr</code> 将生成 <div class=highlight><pre><span></span><code>⊢ (fun x =&gt; f x + 3) = (fun x =&gt; g x + 3)
</code></pre></div> 而 <code>congr with x</code>（或 <code>congr; ext x</code>）将生成 <div class=highlight><pre><span></span><code>x : α ⊢ f x + 3 = g x + 3
</code></pre></div></p> <h2 id=recover>recover<a class=headerlink href=#recover title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.tacticRecover_</code></p> <p>修饰符 <code>recover</code> 用于调试目标被错误关闭的情况的策略（序列）。策略 <code>recover tacs</code> 对策略（序列）<code>tacs</code> 应用这些策略，然后添加未关闭的目标，从原始目标开始。</p> <h2 id=reduce>reduce<a class=headerlink href=#reduce title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.tacticReduce__</code></p> <p><code>reduce at loc</code> 完全规约给定位置。这也作为 <code>conv</code> 模式的策略存在。</p> <h2 id=reduce_mod_char>reduce_mod_char<a class=headerlink href=#reduce_mod_char title="Permanent link">&para;</a></h2> <p>定义于：<code>Tactic.ReduceModChar.reduce_mod_char</code></p> <p>策略<code>reduce_mod_char</code>寻找特征为<code>p</code>的数值表达式，并将这些数值缩减至<code>0</code>到<code>p</code>之间。</p> <p>例如： <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=o>:</span><span class=w>  </span><span class=o>(</span><span class=mi>5</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ZMod</span><span class=w> </span><span class=mi>4</span><span class=o>)</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span><span class=w> </span><span class=n>reduce_mod_char</span>
<span class=kd>example</span><span class=o>:</span><span class=w>  </span><span class=o>(</span><span class=n>X</span><span class=w> </span><span class=bp>^</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=bp>-</span><span class=w> </span><span class=mi>3</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=n>X</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>4</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=o>(</span><span class=n>ZMod</span><span class=w> </span><span class=mi>4</span><span class=o>)[</span><span class=n>X</span><span class=o>])</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>X</span><span class=w> </span><span class=bp>^</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>X</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span><span class=w> </span><span class=n>reduce_mod_char</span>
</code></pre></div></p> <p>该策略还处理取反操作，将其转换为乘以<code>p - 1</code>，减法操作同理。</p> <p>为提高性能，此策略通过子表达式的类型来判断其是否处于正特征环境中，而非尝试合成<code>CharP</code>实例。变体<code>reduce_mod_char!</code>会尝试使用上下文中的<code>CharP R n</code>假设（由于类型类系统的限制，若<code>n</code>尚未知，策略无法搜索<code>CharP R n</code>实例；此时可使用<code>have : CharP R n := inferInstance; reduce_mod_char!</code>作为临时解决方案）。</p> <h2 id=reduce_mod_char_1>reduce_mod_char!<a class=headerlink href=#reduce_mod_char_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Tactic.ReduceModChar.reduce_mod_char!</code></p> <p>策略<code>reduce_mod_char!</code>寻找特征为<code>p</code>的数值表达式，并将这些数值缩减至<code>0</code>到<code>p</code>之间。</p> <p>例如： <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=o>:</span><span class=w>  </span><span class=o>(</span><span class=mi>5</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ZMod</span><span class=w> </span><span class=mi>4</span><span class=o>)</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span><span class=w> </span><span class=n>reduce_mod_char</span>
<span class=kd>example</span><span class=o>:</span><span class=w>  </span><span class=o>(</span><span class=n>X</span><span class=w> </span><span class=bp>^</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=bp>-</span><span class=w> </span><span class=mi>3</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=n>X</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>4</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=o>(</span><span class=n>ZMod</span><span class=w> </span><span class=mi>4</span><span class=o>)[</span><span class=n>X</span><span class=o>])</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>X</span><span class=w> </span><span class=bp>^</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>X</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span><span class=w> </span><span class=n>reduce_mod_char</span>
</code></pre></div></p> <p>该策略还处理取反操作，将其转换为乘以<code>p - 1</code>，减法操作同理。</p> <p>为提高性能，此策略通过子表达式的类型来判断其是否处于正特征环境中，而非尝试合成<code>CharP</code>实例。变体<code>reduce_mod_char!</code>会尝试使用上下文中的<code>CharP R n</code>假设（由于类型类系统的限制，若<code>n</code>尚未知，策略无法搜索<code>CharP R n</code>实例；此时可使用<code>have : CharP R n := inferInstance; reduce_mod_char!</code>作为临时解决方案）。</p> <h2 id=refine>refine<a class=headerlink href=#refine title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.refine</code></p> <p><code>refine e</code>的行为类似于<code>exact e</code>，不同之处在于，若主目标的目标类型无法通过统一解决<code>e</code>中的命名（<code>?x</code>）或未命名（<code>?_</code>）孔洞，则这些孔洞将被转换为新目标，并使用孔洞名称（如有）作为目标案例名称。</p> <h2 id=refine_1>refine'<a class=headerlink href=#refine_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.refine'</code></p> <p><code>refine' e</code>的行为类似于<code>refine e</code>，不同之处在于未解决的占位符（<code>_</code>）和隐式参数也会被转换为新目标。</p> <h2 id=refine_lift>refine_lift<a class=headerlink href=#refine_lift title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.tacticRefine_lift_</code></p> <p>用于提升<code>have</code>/<code>suffices</code>/<code>let</code>等的辅助宏。确保在精炼后，“?_”成为主目标。</p> <h2 id=refine_lift_1>refine_lift'<a class=headerlink href=#refine_lift_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.tacticRefine_lift'_</code></p> <p>类似于<code>refine_lift</code>，但使用<code>refine'</code></p> <h2 id=refold_let>refold_let<a class=headerlink href=#refold_let title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.refoldLetStx</code></p> <p><code>refold_let x y z at loc</code>在指定位置查找本地定义<code>x</code>、<code>y</code>和<code>z</code>的实体，并将其替换回<code>x</code>、<code>y</code>或<code>z</code>。此为zeta规约的逆操作。此策略也可作为<code>conv</code>模式策略使用。</p> <h2 id=rel>rel<a class=headerlink href=#rel title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.GCongr.«tacticRel[_]»</code></p> <p><code>rel</code>策略应用“广义同余”规则，通过“替换”解决关系型目标。例如： <div class=highlight><pre><span></span><code><span class=bp>示例</span><span class=w> </span><span class=o>{</span><span class=n>a</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=n>d</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℝ</span><span class=o>}</span><span class=w> </span><span class=o>(</span><span class=n>h1</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>≤</span><span class=w> </span><span class=n>b</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>h2</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=bp>≤</span><span class=w> </span><span class=n>d</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>^</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=bp>≤</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>^</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>d</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>rel</span><span class=w> </span><span class=o>[</span><span class=n>h1</span><span class=o>,</span><span class=w> </span><span class=n>h2</span><span class=o>]</span>
</code></pre></div> 在此示例中，我们将假设<code>a ≤ b</code>和<code>c ≤ d</code>“替换”到目标的左端<code>x ^ 2 * a + c</code>，得到右端<code>x ^ 2 * b + d</code>，从而证明目标。</p> <p>所使用的“广义同余”规则为标有<code>@[gcongr]</code>属性的库引理。例如，上述示例构造了证明项： <div class=highlight><pre><span></span><code><span class=n>add_le_add</span><span class=w> </span><span class=o>(</span><span class=n>mul_le_mul_of_nonneg_left</span><span class=w> </span><span class=n>h1</span><span class=w> </span><span class=o>(</span><span class=n>pow_bit0_nonneg</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=mi>1</span><span class=o>))</span><span class=w> </span><span class=n>h2</span>
</code></pre></div> 使用的广义同余引理为<code>add_le_add</code>和<code>mul_le_mul_of_nonneg_left</code>。若无适用的广义同余引理，策略将失败。</p> <p>此策略尝试通过<code>gcongr_discharger</code>解决这些广义同余引理的边目标（如上述<code>mul_le_mul_of_nonneg_left</code>应用中的边目标<code>0 ≤ x ^ 2</code>），该工具包装了<code>positivity</code>但可扩展。若边目标无法以此方式解决，策略将失败。</p> <h2 id=rename>rename<a class=headerlink href=#rename title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.rename</code></p> <p><code>rename t =&gt; x</code>将类型匹配<code>t</code>（可含占位符）的最新假设重命名为<code>x</code>，若无此类假设则失败。</p> <h2 id=rename_1>rename'<a class=headerlink href=#rename_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.rename'</code></p> <p><code>rename' h =&gt; hnew</code>将名为<code>h</code>的假设重命名为<code>hnew</code>。重命名多个假设时，使用<code>rename' h₁ =&gt; h₁new, h₂ =&gt; h₂new</code>。可通过<code>rename' a =&gt; b, b =&gt; a</code>交换两个变量。</p> <h2 id=rename_bvar>rename_bvar<a class=headerlink href=#rename_bvar title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.«tacticRename_bvar_→__»</code></p> <ul> <li><code>rename_bvar old → new</code>将目标中所有名为<code>old</code>的绑定变量重命名为<code>new</code>。</li> <li><code>rename_bvar old → new at h</code>在假设<code>h</code>中执行相同操作。</li> </ul> <p><div class=highlight><pre><span></span><code><span class=bp>示例</span><span class=w> </span><span class=o>(</span><span class=n>P</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℕ</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>ℕ</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=kt>Prop</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=bp>∀</span><span class=w> </span><span class=n>n</span><span class=o>,</span><span class=w> </span><span class=bp>∃</span><span class=w> </span><span class=n>m</span><span class=o>,</span><span class=w> </span><span class=n>P</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=n>m</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=bp>∀</span><span class=w> </span><span class=n>l</span><span class=o>,</span><span class=w> </span><span class=bp>∃</span><span class=w> </span><span class=n>m</span><span class=o>,</span><span class=w> </span><span class=n>P</span><span class=w> </span><span class=n>l</span><span class=w> </span><span class=n>m</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>rename_bvar</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>q</span><span class=w> </span><span class=n>at</span><span class=w> </span><span class=n>h</span><span class=w> </span><span class=c1>-- h现为∀ (q : ℕ), ∃ (m : ℕ), P q m</span>
<span class=w>  </span><span class=n>rename_bvar</span><span class=w> </span><span class=n>m</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=c1>-- 目标现为∀ (l : ℕ), ∃ (n : ℕ), P k n</span>
<span class=w>  </span><span class=n>exact</span><span class=w> </span><span class=n>h</span><span class=w> </span><span class=c1>-- Lean不关心这些绑定变量名称</span>
</code></pre></div> 注意：名称冲突将自动解决。</p> <h2 id=rename_i>rename_i<a class=headerlink href=#rename_i title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.renameI</code></p> <p><code>rename_i x_1 ... x_n</code>使用给定名称重命名最后的<code>n</code>个不可访问名称。</p> <h2 id=repeat>repeat<a class=headerlink href=#repeat title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.tacticRepeat_</code></p> <p><code>repeat tac</code>重复应用<code>tac</code>直至其失败。<code>tac</code>可为策略序列，若<code>tac</code>在执行过程中失败，<code>repeat</code>将撤销<code>tac</code>对策略状态的部分更改。</p> <p><code>tac</code>应最终失败，否则<code>repeat tac</code>将无限运行。</p> <p>另见： * <code>try tac</code>类似于<code>repeat tac</code>但最多应用一次<code>tac</code>。 * <code>repeat' tac</code>递归应用<code>tac</code>至各子目标。 * <code>first | tac1 | tac2</code>实现<code>repeat</code>的回溯机制。</p> <h2 id=repeat_1>repeat'<a class=headerlink href=#repeat_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.repeat'</code></p> <p><code>repeat' tac</code>递归应用<code>tac</code>至所有子目标直至其失败。即若<code>tac</code>生成多个子目标，<code>repeat' tac</code>将分别应用于每个子目标。</p> <p>另见： * <code>repeat tac</code>仅简单重复应用<code>tac</code>。 * <code>repeat1' tac</code>为<code>repeat' tac</code>但要求<code>tac</code>至少成功应用于某个目标一次。</p> <h2 id=repeat1>repeat1<a class=headerlink href=#repeat1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.tacticRepeat1_</code></p> <p><code>repeat1 tac</code>至少对主目标应用一次<code>tac</code>。若应用成功，则递归应用于生成的子目标直至最终失败。</p> <h2 id=repeat1_1>repeat1'<a class=headerlink href=#repeat1_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.repeat1'</code></p> <p><code>repeat1' tac</code>递归应用<code>tac</code>至所有子目标直至其失败，但若<code>tac</code>未成功应用于任何初始目标，<code>repeat1' tac</code>将失败。</p> <p>另见： * <code>repeat tac</code>仅简单重复应用<code>tac</code>。 * <code>repeat' tac</code>类似于<code>repeat1' tac</code>但不要求<code>tac</code>至少成功一次。</p> <h2 id=replace>replace<a class=headerlink href=#replace title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.replace'</code></p> <p>行为类似于<code>have</code>，但会移除同名假设（若存在）。例如，若当前状态为： <div class=highlight><pre><span></span><code><span class=n>f</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>α</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>β</span>
<span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>α</span>
<span class=bp>⊢</span><span class=w> </span><span class=n>goal</span>
</code></pre></div> 执行<code>replace h : β</code>后状态为： <div class=highlight><pre><span></span><code><span class=n>case</span><span class=w> </span><span class=n>h</span>
<span class=n>f</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>α</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>β</span>
<span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>α</span>
<span class=bp>⊢</span><span class=w> </span><span class=n>β</span>

<span class=n>f</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>α</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>β</span>
<span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>β</span>
<span class=bp>⊢</span><span class=w> </span><span class=n>goal</span>
</code></pre></div> 而<code>have h : β</code>将导致： <div class=highlight><pre><span></span><code><span class=n>case</span><span class=w> </span><span class=n>h</span>
<span class=n>f</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>α</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>β</span>
<span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>α</span>
<span class=bp>⊢</span><span class=w> </span><span class=n>β</span>

<span class=n>f</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>α</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>β</span>
<span class=n>h</span><span class=bp>✝</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>α</span>
<span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>β</span>
<span class=bp>⊢</span><span class=w> </span><span class=n>goal</span>
</code></pre></div></p> <h2 id=replace_1>replace<a class=headerlink href=#replace_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.replace</code></p> <p>行为类似于<code>have</code>，但会移除同名假设（若存在）。例如，若当前状态为： <div class=highlight><pre><span></span><code><span class=n>f</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>α</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>β</span>
<span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>α</span>
<span class=bp>⊢</span><span class=w> </span><span class=n>goal</span>
</code></pre></div> 执行<code>replace h := f h</code>后状态为： <div class=highlight><pre><span></span><code><span class=n>f</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>α</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>β</span>
<span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>β</span>
<span class=bp>⊢</span><span class=w> </span><span class=n>goal</span>
</code></pre></div> 而<code>have h := f h</code>将导致： <div class=highlight><pre><span></span><code><span class=n>f</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>α</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>β</span>
<span class=n>h</span><span class=bp>†</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>α</span>
<span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>β</span>
<span class=bp>⊢</span><span class=w> </span><span class=n>goal</span>
</code></pre></div> 此策略可用于模拟Coq的<code>specialize</code>和<code>apply at</code>策略。</p> <h2 id=restrict_tac>restrict_tac<a class=headerlink href=#restrict_tac title="Permanent link">&para;</a></h2> <p>定义于：<code>TopCat.Presheaf.restrict_tac</code></p> <p><code>restrict_tac</code>解决子集间的关系（复制自<code>aesop cat</code>）</p> <h2 id=restrict_tac_1>restrict_tac?<a class=headerlink href=#restrict_tac_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>TopCat.Presheaf.restrict_tac?</code></p> <p><code>restrict_tac?</code>传递来自<code>aesop</code>的<code>Try this</code></p> <h2 id=revert>revert<a class=headerlink href=#revert title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.revert</code></p> <p><code>revert x...</code> 是 <code>intro x...</code> 的逆操作：它将给定的假设移回主目标的目标类型中。</p> <h2 id=rewrite>rewrite<a class=headerlink href=#rewrite title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.rewriteSeq</code></p> <p><code>rewrite [e]</code> 将恒等式 <code>e</code> 作为重写规则应用于主目标的目标。若 <code>e</code> 前有左箭头（<code>←</code> 或 <code>&lt;-</code>），则反向应用重写。若 <code>e</code> 是已定义的常量，则使用与 <code>e</code> 相关的等式定理。这为展开 <code>e</code> 提供了一种便捷方式。 - <code>rewrite [e₁, ..., eₙ]</code> 依次应用给定的规则。 - <code>rewrite [e] at l</code> 在位置 <code>l</code> 处重写 <code>e</code>，其中 <code>l</code> 为 <code>*</code> 或局部上下文中的假设列表。后者中也可使用转折符 <code>⊢</code> 或 <code>|-</code> 表示目标的目标。</p> <p>使用 <code>rw (occs := .pos L) [e]</code>（其中 <code>L : List Nat</code>）可控制重写哪些“出现项”。（此选项适用于每条规则，因此通常仅与单一规则配合使用。）出现项从 <code>1</code> 开始计数。在每个允许的出现项处，重写规则 <code>e</code> 的参数可能被实例化，从而限制后续可找到的重写项。（不允许的出现项不会导致实例化。）<code>(occs := .neg L)</code> 允许跳过指定出现项。</p> <h2 id=rfl>rfl<a class=headerlink href=#rfl title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.tacticRfl</code></p> <p>此策略适用于目标形式为 <code>x ~ x</code> 的情况，其中 <code>~</code> 为等式、异构等式或任何带有 <code>@[refl]</code> 属性标记的自反性引理的关系。</p> <h2 id=rfl_1>rfl'<a class=headerlink href=#rfl_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.tacticRfl'</code></p> <p><code>rfl'</code> 类似于 <code>rfl</code>，但禁用智能展开并展开所有类型的定义（包括通过良基递归定义的声明）。</p> <h2 id=rify>rify<a class=headerlink href=#rify title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.Rify.rify</code></p> <p><code>rify</code> 策略用于将命题从 <code>ℕ</code>、<code>ℤ</code> 或 <code>ℚ</code> 转换到 <code>ℝ</code>。尽管不如其同类 <code>zify</code> 和 <code>qify</code> 实用，但当目标或上下文中已涉及实数时，它可能有用。</p> <p>以下示例中，假设 <code>hn</code> 关于自然数，<code>hk</code> 关于整数并涉及自然数到 <code>ℤ</code> 的转换，结论关于实数。证明使用 <code>rify</code> 将两个假设提升至 <code>ℝ</code> 后调用 <code>linarith</code>： <div class=highlight><pre><span></span><code>example {n : ℕ} {k : ℤ} (hn : 8 ≤ n) (hk : 2 * k ≤ n + 2) :
    (0 : ℝ) &lt; n - k - 1 := by
  rify at hn hk /- 现有 hn : 8 ≤ (n : ℝ)   hk : 2 * (k : ℝ) ≤ (n : ℝ) + 2 -/
  linarith
</code></pre></div></p> <p><code>rify</code> 利用 <code>@[zify_simps]</code>、<code>@[qify_simps]</code> 和 <code>@[rify_simps]</code> 属性迁移命题，并使用 <code>push_cast</code> 策略简化 <code>ℝ</code> 值的表达式。</p> <p><code>rify</code> 可接收额外引理以用于简化。这在存在自然数减法时尤为有用：传递 <code>≤</code> 参数可让 <code>push_cast</code> 完成更多工作。 <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℕ</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>-</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=n>c</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>hab</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=bp>≤</span><span class=w> </span><span class=n>a</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>rify</span><span class=w> </span><span class=o>[</span><span class=n>hab</span><span class=o>]</span><span class=w> </span><span class=n>at</span><span class=w> </span><span class=n>h</span><span class=w> </span><span class=bp>⊢</span>
<span class=w>  </span><span class=n>linarith</span>
</code></pre></div> 注意，上述示例中 <code>zify</code> 或 <code>qify</code> 同样有效（且 <code>zify</code> 是自然选择，因其足以消除病态的 <code>ℕ</code> 减法）。</p> <h2 id=right>right<a class=headerlink href=#right title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.right</code></p> <p>当目标为恰好有两个构造函数的归纳类型时，应用第二个构造函数，否则失败。 <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>{</span><span class=n>p</span><span class=w> </span><span class=n>q</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=kt>Prop</span><span class=o>}</span><span class=w> </span><span class=o>(</span><span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>q</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>p</span><span class=w> </span><span class=bp>∨</span><span class=w> </span><span class=n>q</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>right</span>
<span class=w>  </span><span class=n>exact</span><span class=w> </span><span class=n>h</span>
</code></pre></div></p> <h2 id=ring>ring<a class=headerlink href=#ring title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.RingNF.ring</code></p> <p>用于在*交换*（半）环中评估表达式的策略，允许指数中含有变量。若目标不适合 <code>ring</code>（如非等式），将建议使用 <code>ring_nf</code>。 - <code>ring!</code> 使用更具侵略性的可约性设置以判定原子项的相等性。 - <code>ring1</code> 在目标非等式时失败。</p> <p>例如： <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>n</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℕ</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>m</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℤ</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=mi>2</span><span class=bp>^</span><span class=o>(</span><span class=n>n</span><span class=bp>+</span><span class=mi>1</span><span class=o>)</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=n>m</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=mi>2</span><span class=bp>^</span><span class=n>n</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=n>m</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span><span class=w> </span><span class=n>ring</span>
<span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℤ</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>n</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℕ</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>b</span><span class=o>)</span><span class=bp>^</span><span class=o>(</span><span class=n>n</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>2</span><span class=o>)</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=bp>^</span><span class=mi>2</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>b</span><span class=bp>^</span><span class=mi>2</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=n>a</span><span class=o>)</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>b</span><span class=o>)</span><span class=bp>^</span><span class=n>n</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span><span class=w> </span><span class=n>ring</span>
<span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>x</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℕ</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span><span class=w> </span><span class=n>ring</span><span class=bp>!</span>
<span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>x</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℕ</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=bp>&gt;</span><span class=w> </span><span class=mi>5</span><span class=o>):</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>&gt;</span><span class=w> </span><span class=mi>5</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span><span class=w> </span><span class=n>ring</span><span class=bp>;</span><span class=w> </span><span class=n>assumption</span><span class=w> </span><span class=c1>-- 建议使用 ring_nf</span>
</code></pre></div></p> <h2 id=ring_1>ring!<a class=headerlink href=#ring_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.RingNF.tacticRing!</code></p> <p>用于在*交换*（半）环中评估表达式的策略，允许指数中含有变量。若目标不适合 <code>ring</code>（如非等式），将建议使用 <code>ring_nf</code>。 - <code>ring!</code> 使用更具侵略性的可约性设置以判定原子项的相等性。 - <code>ring1</code> 在目标非等式时失败。</p> <p>例如： <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>n</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℕ</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>m</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℤ</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=mi>2</span><span class=bp>^</span><span class=o>(</span><span class=n>n</span><span class=bp>+</span><span class=mi>1</span><span class=o>)</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=n>m</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=mi>2</span><span class=bp>^</span><span class=n>n</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=n>m</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span><span class=w> </span><span class=n>ring</span>
<span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℤ</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>n</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℕ</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>b</span><span class=o>)</span><span class=bp>^</span><span class=o>(</span><span class=n>n</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>2</span><span class=o>)</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=bp>^</span><span class=mi>2</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>b</span><span class=bp>^</span><span class=mi>2</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=n>a</span><span class=o>)</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>b</span><span class=o>)</span><span class=bp>^</span><span class=n>n</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span><span class=w> </span><span class=n>ring</span>
<span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>x</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℕ</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span><span class=w> </span><span class=n>ring</span><span class=bp>!</span>
<span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>x</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℕ</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>*</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=bp>&gt;</span><span class=w> </span><span class=mi>5</span><span class=o>):</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>&gt;</span><span class=w> </span><span class=mi>5</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span><span class=w> </span><span class=n>ring</span><span class=bp>;</span><span class=w> </span><span class=n>assumption</span><span class=w> </span><span class=c1>-- 建议使用 ring_nf</span>
</code></pre></div></p> <h2 id=ring1>ring1<a class=headerlink href=#ring1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.Ring.ring1</code></p> <p>用于解*交换*（半）环方程的策略，允许指数中含有变量。 - 此版本 <code>ring</code> 在目标非等式时失败。 - 变体 <code>ring1!</code> 使用更具侵略性的可约性设置以判定原子项的相等性。</p> <h2 id=ring1_1>ring1!<a class=headerlink href=#ring1_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.Ring.tacticRing1!</code></p> <p>用于解*交换*（半）环方程的策略，允许指数中含有变量。 - 此版本 <code>ring</code> 在目标非等式时失败。 - 变体 <code>ring1!</code> 使用更具侵略性的可约性设置以判定原子项的相等性。</p> <h2 id=ring1_nf>ring1_nf<a class=headerlink href=#ring1_nf title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.RingNF.ring1NF</code></p> <p>用于解*交换*（半）环方程的策略，允许指数中含有变量。 - 此版本 <code>ring1</code> 使用 <code>ring_nf</code> 简化原子项。 - 变体 <code>ring1_nf!</code> 使用更具侵略性的可约性设置以判定原子项的相等性。</p> <h2 id=ring1_nf_1>ring1_nf!<a class=headerlink href=#ring1_nf_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.RingNF.tacticRing1_nf!_</code></p> <p>用于解*交换*（半）环方程的策略，允许指数中含有变量。 - 此版本 <code>ring1</code> 使用 <code>ring_nf</code> 简化原子项。 - 变体 <code>ring1_nf!</code> 使用更具侵略性的可约性设置以判定原子项的相等性。</p> <h2 id=ring_nf>ring_nf<a class=headerlink href=#ring_nf title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.RingNF.ringNF</code></p> <p>用于在交换（半）环语言中表达式简化的策略，将所有环表达式重写为正规形式。 - <code>ring_nf!</code> 使用更具侵略性的可约性设置以识别原子项。 - <code>ring_nf (config := cfg)</code> 允许额外配置： - <code>red</code>：可约性设置（被 <code>!</code> 覆盖） - <code>zetaDelta</code>：若为真，局部 let 变量可展开（被 <code>!</code> 覆盖） - <code>recursive</code>：若为真，<code>ring_nf</code> 将递归进入原子项 - <code>ring_nf</code> 可作为策略或转换策略使用。在策略模式中，<code>ring_nf at h</code> 可用于在假设中重写。</p> <p>此策略可用于非终止性地将目标中的环表达式规范化，如 <code>⊢ P (x + x + x)</code> ~&gt; <code>⊢ P (x * 3)</code>，并能证明某些 <code>ring</code> 无法处理的方程，因其涉及子项内的环推理，如 <code>sin (x + y) + sin (y + x) = 2 * sin (x + y)</code>。</p> <h2 id=ring_nf_1>ring_nf!<a class=headerlink href=#ring_nf_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.RingNF.tacticRing_nf!__</code></p> <p>用于在交换（半）环语言中表达式简化的策略，将所有环表达式重写为正规形式。 - <code>ring_nf!</code> 使用更具侵略性的可约性设置以识别原子项。 - <code>ring_nf (config := cfg)</code> 允许额外配置： - <code>red</code>：可约性设置（被 <code>!</code> 覆盖） - <code>zetaDelta</code>：若为真，局部 let 变量可展开（被 <code>!</code> 覆盖） - <code>recursive</code>：若为真，<code>ring_nf</code> 将递归进入原子项 - <code>ring_nf</code> 可作为策略或转换策略使用。在策略模式中，<code>ring_nf at h</code> 可用于在假设中重写。</p> <p>此策略可用于非终止性地将目标中的环表达式规范化，如 <code>⊢ P (x + x + x)</code> ~&gt; <code>⊢ P (x * 3)</code>，并能证明某些 <code>ring</code> 无法处理的方程，因其涉及子项内的环推理，如 <code>sin (x + y) + sin (y + x) = 2 * sin (x + y)</code>。</p> <h2 id=rintro>rintro<a class=headerlink href=#rintro title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.rintro</code></p> <p><code>rintro</code> 策略结合了 <code>intros</code> 策略和 <code>rcases</code> 的功能，允许在引入变量时进行解构模式。关于支持的模式描述，请参见 <code>rcases</code>。例如，<code>rintro (a | ⟨b, c⟩) ⟨d, e⟩</code> 将引入两个变量，然后对它们进行分支处理，生成两个子目标：一个带有变量 <code>a d e</code>，另一个带有 <code>b c d e</code>。</p> <p>与 <code>rcases</code> 不同，<code>rintro</code> 还支持 <code>(x y : ty)</code> 形式的语法，用于同时引入多个变量并进行类型标注，类似于绑定器。</p> <h2 id=rotate_left>rotate_left<a class=headerlink href=#rotate_left title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.rotateLeft</code></p> <p><code>rotate_left n</code> 将目标向左轮换 <code>n</code> 次。即，<code>rotate_left 1</code> 将主目标移动到子目标列表的末尾。如果未指定 <code>n</code>，默认值为 <code>1</code>。</p> <h2 id=rotate_right>rotate_right<a class=headerlink href=#rotate_right title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.rotateRight</code></p> <p><code>rotate_right n</code> 将目标向右轮换 <code>n</code> 次。即，将末尾的目标移动到前端 <code>n</code> 次。如果未指定 <code>n</code>，默认值为 <code>1</code>。</p> <h2 id=rsuffices>rsuffices<a class=headerlink href=#rsuffices title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.rsuffices</code></p> <p><code>rsuffices</code> 是 <code>suffices</code> 的替代版本，允许使用在 <code>obtain</code> 块中有效的任何语法。此策略通过调用 <code>obtain</code> 处理表达式，然后执行 <code>rotate_left</code>。</p> <h2 id=run_tac>run_tac<a class=headerlink href=#run_tac title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.runTac</code></p> <p><code>run_tac doSeq</code> 策略用于执行 <code>TacticM Unit</code> 中的代码。</p> <h2 id=rw>rw<a class=headerlink href=#rw title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.rwSeq</code></p> <p><code>rw</code> 类似于 <code>rewrite</code>，但在之后会尝试通过“廉价”（可还原的）<code>rfl</code> 闭合目标。</p> <h2 id=rw_1>rw?<a class=headerlink href=#rw_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.rewrites?</code></p> <p><code>rw?</code> 尝试查找可用于重写目标的引理。</p> <p><code>rw?</code> 不应留在最终证明中；它类似于 <code>apply?</code>，是一个搜索工具。</p> <p>建议会以 <code>rw [h]</code> 或 <code>rw [← h]</code> 的形式打印。</p> <p>可通过 <code>rw? [-my_lemma, -my_theorem]</code> 防止 <code>rw?</code> 使用指定名称的引理。</p> <h2 id=rw_mod_cast>rw_mod_cast<a class=headerlink href=#rw_mod_cast title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.tacticRw_mod_cast___</code></p> <p>根据给定规则进行重写，每次重写前规范化类型转换。</p> <h2 id=rw_search>rw_search<a class=headerlink href=#rw_search title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.RewriteSearch.tacticRw_search_</code></p> <p><code>rw_search</code> 尝试通过反复重写库中的引理来解决等式目标。若未找到解，则返回在 <code>maxHeartbeats</code> 超时前找到的最佳重写序列。</p> <p>搜索采用最佳优先策略，最小化等式两侧美化打印表达式的 Levenshtein 编辑距离。（字符串以空格、分隔符 <code>(</code>, <code>)</code>, <code>[</code>, <code>]</code>, <code>,</code> 进行分词。）</p> <p>可通过 <code>rw_search [-my_lemma, -my_theorem]</code> 阻止 <code>rw_search</code> 使用指定名称的定理。</p> <h2 id=rwa>rwa<a class=headerlink href=#rwa title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.tacticRwa__</code></p> <p><code>rwa</code> 是 <code>rw; assumption</code> 的简写形式。</p> <h2 id=saturate>saturate<a class=headerlink href=#saturate title="Permanent link">&para;</a></h2> <p>定义于：<code>Aesop.Frontend.tacticSaturate_____</code></p> <h2 id=saturate_1>saturate?<a class=headerlink href=#saturate_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Aesop.Frontend.tacticSaturate?_____</code></p> <h2 id=says>says<a class=headerlink href=#says title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.Says.says</code></p> <p>若书写 <code>X says</code>（其中 <code>X</code> 是会产生“Try this: Y”消息的策略），则会生成“Try this: X says Y”消息。点击替换 <code>X says</code> 为 <code>X says Y</code> 后，<code>X says Y</code> 将仅执行 <code>Y</code>。</p> <p>典型用法为： <div class=highlight><pre><span></span><code><span class=n>simp</span><span class=bp>?</span><span class=w> </span><span class=o>[</span><span class=n>X</span><span class=o>]</span><span class=w> </span><span class=n>says</span><span class=w> </span><span class=n>simp</span><span class=w> </span><span class=n>only</span><span class=w> </span><span class=o>[</span><span class=n>X</span><span class=o>,</span><span class=w> </span><span class=n>Y</span><span class=o>,</span><span class=w> </span><span class=n>Z</span><span class=o>]</span>
</code></pre></div></p> <p>若设置 <code>set_option says.verify true</code>（在 CI 中自动设置），则 <code>X says Y</code> 会执行 <code>X</code> 并验证其仍输出“Try this: Y”。</p> <h2 id=set>set<a class=headerlink href=#set title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.setTactic</code></p> <h2 id=set_1>set!<a class=headerlink href=#set_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.tacticSet!_</code></p> <h2 id=set_option>set_option<a class=headerlink href=#set_option title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.set_option</code></p> <p><code>set_option opt val in tacs</code>（作为策略）类似于命令层的 <code>set_option opt val</code>，但仅在策略 <code>tacs</code> 内设置选项。</p> <h2 id=show>show<a class=headerlink href=#show title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.tacticShow_</code></p> <p><code>show t</code> 查找首个目标其目标可与 <code>t</code> 统一。将其设为主目标，执行统一，并将目标替换为统一后的 <code>t</code> 版本。</p> <h2 id=show_term>show_term<a class=headerlink href=#show_term title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.showTerm</code></p> <p><code>show_term tac</code> 运行 <code>tac</code>，随后以“exact X Y Z”或“refine X ?_ Z”形式打印生成的项（若存在剩余子目标）。</p> <p>（部分策略的打印项可能不易于人类阅读。）</p> <h2 id=simp>simp<a class=headerlink href=#simp title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.simp</code></p> <p><code>simp</code> 策略使用标记为 <code>[simp]</code> 属性的引理和假设来简化主目标或非依赖假设。其变体包括： - <code>simp</code>：使用 <code>[simp]</code> 引理简化主目标。 - <code>simp [h₁, h₂, ..., hₙ]</code>：使用 <code>[simp]</code> 引理及给定 <code>hᵢ</code> 简化主目标。若 <code>hᵢ</code> 为已定义常量 <code>f</code>，则展开 <code>f</code>。 - <code>simp [*]</code>：使用 <code>[simp]</code> 引理及所有假设简化主目标。 - <code>simp only [h₁, h₂, ..., hₙ]</code>：类似 <code>simp [h₁, h₂, ..., hₙ]</code>，但不使用 <code>[simp]</code> 引理。 - <code>simp [-id₁, ..., -idₙ]</code>：使用 <code>[simp]</code> 引理简化主目标，但排除指定名称的引理。 - <code>simp at h₁ h₂ ... hₙ</code>：在假设 <code>h₁ : T₁</code> ... <code>hₙ : Tₙ</code> 上应用简化。若目标或其他假设依赖 <code>hᵢ</code>，则引入新的简化假设，但旧假设仍保留在上下文中。 - <code>simp at *</code>：简化所有假设及目标。 - <code>simp [*] at *</code>：使用其他假设简化目标及所有命题性假设。</p> <h2 id=simp_1>simp!<a class=headerlink href=#simp_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.simpAutoUnfold</code></p> <p><code>simp!</code> 是 <code>simp</code> 的简写形式，启用 <code>autoUnfold := true</code>。这将使用所有等式引理进行重写，可部分求值多项定义。</p> <h2 id=simp_2>simp?<a class=headerlink href=#simp_2 title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.simpTrace</code></p> <p><code>simp?</code> 接受与 <code>simp</code> 相同的参数，但报告等效的 <code>simp only</code> 调用，以闭合目标。有助于减少本地调用中的简化集以加速处理。 <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>x</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Nat</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=o>(</span><span class=k>if</span><span class=w> </span><span class=n>True</span><span class=w> </span><span class=k>then</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=mi>3</span><span class=o>)</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>simp</span><span class=bp>?</span><span class=w> </span><span class=c1>-- 输出 &quot;Try this: simp only [ite_true]&quot;</span>
</code></pre></div></p> <p>此命令也可用于 <code>simp_all</code> 和 <code>dsimp</code>。</p> <h2 id=simp_3>simp?!<a class=headerlink href=#simp_3 title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.tacticSimp?!_</code></p> <p><code>simp?</code> 接受与 <code>simp</code> 相同的参数，但报告等效的 <code>simp only</code> 调用，以闭合目标。有助于减少本地调用中的简化集以加速处理。 <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>x</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Nat</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=o>(</span><span class=k>if</span><span class=w> </span><span class=n>True</span><span class=w> </span><span class=k>then</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=mi>3</span><span class=o>)</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>simp</span><span class=bp>?</span><span class=w> </span><span class=c1>-- 输出 &quot;Try this: simp only [ite_true]&quot;</span>
</code></pre></div></p> <p>此命令也可用于 <code>simp_all</code> 和 <code>dsimp</code>。</p> <h2 id=simp_all>simp_all<a class=headerlink href=#simp_all title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.simpAll</code></p> <p><code>simp_all</code> 是 <code>simp [*] at *</code> 的强化版本，持续简化假设及目标直至无适用简化。仅考虑非依赖命题性假设。</p> <h2 id=simp_all_1>simp_all!<a class=headerlink href=#simp_all_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.simpAllAutoUnfold</code></p> <p><code>simp_all!</code> 是 <code>simp_all</code> 的简写形式，启用 <code>autoUnfold := true</code>。这将使用所有等式引理进行重写，可部分求值多项定义。</p> <h2 id=simp_all_2>simp_all?<a class=headerlink href=#simp_all_2 title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.simpAllTrace</code></p> <p><code>simp?</code> 接受与 <code>simp</code> 相同的参数，但报告等效的 <code>simp only</code> 调用，以闭合目标。有助于减少本地调用中的简化集以加速处理。 <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>x</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Nat</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=o>(</span><span class=k>if</span><span class=w> </span><span class=n>True</span><span class=w> </span><span class=k>then</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=mi>3</span><span class=o>)</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>simp</span><span class=bp>?</span><span class=w> </span><span class=c1>-- 输出 &quot;Try this: simp only [ite_true]&quot;</span>
</code></pre></div></p> <p>此命令也可用于 <code>simp_all</code> 和 <code>dsimp</code>。</p> <h2 id=simp_all_3>simp_all?!<a class=headerlink href=#simp_all_3 title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.tacticSimp_all?!_</code></p> <p><code>simp?</code> 接受与 <code>simp</code> 相同的参数，但报告等效的 <code>simp only</code> 调用，以闭合目标。有助于减少本地调用中的简化集以加速处理。 <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>x</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Nat</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=o>(</span><span class=k>if</span><span class=w> </span><span class=n>True</span><span class=w> </span><span class=k>then</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=mi>3</span><span class=o>)</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>simp</span><span class=bp>?</span><span class=w> </span><span class=c1>-- 输出 &quot;Try this: simp only [ite_true]&quot;</span>
</code></pre></div></p> <p>此命令也可用于 <code>simp_all</code> 和 <code>dsimp</code>。</p> <h2 id=simp_all_arith>simp_all_arith<a class=headerlink href=#simp_all_arith title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.simpAllArith</code></p> <p><code>simp_all_arith</code> 已被弃用。它曾是 <code>simp_all +arith +decide</code> 的简写形式。注意，由于 Lean 已添加了简化过程（simprocs），<code>+decide</code> 不再需要用于简化算术表达式。</p> <h2 id=simp_all_arith_1>simp_all_arith!<a class=headerlink href=#simp_all_arith_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.simpAllArithBang</code></p> <p><code>simp_all_arith!</code> 已被弃用。它曾是 <code>simp_all! +arith +decide</code> 的简写形式。注意，由于 Lean 已添加了简化过程（simprocs），<code>+decide</code> 不再需要用于简化算术表达式。</p> <h2 id=simp_arith>simp_arith<a class=headerlink href=#simp_arith title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.simpArith</code></p> <p><code>simp_arith</code> 已被弃用。它曾是 <code>simp +arith +decide</code> 的简写形式。注意，由于 Lean 已添加了简化过程（simprocs），<code>+decide</code> 不再需要用于简化算术表达式。</p> <h2 id=simp_arith_1>simp_arith!<a class=headerlink href=#simp_arith_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.simpArithBang</code></p> <p><code>simp_arith!</code> 已被弃用。它曾是 <code>simp! +arith +decide</code> 的简写形式。注意，由于 Lean 已添加了简化过程（simprocs），<code>+decide</code> 不再需要用于简化算术表达式。</p> <h2 id=simp_intro>simp_intro<a class=headerlink href=#simp_intro title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.«tacticSimp_intro_____..Only_»</code></p> <p><code>simp_intro</code> 是 <code>simp</code> 和 <code>intro</code> 的结合策略：它在引入变量的同时简化变量的类型，并利用新变量简化后续参数及目标。 * <code>simp_intro x y z</code> 引入名为 <code>x y z</code> 的变量 * <code>simp_intro x y z ..</code> 引入名为 <code>x y z</code> 的变量后，继续引入 <code>_</code> 匿名绑定器 * <code>simp_intro (config := cfg) (discharger := tac) x y .. only [h₁, h₂]</code>： <code>simp_intro</code> 接受与 <code>simp</code> 相同的配置选项（参见 <code>simp</code>）</p> <p>示例： <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>z</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>simp_intro</span><span class=w> </span><span class=n>h</span>
<span class=w>  </span><span class=c1>-- h: x = y ⊢ y = z</span>
<span class=w>  </span><span class=gr>sorry</span>
</code></pre></div></p> <h2 id=simp_rw>simp_rw<a class=headerlink href=#simp_rw title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.tacticSimp_rw___</code></p> <p><code>simp_rw</code> 结合了 <code>simp</code> 和 <code>rw</code> 的功能。类似于 <code>rw</code>，它按顺序应用每条重写规则，但像 <code>simp</code> 一样反复应用这些规则，并处理如 <code>∀ x, ...</code>、<code>∃ x, ...</code> 和 <code>fun x ↦...</code> 等绑定器下的表达式。</p> <p>用法： - <code>simp_rw [lemma_1, ..., lemma_n]</code> 将按顺序应用这些引理来重写目标。以 <code>←</code> 开头的引理将反向应用。 - <code>simp_rw [lemma_1, ..., lemma_n] at h₁ ... hₙ</code> 对指定假设进行重写。 - <code>simp_rw [...] at *</code> 在整个上下文中重写：所有假设及目标。</p> <p>传递给 <code>simp_rw</code> 的引理必须是 <code>simp</code> 的有效参数。例如，以下示例中 <code>simp</code> 和 <code>rw</code> 均无法解决，但 <code>simp_rw</code> 可以：</p> <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>{</span><span class=n>a</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℕ</span><span class=o>}</span>
<span class=w>    </span><span class=o>(</span><span class=n>h1</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=bp>∀</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℕ</span><span class=o>,</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>-</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=bp>≤</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=bp>↔</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>≤</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>1</span><span class=o>)</span>
<span class=w>    </span><span class=o>(</span><span class=n>h2</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=bp>∀</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℕ</span><span class=o>,</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>≤</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=bp>↔</span><span class=w> </span><span class=bp>∀</span><span class=w> </span><span class=n>c</span><span class=o>,</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=n>b</span><span class=o>)</span><span class=w> </span><span class=o>:</span>
<span class=w>    </span><span class=o>(</span><span class=bp>∀</span><span class=w> </span><span class=n>b</span><span class=o>,</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>-</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=bp>≤</span><span class=w> </span><span class=n>b</span><span class=o>)</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=bp>∀</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>ℕ</span><span class=o>,</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>simp_rw</span><span class=w> </span><span class=o>[</span><span class=n>h1</span><span class=o>,</span><span class=w> </span><span class=n>h2</span><span class=o>]</span>
</code></pre></div> <h2 id=simp_wf>simp_wf<a class=headerlink href=#simp_wf title="Permanent link">&para;</a></h2> <p>定义于：<code>tacticSimp_wf</code></p> <p>展开常用于良基关系定义的表达式。</p> <p>自 Lean 4.12 起，Lean 在向用户展示目标前会自动展开这些定义，因此本策略不再必要。可移除 <code>simp_wf</code> 调用，或替换为普通 <code>simp</code> 调用。</p> <h2 id=simpa>simpa<a class=headerlink href=#simpa title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.simpa</code></p> <p>这是 <code>simp</code> 的“终结”策略变体，有两种形式： * <code>simpa [rules, ⋯] using e</code> 会使用 <code>rules</code> 简化目标及 <code>e</code> 的类型，然后尝试用 <code>e</code> 闭合目标。 简化 <code>e</code> 的类型使其更可能匹配目标（目标也已被简化）。此构造在 simp 引理集变更时更具鲁棒性。 * <code>simpa [rules, ⋯]</code> 会简化目标及上下文中的 <code>this</code> 假设（若存在）的类型，然后尝试用 <code>assumption</code> 策略闭合目标。</p> <h2 id=simpa_1>simpa!<a class=headerlink href=#simpa_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.tacticSimpa!_</code></p> <p>这是 <code>simp</code> 的“终结”策略变体，有两种形式： * <code>simpa [rules, ⋯] using e</code> 会使用 <code>rules</code> 简化目标及 <code>e</code> 的类型，然后尝试用 <code>e</code> 闭合目标。 简化 <code>e</code> 的类型使其更可能匹配目标（目标也已被简化）。此构造在 simp 引理集变更时更具鲁棒性。 * <code>simpa [rules, ⋯]</code> 会简化目标及上下文中的 <code>this</code> 假设（若存在）的类型，然后尝试用 <code>assumption</code> 策略闭合目标。</p> <h2 id=simpa_2>simpa?<a class=headerlink href=#simpa_2 title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.tacticSimpa?_</code></p> <p>这是 <code>simp</code> 的“终结”策略变体，有两种形式： * <code>simpa [rules, ⋯] using e</code> 会使用 <code>rules</code> 简化目标及 <code>e</code> 的类型，然后尝试用 <code>e</code> 闭合目标。 简化 <code>e</code> 的类型使其更可能匹配目标（目标也已被简化）。此构造在 simp 引理集变更时更具鲁棒性。 * <code>simpa [rules, ⋯]</code> 会简化目标及上下文中的 <code>this</code> 假设（若存在）的类型，然后尝试用 <code>assumption</code> 策略闭合目标。</p> <h2 id=simpa_3>simpa?!<a class=headerlink href=#simpa_3 title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.tacticSimpa?!_</code></p> <p>这是 <code>simp</code> 的“终结”策略变体，有两种形式： * <code>simpa [rules, ⋯] using e</code> 会使用 <code>rules</code> 简化目标及 <code>e</code> 的类型，然后尝试用 <code>e</code> 闭合目标。 简化 <code>e</code> 的类型使其更可能匹配目标（目标也已被简化）。此构造在 simp 引理集变更时更具鲁棒性。 * <code>simpa [rules, ⋯]</code> 会简化目标及上下文中的 <code>this</code> 假设（若存在）的类型，然后尝试用 <code>assumption</code> 策略闭合目标。</p> <h2 id=sizeof_list_dec>sizeOf_list_dec<a class=headerlink href=#sizeof_list_dec title="Permanent link">&para;</a></h2> <p>定义于：<code>List.tacticSizeOf_list_dec</code></p> <p>此策略已添加至 <code>decreasing_trivial</code> 工具箱，当 <code>a ∈ as</code> 时证明 <code>sizeOf a &lt; sizeOf as</code>，对于嵌套归纳类型如 <code>inductive T | mk : List T → T</code> 的良基递归十分有用。</p> <h2 id=skip>skip<a class=headerlink href=#skip title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.skip</code></p> <p><code>skip</code> 无任何操作。</p> <h2 id=sleep>sleep<a class=headerlink href=#sleep title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.sleep</code></p> <p>策略 <code>sleep ms</code> 暂停 <code>ms</code> 毫秒且不执行任何操作，仅用于调试目的。</p> <h2 id=sleep_heartbeats>sleep_heartbeats<a class=headerlink href=#sleep_heartbeats title="Permanent link">&para;</a></h2> <p>定义于：<code>tacticSleep_heartbeats_</code></p> <p>暂停至少 n 次心跳周期，无任何操作。</p> <h2 id=slice_lhs>slice_lhs<a class=headerlink href=#slice_lhs title="Permanent link">&para;</a></h2> <p>定义于：<code>sliceLHS</code></p> <p><code>slice_lhs a b =&gt; tac</code> 聚焦左侧，根据需要使用范畴组合的结合律，聚焦第 <code>a</code> 至 <code>b</code> 个态射，并调用 <code>tac</code>。</p> <h2 id=slice_rhs>slice_rhs<a class=headerlink href=#slice_rhs title="Permanent link">&para;</a></h2> <p>定义于：<code>sliceRHS</code></p> <p><code>slice_rhs a b =&gt; tac</code> 聚焦右侧，根据需要使用范畴组合的结合律，聚焦第 <code>a</code> 至 <code>b</code> 个态射，并调用 <code>tac</code>。</p> <h2 id=smul_tac>smul_tac<a class=headerlink href=#smul_tac title="Permanent link">&para;</a></h2> <p>定义于：<code>RatFunc.tacticSmul_tac</code></p> <p>通过应用 <code>RatFunc.induction_on</code> 解决 <code>RatFunc K</code> 的方程。</p> <h2 id=solve>solve<a class=headerlink href=#solve title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.solveTactic</code></p> <p>类似于 <code>first</code>，但仅当给定策略之一解决当前目标时成功。</p> <h2 id=solve_by_elim>solve_by_elim<a class=headerlink href=#solve_by_elim title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.solveByElim</code></p> <p><code>solve_by_elim</code> 对主目标调用 <code>apply</code> 寻找头部匹配的假设，随后在生成的子目标上反复调用 <code>apply</code> 直至无子目标残留，最多执行 <code>maxDepth</code>（默认 6）次递归步骤。</p> <p><code>solve_by_elim</code> 解决当前目标或失败。</p> <p>若子目标无法解决，<code>solve_by_elim</code> 将进行回溯。</p> <p>默认情况下，传递给 <code>apply</code> 的假设为局部上下文、<code>rfl</code>、<code>trivial</code>、<code>congrFun</code> 和 <code>congrArg</code>。</p> <p>假设可通过类似 <code>simp</code> 的语法调整： * <code>solve_by_elim [h₁, h₂, ..., hᵣ]</code> 同时应用给定表达式。 * <code>solve_by_elim only [h₁, h₂, ..., hᵣ]</code> 不包含局部上下文、<code>rfl</code>、<code>trivial</code>、<code>congrFun</code> 或 <code>congrArg</code>，除非显式包含。 * <code>solve_by_elim [-h₁, ... -hₙ]</code> 移除给定局部假设。 * <code>solve_by_elim using [a₁, ...]</code> 使用所有标记有属性 <code>aᵢ</code> 的引理（这些属性需通过 <code>register_label_attr</code> 创建）。</p> <p><code>solve_by_elim*</code> 尝试同时解决所有目标，若某目标的解决方案导致其他目标无法解决则进行回溯。 （起始时存在多个目标时，添加或移除局部假设可能表现不稳定。）</p> <p>通过配置参数传递的可选参数 <code>solve_by_elim (config := { ... })</code> - <code>maxDepth</code>: 用于解除生成子目标的最大尝试次数。 - <code>symm</code>: 添加所有通过 <code>symm</code> 派生的假设（默认为 <code>true</code>）。 - <code>exfalso</code>: 允许在 <code>solve_by_elim</code> 失败时调用 <code>exfalso</code> 并重试（默认为 <code>true</code>）。 - <code>transparency</code>: 调用 <code>apply</code> 时更改透明模式。默认为 <code>.default</code>，但通常更改为 <code>.reducible</code>，以便在尝试应用引理时不会展开半可约定义。</p> <p>另请参阅 <code>Lean.Meta.Tactic.Backtrack.BacktrackConfig</code> 的文档注释，了解允许进一步自定义 <code>solve_by_elim</code> 的 <code>proc</code>、<code>suspend</code> 和 <code>discharge</code> 选项。<code>apply_assumption</code> 和 <code>apply_rules</code> 均通过这些钩子实现。</p> <h2 id=sorry>sorry<a class=headerlink href=#sorry title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.tacticSorry</code></p> <p><code>sorry</code> 策略是用于不完整策略证明的临时占位符，使用 <code>exact sorry</code> 关闭主目标。</p> <p>此策略旨在为证明的不完整部分占位，同时保持语法正确的证明框架。每当证明使用 <code>sorry</code> 时，Lean 会发出警告，因此不太可能遗漏。但可以通过查看 <code>#print axioms my_thm</code> 命令输出中的 <code>sorryAx</code> 来确认定理是否依赖 <code>sorry</code>，即 <code>sorry</code> 实现所使用的公理。</p> <h2 id=sorry_if_sorry>sorry_if_sorry<a class=headerlink href=#sorry_if_sorry title="Permanent link">&para;</a></h2> <p>定义于：<code>CategoryTheory.sorryIfSorry</code></p> <p>如果主目标的类型包含 <code>sorry</code>，则使用 <code>sorry</code> 关闭主目标，否则失败。</p> <h2 id=specialize>specialize<a class=headerlink href=#specialize title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.specialize</code></p> <p>策略 <code>specialize h a₁ ... aₙ</code> 作用于局部假设 <code>h</code>。该假设的前提（无论是全称量化还是非依赖蕴含）通过具体项 <code>a₁ ... aₙ</code> 实例化。该策略添加一个同名新假设 <code>h := h a₁ ... aₙ</code>，并尝试清除之前的假设。</p> <h2 id=specialize_all>specialize_all<a class=headerlink href=#specialize_all title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.TautoSet.specialize_all</code></p> <p><code>specialize_all x</code> 对所有假设 <code>h</code> 运行 <code>specialize h x</code>，只要该策略成功。</p> <h2 id=split>split<a class=headerlink href=#split title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.split</code></p> <p><code>split</code> 策略用于将嵌套的 if-then-else 和 <code>match</code> 表达式拆分为单独的情况。对于有 <code>n</code> 个情况的 <code>match</code> 表达式，<code>split</code> 最多生成 <code>n</code> 个子目标。</p> <p>例如，给定 <code>n : Nat</code> 和目标 <code>if n = 0 then Q else R</code>，<code>split</code> 将生成一个具有假设 <code>n = 0</code> 和目标 <code>Q</code> 的子目标，以及第二个具有假设 <code>¬n = 0</code> 和目标 <code>R</code> 的子目标。注意引入的假设未命名，通常使用 <code>case</code> 或 <code>next</code> 策略重命名。</p> <ul> <li><code>split</code> 将拆分目标（主目标）。</li> <li><code>split at h</code> 将拆分假设 <code>h</code>。</li> </ul> <h2 id=split_ands>split_ands<a class=headerlink href=#split_ands title="Permanent link">&para;</a></h2> <p>定义于：<code>Batteries.Tactic.tacticSplit_ands</code></p> <p><code>split_ands</code> 应用 <code>And.intro</code> 直到不再进展。</p> <h2 id=split_ifs>split_ifs<a class=headerlink href=#split_ifs title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.splitIfs</code></p> <p>将所有 if-then-else 表达式拆分为多个目标。给定形式为 <code>g (if p then x else y)</code> 的目标，<code>split_ifs</code> 将生成两个目标：<code>p ⊢ g x</code> 和 <code>¬p ⊢ g y</code>。若存在多个 ite 表达式，<code>split_ifs</code> 将拆分所有，从顶层开始，其条件不包含其他 ite 表达式。<code>split_ifs at *</code> 拆分所有假设中的 ite 表达式及目标。<code>split_ifs with h₁ h₂ h₃</code> 覆盖默认假设名称。</p> <h2 id=squeeze_scope>squeeze_scope<a class=headerlink href=#squeeze_scope title="Permanent link">&para;</a></h2> <p>定义于：<code>Batteries.Tactic.squeezeScope</code></p> <p><code>squeeze_scope</code> 策略允许聚合来自同一语法但在不同执行分支的多个 <code>simp</code> 调用，例如 <code>cases x &lt;;&gt; simp</code>。报告的 <code>simp</code> 调用涵盖该语法使用的所有 simp 引理。</p> <div class=highlight><pre><span></span><code><span class=kd>@[</span><span class=n>simp</span><span class=kd>]</span><span class=w> </span><span class=kd>def</span><span class=w> </span><span class=n>bar</span><span class=w> </span><span class=o>(</span><span class=n>z</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Nat</span><span class=o>)</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>z</span>
<span class=kd>@[</span><span class=n>simp</span><span class=kd>]</span><span class=w> </span><span class=kd>def</span><span class=w> </span><span class=n>baz</span><span class=w> </span><span class=o>(</span><span class=n>z</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Nat</span><span class=o>)</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>z</span>

<span class=kd>@[</span><span class=n>simp</span><span class=kd>]</span><span class=w> </span><span class=kd>def</span><span class=w> </span><span class=n>foo</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Nat</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>Nat</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>Nat</span>
<span class=w>  </span><span class=bp>|</span><span class=w> </span><span class=mi>0</span><span class=o>,</span><span class=w> </span><span class=n>z</span><span class=w> </span><span class=bp>=&gt;</span><span class=w> </span><span class=n>bar</span><span class=w> </span><span class=n>z</span>
<span class=w>  </span><span class=bp>|</span><span class=w> </span><span class=n>_</span><span class=bp>+</span><span class=mi>1</span><span class=o>,</span><span class=w> </span><span class=n>z</span><span class=w> </span><span class=bp>=&gt;</span><span class=w> </span><span class=n>baz</span><span class=w> </span><span class=n>z</span>

<span class=kd>example</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>foo</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>cases</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>&lt;;&gt;</span><span class=w> </span><span class=n>simp</span><span class=bp>?</span><span class=w> </span><span class=c1>-- 两次输出：</span>
<span class=w>  </span><span class=c1>-- &quot;Try this: simp only [foo, bar]&quot;</span>
<span class=w>  </span><span class=c1>-- &quot;Try this: simp only [foo, baz]&quot;</span>

<span class=kd>example</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>foo</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>squeeze_scope</span>
<span class=w>    </span><span class=n>cases</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>&lt;;&gt;</span><span class=w> </span><span class=n>simp</span><span class=w> </span><span class=c1>-- 仅一次输出：&quot;Try this: simp only [foo, baz, bar]&quot;</span>
</code></pre></div> <h2 id=stop>stop<a class=headerlink href=#stop title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.tacticStop_</code></p> <p><code>stop</code> 是用于“丢弃”剩余证明的辅助策略：定义为 <code>repeat sorry</code>。在处理复杂证明的中间部分时非常有用，比注释剩余证明更整洁。</p> <h2 id=subsingleton>subsingleton<a class=headerlink href=#subsingleton title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.subsingletonStx</code></p> <p><code>subsingleton</code> 策略尝试使用所涉及类型为 <strong>子单一类型</strong>（恰好有零或一个项的类型）的事实来证明形式为 <code>x = y</code> 或 <code>HEq x y</code> 的目标。近似地说，它执行 <code>apply Subsingleton.elim</code>。作为优化，<code>subsingleton</code> 首先运行 <code>intros</code> 策略。</p> <ul> <li>若目标是等式，则要么关闭目标，要么失败。</li> <li><code>subsingleton [inst1, inst2, ...]</code> 可用于向局部上下文添加额外的 <code>Subsingleton</code> 实例。这比 <code>have := inst1; have := inst2; ...; subsingleton</code> 更灵活，因为该策略不要求所有占位符都被解决。</li> </ul> <p><code>subsingleton</code> 策略可应用的技术： - 证明无关性 - 异质证明无关性（通过 <code>proof_irrel_heq</code>） - 使用 <code>Subsingleton</code>（通过 <code>Subsingleton.elim</code>） - 若 <code>BEq</code> 实例均为合法，则证明它们相等（通过 <code>lawful_beq_subsingleton</code>）</p> <h3 id=_12>特性<a class=headerlink href=#_12 title="Permanent link">&para;</a></h3> <p>该策略谨慎避免意外将 <code>Sort _</code> 特化为 <code>Prop</code>，防止 <code>apply Subsingleton.elim</code> 的以下意外行为：</p> <p><div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>α</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=kt>Sort</span><span class=w> </span><span class=n>_</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>x</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>α</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span><span class=w> </span><span class=n>apply</span><span class=w> </span><span class=n>Subsingleton.elim</span>
</code></pre></div> 此 <code>example</code> 通过的原因在于应用了 <code>∀ (p : Prop), Subsingleton p</code> 实例，将 <code>Sort _</code> 的宇宙级别元变量特化为 <code>0</code>。</p> <h2 id=subst>subst<a class=headerlink href=#subst title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.subst</code></p> <p><code>subst x...</code> 在目标中用 <code>e</code> 替换每个 <code>x</code>，前提是有类型为 <code>x = e</code> 或 <code>e = x</code> 的假设。若 <code>x</code> 本身是类型为 <code>y = e</code> 或 <code>e = y</code> 的假设，则替换 <code>y</code>。</p> <h2 id=subst_eqs>subst_eqs<a class=headerlink href=#subst_eqs title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.substEqs</code></p> <p><code>subst_eq</code> 根据上下文中的等式证明假设反复替换，将等式的左侧替换为右侧，直到无法进一步进展。</p> <h2 id=subst_hom_lift>subst_hom_lift<a class=headerlink href=#subst_hom_lift title="Permanent link">&para;</a></h2> <p>定义于：<code>CategoryTheory.tacticSubst_hom_lift___</code></p> <p><code>subst_hom_lift p f φ</code> 尝试通过使用 <code>p.IsHomLift f φ</code> 将 <code>f</code> 替换为 <code>p(φ)</code>。</p> <h2 id=subst_vars>subst_vars<a class=headerlink href=#subst_vars title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.substVars</code></p> <p>对形式为 <code>h : x = t</code> 或 <code>h : t = x</code> 的所有假设应用 <code>subst</code>。</p> <h2 id=substs>substs<a class=headerlink href=#substs title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.Substs.substs</code></p> <p>从左到右对所有给定假设应用 <code>subst</code> 策略。</p> <h2 id=success_if_fail_with_msg>success_if_fail_with_msg<a class=headerlink href=#success_if_fail_with_msg title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.successIfFailWithMsg</code></p> <p><code>success_if_fail_with_msg msg tacs</code> 运行 <code>tacs</code> 且仅在其因消息 <code>msg</code> 失败时成功。</p> <p><code>msg</code> 可以是任何评估为显式 <code>String</code> 的项。</p> <h2 id=suffices>suffices<a class=headerlink href=#suffices title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.tacticSuffices_</code></p> <p>给定主目标 <code>ctx ⊢ t</code>，<code>suffices h : t' from e</code> 将主目标替换为 <code>ctx ⊢ t'</code>，<code>e</code> 必须在上下文 <code>ctx, h : t'</code> 中具有类型 <code>t</code>。</p> <p>变体 <code>suffices h : t' by tac</code> 是 <code>suffices h : t' from by tac</code> 的简写。若省略 <code>h :</code>，则使用名称 <code>this</code>。</p> <h2 id=suffices_1>suffices<a class=headerlink href=#suffices_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.tacticSuffices_</code></p> <h2 id=suggest_premises>suggest_premises<a class=headerlink href=#suggest_premises title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.suggestPremises</code></p> <p><code>#suggest_premises</code> 将建议当前目标的前提，使用当前注册的前提选择器。</p> <p>建议按置信度从高到低排序。</p> <h2 id=swap>swap<a class=headerlink href=#swap title="Permanent link">&para;</a></h2> <p>定义于：<code>Batteries.Tactic.tacticSwap</code></p> <p><code>swap</code> 是 <code>pick_goal 2</code> 的快捷方式，交换第一个和第二个目标。</p> <h2 id=swap_var>swap_var<a class=headerlink href=#swap_var title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.«tacticSwap_var__,,»</code></p> <p><code>swap_var swap_rule₁, swap_rule₂, ⋯</code> 依次应用 <code>swap_rule₁</code> 然后 <code>swap_rule₂</code> 然后 <code>⋯</code>。</p> <p><em>交换规则</em> 的形式为 <code>x y</code> 或 <code>x ↔ y</code>，“应用”它意味着在所有假设和目标上将变量名 <code>x</code> 和 <code>y</code> 互换。</p> <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>{</span><span class=n>P</span><span class=w> </span><span class=n>Q</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=kt>Prop</span><span class=o>}</span><span class=w> </span><span class=o>(</span><span class=n>q</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>P</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>p</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Q</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>P</span><span class=w> </span><span class=bp>∧</span><span class=w> </span><span class=n>Q</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>swap_var</span><span class=w> </span><span class=n>p</span><span class=w> </span><span class=bp>↔</span><span class=w> </span><span class=n>q</span>
<span class=w>  </span><span class=n>exact</span><span class=w> </span><span class=o>⟨</span><span class=n>p</span><span class=o>,</span><span class=w> </span><span class=n>q</span><span class=o>⟩</span>
</code></pre></div> <h2 id=symm>symm<a class=headerlink href=#symm title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.symm</code></p> <ul> <li><code>symm</code> 应用于目标形式为 <code>t ~ u</code> 的情况，其中 <code>~</code> 是一个对称关系，即具有标记为属性 [symm] 的对称性引理的关系。它将目标替换为 <code>u ~ t</code>。</li> <li><code>symm at h</code> 将重写假设 <code>h : t ~ u</code> 为 <code>h : u ~ t</code>。</li> </ul> <h2 id=symm_saturate>symm_saturate<a class=headerlink href=#symm_saturate title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.symmSaturate</code></p> <p>对于每个假设 <code>h : a ~ b</code>（其中存在可用的 <code>@[symm]</code> 引理），添加一个假设 <code>h_symm : b ~ a</code>。</p> <h2 id=tauto>tauto<a class=headerlink href=#tauto title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.Tauto.tauto</code></p> <p><code>tauto</code> 分解形如 <code>_ ∧ _</code>、<code>_ ∨ _</code>、<code>_ ↔ _</code> 和 <code>∃ _, _</code> 的假设，并将形如 <code>_ ∧ _</code>、<code>_ ↔ _</code> 或 <code>∃ _, _</code> 的目标拆分，直到可以通过 <code>reflexivity</code> 或 <code>solve_by_elim</code> 完成。这是一个终结策略：它要么闭合目标，要么抛出错误。</p> <p>Lean 3 版本的此策略默认尽量避免使用经典推理。而 Lean 4 版本不再进行此类尝试。<code>itauto</code> 策略专为此目的设计。</p> <h2 id=tauto_set>tauto_set<a class=headerlink href=#tauto_set title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.TautoSet.tacticTauto_set</code></p> <p><code>tauto_set</code> 尝试证明涉及形如 <code>X ⊆ Y</code> 或 <code>X = Y</code> 的假设和目标的同义反复，其中 <code>X</code>、<code>Y</code> 是使用 ∪、∩、 和 ᶜ 从有限多个 <code>Set α</code> 类型的变量构建的表达式。它还会展开形如 <code>Disjoint A B</code> 和 <code>symmDiff A B</code> 的表达式。</p> <p>示例： <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>{</span><span class=n>α</span><span class=o>}</span><span class=w> </span><span class=o>(</span><span class=n>A</span><span class=w> </span><span class=n>B</span><span class=w> </span><span class=n>C</span><span class=w> </span><span class=n>D</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Set</span><span class=w> </span><span class=n>α</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>h1</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>A</span><span class=w> </span><span class=bp>⊆</span><span class=w> </span><span class=n>B</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>h2</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>C</span><span class=w> </span><span class=bp>⊆</span><span class=w> </span><span class=n>D</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>C</span><span class=w> </span><span class=bp>\</span><span class=w> </span><span class=n>B</span><span class=w> </span><span class=bp>⊆</span><span class=w> </span><span class=n>D</span><span class=w> </span><span class=bp>\</span><span class=w> </span><span class=n>A</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>tauto_set</span>

<span class=kd>example</span><span class=w> </span><span class=o>{</span><span class=n>α</span><span class=o>}</span><span class=w> </span><span class=o>(</span><span class=n>A</span><span class=w> </span><span class=n>B</span><span class=w> </span><span class=n>C</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Set</span><span class=w> </span><span class=n>α</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>h1</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>A</span><span class=w> </span><span class=bp>⊆</span><span class=w> </span><span class=n>B</span><span class=w> </span><span class=bp>∪</span><span class=w> </span><span class=n>C</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=o>(</span><span class=n>A</span><span class=w> </span><span class=bp>∩</span><span class=w> </span><span class=n>B</span><span class=o>)</span><span class=w> </span><span class=bp>∪</span><span class=w> </span><span class=o>(</span><span class=n>A</span><span class=w> </span><span class=bp>∩</span><span class=w> </span><span class=n>C</span><span class=o>)</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>A</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>tauto_set</span>
</code></pre></div></p> <h2 id=tfae_finish>tfae_finish<a class=headerlink href=#tfae_finish title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.TFAE.tfaeFinish</code></p> <p><code>tfae_finish</code> 用于闭合形如 <code>TFAE [P₁, P₂, ...]</code> 的目标，一旦向局部上下文中引入了足够多的形如 <code>Pᵢ → Pⱼ</code> 或 <code>Pᵢ ↔ Pⱼ</code> 的假设。</p> <p><code>tfae_have</code> 可方便地引入这些假设；参见 <code>tfae_have</code>。</p> <p>示例： <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>TFAE</span><span class=w> </span><span class=o>[</span><span class=n>P</span><span class=o>,</span><span class=w> </span><span class=n>Q</span><span class=o>,</span><span class=w> </span><span class=n>R</span><span class=o>]</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>tfae_have</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=gr>sorry</span><span class=w> </span><span class=c>/-</span><span class=cm> 证明 P → Q -/</span>
<span class=w>  </span><span class=n>tfae_have</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=gr>sorry</span><span class=w> </span><span class=c>/-</span><span class=cm> 证明 Q → P -/</span>
<span class=w>  </span><span class=n>tfae_have</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=bp>↔</span><span class=w> </span><span class=mi>3</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=gr>sorry</span><span class=w> </span><span class=c>/-</span><span class=cm> 证明 Q ↔ R -/</span>
<span class=w>  </span><span class=n>tfae_finish</span>
</code></pre></div></p> <h2 id=tfae_have>tfae_have<a class=headerlink href=#tfae_have title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.TFAE.tfaeHave</code></p> <p><code>tfae_have</code> 引入用于证明形如 <code>TFAE [P₁, P₂, ...]</code> 目标的假设。具体来说，<code>tfae_have i &lt;箭头&gt; j := ...</code> 向局部上下文中引入一个类型为 <code>Pᵢ &lt;箭头&gt; Pⱼ</code> 的假设，其中 <code>&lt;箭头&gt;</code> 可以是 <code>→</code>、<code>←</code> 或 <code>↔</code>。注意 <code>i</code> 和 <code>j</code> 是自然数索引（从 1 开始），用于指定目标中出现的命题 <code>P₁, P₂, ...</code>。</p> <p><div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>P</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>R</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>TFAE</span><span class=w> </span><span class=o>[</span><span class=n>P</span><span class=o>,</span><span class=w> </span><span class=n>Q</span><span class=o>,</span><span class=w> </span><span class=n>R</span><span class=o>]</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>tfae_have</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=mi>3</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=n>h</span>
<span class=w>  </span><span class=bp>...</span>
</code></pre></div> 现在上下文中包含 <code>tfae_1_to_3 : P → R</code>。</p> <p>一旦通过 <code>tfae_have</code> 引入了足够的假设，即可使用 <code>tfae_finish</code> 闭合目标。例如：</p> <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>TFAE</span><span class=w> </span><span class=o>[</span><span class=n>P</span><span class=o>,</span><span class=w> </span><span class=n>Q</span><span class=o>,</span><span class=w> </span><span class=n>R</span><span class=o>]</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>tfae_have</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=gr>sorry</span><span class=w> </span><span class=c>/-</span><span class=cm> 证明 P → Q -/</span>
<span class=w>  </span><span class=n>tfae_have</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=gr>sorry</span><span class=w> </span><span class=c>/-</span><span class=cm> 证明 Q → P -/</span>
<span class=w>  </span><span class=n>tfae_have</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=bp>↔</span><span class=w> </span><span class=mi>3</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=gr>sorry</span><span class=w> </span><span class=c>/-</span><span class=cm> 证明 Q ↔ R -/</span>
<span class=w>  </span><span class=n>tfae_finish</span>
</code></pre></div> <p><code>tfae_have</code> 支持 <code>have</code> 的所有功能，包括命名、匹配、解构和目标创建。以下示例展示了这些功能：</p> <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>TFAE</span><span class=w> </span><span class=o>[</span><span class=n>P</span><span class=o>,</span><span class=w> </span><span class=n>Q</span><span class=o>]</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=c1>-- 断言 `tfae_1_to_2 : P → Q`：</span>
<span class=w>  </span><span class=n>tfae_have</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=gr>sorry</span>

<span class=w>  </span><span class=c1>-- 断言 `hpq : P → Q`：</span>
<span class=w>  </span><span class=n>tfae_have</span><span class=w> </span><span class=n>hpq</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=gr>sorry</span>

<span class=w>  </span><span class=c1>-- 匹配 `p : P` 并通过 `f p` 证明 `Q`：</span>
<span class=w>  </span><span class=n>tfae_have</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=mi>2</span>
<span class=w>  </span><span class=bp>|</span><span class=w> </span><span class=n>p</span><span class=w> </span><span class=bp>=&gt;</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=n>p</span>

<span class=w>  </span><span class=c1>-- 断言 `pq : P → Q`，`qp : Q → P`：</span>
<span class=w>  </span><span class=n>tfae_have</span><span class=w> </span><span class=o>⟨</span><span class=n>pq</span><span class=o>,</span><span class=w> </span><span class=n>qp</span><span class=o>⟩</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=bp>↔</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=gr>sorry</span>

<span class=w>  </span><span class=c1>-- 断言 `h : P → Q`；`?a` 是一个新目标：</span>
<span class=w>  </span><span class=n>tfae_have</span><span class=w> </span><span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=bp>?</span><span class=n>a</span>
<span class=w>  </span><span class=bp>...</span>
</code></pre></div> <h2 id=tfae_have_1>tfae_have<a class=headerlink href=#tfae_have_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.TFAE.tfaeHave'</code></p> <p>“目标式” <code>tfae_have</code> 语法已弃用。现在，<code>tfae_have ...</code> 后应跟随 <code>:= ...</code>；有关新行为，请参见下文。可通过 <code>set_option Mathlib.Tactic.TFAE.useDeprecated true</code> 关闭此警告。</p> <hr> <p><code>tfae_have</code> 引入用于证明形如 <code>TFAE [P₁, P₂, ...]</code> 目标的假设。具体来说，<code>tfae_have i &lt;箭头&gt; j := ...</code> 向局部上下文中引入一个类型为 <code>Pᵢ &lt;箭头&gt; Pⱼ</code> 的假设，其中 <code>&lt;箭头&gt;</code> 可以是 <code>→</code>、<code>←</code> 或 <code>↔</code>。注意 <code>i</code> 和 <code>j</code> 是自然数索引（从 1 开始），用于指定目标中出现的命题 <code>P₁, P₂, ...</code>。</p> <p><div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>P</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>R</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>TFAE</span><span class=w> </span><span class=o>[</span><span class=n>P</span><span class=o>,</span><span class=w> </span><span class=n>Q</span><span class=o>,</span><span class=w> </span><span class=n>R</span><span class=o>]</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>tfae_have</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=mi>3</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=n>h</span>
<span class=w>  </span><span class=bp>...</span>
</code></pre></div> 现在上下文中包含 <code>tfae_1_to_3 : P → R</code>。</p> <p>一旦通过 <code>tfae_have</code> 引入了足够的假设，即可使用 <code>tfae_finish</code> 闭合目标。例如：</p> <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>TFAE</span><span class=w> </span><span class=o>[</span><span class=n>P</span><span class=o>,</span><span class=w> </span><span class=n>Q</span><span class=o>,</span><span class=w> </span><span class=n>R</span><span class=o>]</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>tfae_have</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=gr>sorry</span><span class=w> </span><span class=c>/-</span><span class=cm> 证明 P → Q -/</span>
<span class=w>  </span><span class=n>tfae_have</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=gr>sorry</span><span class=w> </span><span class=c>/-</span><span class=cm> 证明 Q → P -/</span>
<span class=w>  </span><span class=n>tfae_have</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=bp>↔</span><span class=w> </span><span class=mi>3</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=gr>sorry</span><span class=w> </span><span class=c>/-</span><span class=cm> 证明 Q ↔ R -/</span>
<span class=w>  </span><span class=n>tfae_finish</span>
</code></pre></div> <p><code>tfae_have</code> 支持 <code>have</code> 的所有功能，包括命名、匹配、解构和目标创建。以下示例展示了这些功能：</p> <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>TFAE</span><span class=w> </span><span class=o>[</span><span class=n>P</span><span class=o>,</span><span class=w> </span><span class=n>Q</span><span class=o>]</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=c1>-- 断言 `tfae_1_to_2 : P → Q`：</span>
<span class=w>  </span><span class=n>tfae_have</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=gr>sorry</span>

<span class=w>  </span><span class=c1>-- 断言 `hpq : P → Q`：</span>
<span class=w>  </span><span class=n>tfae_have</span><span class=w> </span><span class=n>hpq</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=gr>sorry</span>

<span class=w>  </span><span class=c1>-- 匹配 `p : P` 并通过 `f p` 证明 `Q`：</span>
<span class=w>  </span><span class=n>tfae_have</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=mi>2</span>
<span class=w>  </span><span class=bp>|</span><span class=w> </span><span class=n>p</span><span class=w> </span><span class=bp>=&gt;</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=n>p</span>

<span class=w>  </span><span class=c1>-- 断言 `pq : P → Q`，`qp : Q → P`：</span>
<span class=w>  </span><span class=n>tfae_have</span><span class=w> </span><span class=o>⟨</span><span class=n>pq</span><span class=o>,</span><span class=w> </span><span class=n>qp</span><span class=o>⟩</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=bp>↔</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=gr>sorry</span>

<span class=w>  </span><span class=c1>-- 断言 `h : P → Q`；`?a` 是一个新目标：</span>
<span class=w>  </span><span class=n>tfae_have</span><span class=w> </span><span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=bp>?</span><span class=n>a</span>
<span class=w>  </span><span class=bp>...</span>
</code></pre></div> <h2 id=tofinite_tac>toFinite_tac<a class=headerlink href=#tofinite_tac title="Permanent link">&para;</a></h2> <p>定义于：<code>Set.tacticToFinite_tac</code></p> <p>一种（用于默认参数中的）策略，应用 <code>Set.toFinite</code> 来合成 <code>Set.Finite</code> 项。</p> <h2 id=to_encard_tac>to_encard_tac<a class=headerlink href=#to_encard_tac title="Permanent link">&para;</a></h2> <p>定义于：<code>Set.tacticTo_encard_tac</code></p> <p>一种有助于将 <code>encard</code> 的证明转移到其对应的 <code>card</code> 陈述中的策略</p> <h2 id=trace>trace<a class=headerlink href=#trace title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.trace</code></p> <p>将术语求值为字符串（可能时），并作为跟踪消息打印。</p> <h2 id=trace_1>trace<a class=headerlink href=#trace_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.traceMessage</code></p> <p><code>trace msg</code> 在信息视图中显示 <code>msg</code>。</p> <h2 id=trace_state>trace_state<a class=headerlink href=#trace_state title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.traceState</code></p> <p><code>trace_state</code> 在信息视图中显示当前状态。</p> <h2 id=trans>trans<a class=headerlink href=#trans title="Permanent link">&para;</a></h2> <p>定义于：<code>Batteries.Tactic.tacticTrans___</code></p> <p><code>trans</code> 应用于目标形式为 <code>t ~ u</code> 的情况，其中 <code>~</code> 是一个传递关系，即具有标记为属性 [trans] 的传递性引理的关系。</p> <ul> <li><code>trans s</code> 将目标替换为两个子目标 <code>t ~ s</code> 和 <code>s ~ u</code>。</li> <li>若省略 <code>s</code>，则使用一个元变量代替。</li> </ul> <p>此外，<code>trans</code> 也应用于目标形式为 <code>t → u</code> 的情况，此时它将目标替换为 <code>t → s</code> 和 <code>s → u</code>。</p> <h2 id=transitivity>transitivity<a class=headerlink href=#transitivity title="Permanent link">&para;</a></h2> <p>定义于：<code>Batteries.Tactic.tacticTransitivity___</code></p> <p><code>trans</code> 策略的同义词。</p> <h2 id=triv>triv<a class=headerlink href=#triv title="Permanent link">&para;</a></h2> <p>定义于：<code>Batteries.Tactic.triv</code></p> <p>已弃用的 <code>trivial</code> 变体。</p> <h2 id=trivial>trivial<a class=headerlink href=#trivial title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.tacticTrivial</code></p> <p><code>trivial</code> 尝试不同的简单策略（如 <code>rfl</code>、<code>contradiction</code> 等）以闭合当前目标。您可以使用 <code>macro_rules</code> 命令扩展所使用的策略集合。例如： <div class=highlight><pre><span></span><code><span class=n>macro_rules</span><span class=w> </span><span class=bp>|</span><span class=w> </span><span class=bp>`</span><span class=o>(</span><span class=n>tactic</span><span class=bp>|</span><span class=w> </span><span class=n>trivial</span><span class=o>)</span><span class=w> </span><span class=bp>=&gt;</span><span class=w> </span><span class=bp>`</span><span class=o>(</span><span class=n>tactic</span><span class=bp>|</span><span class=w> </span><span class=n>simp</span><span class=o>)</span>
</code></pre></div></p> <h2 id=try>try<a class=headerlink href=#try title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.tacticTry_</code></p> <p><code>try tac</code> 运行 <code>tac</code> 并在 <code>tac</code> 失败时仍视为成功。</p> <h2 id=try_1>try?<a class=headerlink href=#try_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.tryTrace</code></p> <h2 id=try_suggestions>try_suggestions<a class=headerlink href=#try_suggestions title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.tryResult</code></p> <p>用于在 <code>try?</code> 中实现 <code>evalSuggest</code> 的内部辅助策略</p> <h2 id=try_this>try_this<a class=headerlink href=#try_this title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.tacticTry_this__</code></p> <p>生成文本 <code>Try this: &lt;tac&gt;</code> 并执行给定的策略。</p> <h2 id=type_check>type_check<a class=headerlink href=#type_check title="Permanent link">&para;</a></h2> <p>定义于：<code>tacticType_check_</code></p> <p>对给定表达式进行类型检查，并追踪其类型。</p> <h2 id=unfold>unfold<a class=headerlink href=#unfold title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.unfold</code></p> <ul> <li><code>unfold id</code> 展开目标中定义 <code>id</code> 的所有出现。</li> <li><code>unfold id1 id2 ...</code> 等效于 <code>unfold id1; unfold id2; ...</code>。</li> <li><code>unfold id at h</code> 在假设 <code>h</code> 处展开。</li> </ul> <p>定义可以是全局或局部定义。</p> <p>对于非递归的全局定义，此策略与 <code>delta</code> 相同。对于递归的全局定义，它使用由用户给出的递归定义生成的“展开引理” <code>id.eq_def</code> 来展开。仅执行一级展开，与 <code>simp only [id]</code> 不同，后者递归展开定义 <code>id</code>。</p> <h2 id=unfold_1>unfold?<a class=headerlink href=#unfold_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.InteractiveUnfold.tacticUnfold?</code></p> <p>将选定的表达式替换为定义展开。 - 每次展开后，我们应用<code>whnfCore</code>来简化表达式。 - 显式的自然数表达式会被求值。 - 标记有<code>@[default_instance]</code>的类投影实例的展开不会被显示。这对于如<code>+</code>这样的符号类型类很重要：我们不希望将<code>Add.add a b</code>作为<code>a + b</code>的展开建议。类似地，<code>OfNat n : Nat</code>展开为<code>n : Nat</code>。</p> <p>使用<code>unfold?</code>时，按住Shift键点击策略状态中的表达式。这将为选定的表达式提供重写建议列表。点击建议将用执行该重写的策略替换<code>unfold?</code>。</p> <h2 id=unfold_let>unfold_let<a class=headerlink href=#unfold_let title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.unfoldLetStx</code></p> <p>此策略已被<code>unfold</code>策略取代。</p> <p><code>unfold_let x y z at loc</code>在给定位置展开局部定义<code>x</code>、<code>y</code>和<code>z</code>，这被称为“zeta约简”。此策略也可作为<code>conv</code>模式策略使用。</p> <p>若未指定局部定义，则展开所有局部定义。此变体也可作为<code>conv</code>模式策略<code>zeta</code>使用。</p> <h2 id=unfold_projs>unfold_projs<a class=headerlink href=#unfold_projs title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.unfoldProjsStx</code></p> <p><code>unfold_projs at loc</code>在给定位置展开类实例的投影。此策略也可作为<code>conv</code>模式策略使用。</p> <h2 id=unhygienic>unhygienic<a class=headerlink href=#unhygienic title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.tacticUnhygienic_</code></p> <p><code>unhygienic tacs</code>运行<code>tacs</code>时禁用名称卫生机制。这意味着通常会生成不可访问名称的策略将生成常规变量。<strong>警告</strong>：策略可能随时更改其变量命名策略，因此依赖自动生成名称的代码较为脆弱。用户应尽可能避免使用<code>unhygienic</code>。</p> <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=bp>∀</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Nat</span><span class=o>,</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span><span class=w> </span><span class=n>unhygienic</span>
<span class=w>  </span><span class=n>intro</span><span class=w>            </span><span class=c1>-- x通常会被引入为不可访问</span>
<span class=w>  </span><span class=n>exact</span><span class=w> </span><span class=n>Eq.refl</span><span class=w> </span><span class=n>x</span><span class=w>  </span><span class=c1>-- 引用x</span>
</code></pre></div> <h2 id=uniquediffwithinat_ici_iic_univ>uniqueDiffWithinAt_Ici_Iic_univ<a class=headerlink href=#uniquediffwithinat_ici_iic_univ title="Permanent link">&para;</a></h2> <p>定义于：<code>intervalIntegral.tacticUniqueDiffWithinAt_Ici_Iic_univ</code></p> <p>一个辅助策略，用于关闭目标<code>UniqueDiffWithinAt ℝ s a</code>，其中<code>s ∈ {Iic a, Ici a, univ}</code>。</p> <h2 id=unit_interval>unit_interval<a class=headerlink href=#unit_interval title="Permanent link">&para;</a></h2> <p>定义于：<code>Tactic.Interactive.tacticUnit_interval</code></p> <p>一个解决<code>0 ≤ ↑x</code>、<code>0 ≤ 1 - ↑x</code>、<code>↑x ≤ 1</code>和<code>1 - ↑x ≤ 1</code>对于<code>x : I</code>的策略。</p> <h2 id=unreachable>unreachable!<a class=headerlink href=#unreachable title="Permanent link">&para;</a></h2> <p>定义于：<code>Batteries.Tactic.unreachable</code></p> <p>此策略在运行时（编译时）引发恐慌。（这与<code>exact unreachable!</code>不同，后者插入在运行时恐慌的代码。）</p> <p>它用于测试中，以断言某个策略永远不会被执行，否则这是不寻常的做法（而<code>unreachableTactic</code>检查器会对此发出警告）。</p> <p><code>unreachableTactic</code>检查器对<code>unreachable!</code>的使用有特殊例外。</p> <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>True</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span><span class=w> </span><span class=n>trivial</span><span class=w> </span><span class=bp>&lt;;&gt;</span><span class=w> </span><span class=n>unreachable</span><span class=bp>!</span>
</code></pre></div> <h2 id=use>use<a class=headerlink href=#use title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.useSyntax</code></p> <p><code>use e₁, e₂, ⋯</code>类似于<code>exists</code>，但与<code>exists</code>不同，它等效于应用策略<code>refine ⟨e₁, e₂, ⋯, ?_, ⋯, ?_⟩</code>，带有任意数量的占位符（而非仅一个），然后尝试用可配置的解除器关闭与占位符关联的目标（而非仅<code>try trivial</code>）。</p> <p>示例：</p> <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=bp>∃</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Nat</span><span class=o>,</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span><span class=w> </span><span class=n>use</span><span class=w> </span><span class=mi>42</span>

<span class=kd>example</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=bp>∃</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Nat</span><span class=o>,</span><span class=w> </span><span class=bp>∃</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Nat</span><span class=o>,</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span><span class=w> </span><span class=n>use</span><span class=w> </span><span class=mi>42</span><span class=o>,</span><span class=w> </span><span class=mi>42</span>

<span class=kd>example</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=bp>∃</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=bp>×</span><span class=w> </span><span class=n>String</span><span class=o>,</span><span class=w> </span><span class=n>x</span><span class=bp>.</span><span class=mi>1</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>x</span><span class=bp>.</span><span class=mi>2</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span><span class=w> </span><span class=n>use</span><span class=w> </span><span class=o>(</span><span class=s2>&quot;forty-two&quot;</span><span class=o>,</span><span class=w> </span><span class=s2>&quot;forty-two&quot;</span><span class=o>)</span>
</code></pre></div> <p><code>use! e₁, e₂, ⋯</code>类似，但它会在所有地方应用构造函数，而不仅仅针对构造器最后一个参数对应的目标。这产生了一种效果，即嵌套的构造函数被展开，提供的值被用于构造函数树的叶子和节点。使用<code>use!</code>可以逐个输入每个<code>42</code>：</p> <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=bp>∃</span><span class=w> </span><span class=n>p</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Nat</span><span class=w> </span><span class=bp>×</span><span class=w> </span><span class=n>Nat</span><span class=o>,</span><span class=w> </span><span class=n>p</span><span class=bp>.</span><span class=mi>1</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>p</span><span class=bp>.</span><span class=mi>2</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span><span class=w> </span><span class=n>use</span><span class=bp>!</span><span class=w> </span><span class=mi>42</span><span class=o>,</span><span class=w> </span><span class=mi>42</span>

<span class=kd>example</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=bp>∃</span><span class=w> </span><span class=n>p</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Nat</span><span class=w> </span><span class=bp>×</span><span class=w> </span><span class=n>Nat</span><span class=o>,</span><span class=w> </span><span class=n>p</span><span class=bp>.</span><span class=mi>1</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>p</span><span class=bp>.</span><span class=mi>2</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span><span class=w> </span><span class=n>use</span><span class=bp>!</span><span class=w> </span><span class=o>(</span><span class=mi>42</span><span class=o>,</span><span class=w> </span><span class=mi>42</span><span class=o>)</span>
</code></pre></div> <p>第二行利用了<code>use!</code>在应用构造函数前尝试用参数进行精炼的事实。还需注意，<code>use</code>/<code>use!</code>默认使用称为<code>use_discharger</code>的策略来关闭目标，因此在此示例中<code>use! 42</code>将关闭目标，因为<code>use_discharger</code>应用<code>rfl</code>，从而解决另一个<code>Nat</code>元变量。</p> <p>这些策略接受一个可选的解除器来处理剩余的显式<code>Prop</code>构造器参数。默认情况下为<code>use (discharger := try with_reducible use_discharger) e₁, e₂, ⋯</code>。要关闭解除器并保留所有目标，使用<code>(discharger := skip)</code>。要允许“重度反身”，使用<code>(discharger := try use_discharger)</code>。</p> <h2 id=use_1>use!<a class=headerlink href=#use_1 title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.«tacticUse!___,,»</code></p> <p><code>use e₁, e₂, ⋯</code>类似于<code>exists</code>，但与<code>exists</code>不同，它等效于应用策略<code>refine ⟨e₁, e₂, ⋯, ?_, ⋯, ?_⟩</code>，带有任意数量的占位符（而非仅一个），然后尝试用可配置的解除器关闭与占位符关联的目标（而非仅<code>try trivial</code>）。</p> <p>示例：</p> <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=bp>∃</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Nat</span><span class=o>,</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span><span class=w> </span><span class=n>use</span><span class=w> </span><span class=mi>42</span>

<span class=kd>example</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=bp>∃</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Nat</span><span class=o>,</span><span class=w> </span><span class=bp>∃</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Nat</span><span class=o>,</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span><span class=w> </span><span class=n>use</span><span class=w> </span><span class=mi>42</span><span class=o>,</span><span class=w> </span><span class=mi>42</span>

<span class=kd>example</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=bp>∃</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=bp>×</span><span class=w> </span><span class=n>String</span><span class=o>,</span><span class=w> </span><span class=n>x</span><span class=bp>.</span><span class=mi>1</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>x</span><span class=bp>.</span><span class=mi>2</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span><span class=w> </span><span class=n>use</span><span class=w> </span><span class=o>(</span><span class=s2>&quot;forty-two&quot;</span><span class=o>,</span><span class=w> </span><span class=s2>&quot;forty-two&quot;</span><span class=o>)</span>
</code></pre></div> <p><code>use! e₁, e₂, ⋯</code>类似，但它会在所有地方应用构造函数，而不仅仅针对构造器最后一个参数对应的目标。这产生了一种效果，即嵌套的构造函数被展开，提供的值被用于构造函数树的叶子和节点。使用<code>use!</code>可以逐个输入每个<code>42</code>：</p> <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=bp>∃</span><span class=w> </span><span class=n>p</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Nat</span><span class=w> </span><span class=bp>×</span><span class=w> </span><span class=n>Nat</span><span class=o>,</span><span class=w> </span><span class=n>p</span><span class=bp>.</span><span class=mi>1</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>p</span><span class=bp>.</span><span class=mi>2</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span><span class=w> </span><span class=n>use</span><span class=bp>!</span><span class=w> </span><span class=mi>42</span><span class=o>,</span><span class=w> </span><span class=mi>42</span>

<span class=kd>example</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=bp>∃</span><span class=w> </span><span class=n>p</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Nat</span><span class=w> </span><span class=bp>×</span><span class=w> </span><span class=n>Nat</span><span class=o>,</span><span class=w> </span><span class=n>p</span><span class=bp>.</span><span class=mi>1</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>p</span><span class=bp>.</span><span class=mi>2</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span><span class=w> </span><span class=n>use</span><span class=bp>!</span><span class=w> </span><span class=o>(</span><span class=mi>42</span><span class=o>,</span><span class=w> </span><span class=mi>42</span><span class=o>)</span>
</code></pre></div> <p>第二行利用了<code>use!</code>在应用构造函数前尝试用参数进行精炼的事实。还需注意，<code>use</code>/<code>use!</code>默认使用称为<code>use_discharger</code>的策略来关闭目标，因此在此示例中<code>use! 42</code>将关闭目标，因为<code>use_discharger</code>应用<code>rfl</code>，从而解决另一个<code>Nat</code>元变量。</p> <p>这些策略接受一个可选的解除器来处理剩余的显式<code>Prop</code>构造器参数。默认情况下为<code>use (discharger := try with_reducible use_discharger) e₁, e₂, ⋯</code>。要关闭解除器并保留所有目标，使用<code>(discharger := skip)</code>。要允许“重度反身”，使用<code>(discharger := try use_discharger)</code>。</p> <h2 id=use_discharger>use_discharger<a class=headerlink href=#use_discharger title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.tacticUse_discharger</code></p> <p>用于<code>use</code>和<code>use!</code>策略的默认解除器。此策略类似于<code>trivial</code>，但不执行<code>contradiction</code>或<code>decide</code>等操作。</p> <h2 id=use_finite_instance>use_finite_instance<a class=headerlink href=#use_finite_instance title="Permanent link">&para;</a></h2> <p>定义于：<code>tacticUse_finite_instance</code></p> <h2 id=valid>valid<a class=headerlink href=#valid title="Permanent link">&para;</a></h2> <p>定义于：<code>CategoryTheory.ComposableArrows.tacticValid</code></p> <p><code>omega</code>的包装器，前置一些快速且有用的尝试</p> <h2 id=volume_tac>volume_tac<a class=headerlink href=#volume_tac title="Permanent link">&para;</a></h2> <p>定义于：<code>MeasureTheory.tacticVolume_tac</code></p> <p>策略<code>exact volume</code>，用于可选（<code>autoParam</code>）参数。</p> <h2 id=wait_for_unblock_async>wait_for_unblock_async<a class=headerlink href=#wait_for_unblock_async title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Server.Test.Cancel.tacticWait_for_unblock_async</code></p> <p>生成一个<code>logSnapshotTask</code>，等待<code>unblock</code>被调用，预计在后续不使此策略失效的文档版本中发生。如果在取消令牌设置前未解除阻塞（即如果策略在之后被失效），则会抱怨。</p> <h2 id=whisker_simps>whisker_simps<a class=headerlink href=#whisker_simps title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.BicategoryCoherence.whisker_simps</code></p> <p>用于将2-态重写为正常形式的Simp引理。</p> <h2 id=whnf>whnf<a class=headerlink href=#whnf title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.tacticWhnf__</code></p> <p><code>whnf at loc</code>将给定位置置于弱头正规形式。此策略也可作为<code>conv</code>模式策略使用。</p> <p>弱头正规形式是指最外层表达式已完全约简，但可能包含未约简的子表达式。</p> <h2 id=with_panel_widgets>with_panel_widgets<a class=headerlink href=#with_panel_widgets title="Permanent link">&para;</a></h2> <p>定义于：<code>ProofWidgets.withPanelWidgetsTacticStx</code></p> <p>在嵌套的策略脚本中显示选定的面板小部件。例如，假设我们编写了一个<code>GeometryDisplay</code>组件，</p> <div class=highlight><pre><span></span><code><span class=kd>by</span><span class=w> </span><span class=n>with_panel_widgets</span><span class=w> </span><span class=o>[</span><span class=n>GeometryDisplay</span><span class=o>]</span>
<span class=w>  </span><span class=n>simp</span>
<span class=w>  </span><span class=n>rfl</span>
</code></pre></div> <p>将在整个证明过程中显示几何显示与通常的策略状态。</p> <h2 id=with_reducible>with_reducible<a class=headerlink href=#with_reducible title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.withReducible</code></p> <p><code>with_reducible tacs</code> 使用可约简的透明度设置执行 <code>tacs</code>。在此设置下，仅展开被标记为 <code>[reducible]</code> 的定义。</p> <h2 id=with_reducible_and_instances>with_reducible_and_instances<a class=headerlink href=#with_reducible_and_instances title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.withReducibleAndInstances</code></p> <p><code>with_reducible_and_instances tacs</code> 使用 <code>.instances</code> 透明度设置执行 <code>tacs</code>。在此设置下，展开被标记为 <code>[reducible]</code> 的定义或类型类实例。</p> <h2 id=with_unfolding_all>with_unfolding_all<a class=headerlink href=#with_unfolding_all title="Permanent link">&para;</a></h2> <p>定义于：<code>Lean.Parser.Tactic.withUnfoldingAll</code></p> <p><code>with_unfolding_all tacs</code> 使用 <code>.all</code> 透明度设置执行 <code>tacs</code>。在此设置下，展开所有非不透明的定义。</p> <h2 id=witt_truncatefun_tac>witt_truncateFun_tac<a class=headerlink href=#witt_truncatefun_tac title="Permanent link">&para;</a></h2> <p>定义于：<code>witt_truncateFun_tac</code></p> <p>用于证明 <code>truncateFun</code> 尊重环操作的宏策略。</p> <h2 id=wlog>wlog<a class=headerlink href=#wlog title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.wlog</code></p> <p><code>wlog h : P</code> 将在主目标中添加假设 <code>h : P</code>，并添加一个需证明当 <code>h : ¬ P</code> 时的情况可简化为 <code>P</code> 成立的边目标（通常通过对称性）。</p> <p>边目标将位于目标栈顶部。在此边目标中，将有两个额外假设： - <code>h : ¬ P</code>：假设 <code>P</code> 不成立 - <code>this</code>：表示在原上下文中 <code>P</code> 足以证明目标。默认使用名称 <code>this</code>，但可通过添加 <code>with H</code> 指定名称：<code>wlog h : P with H</code>。</p> <p>通常，结合 <code>wlog h : P generalizing x y</code> 使用以在创建新目标前恢复上下文的某些部分，便于 <code>wlog</code> 声明 <code>this</code> 以不同顺序应用于 <code>x</code> 和 <code>y</code>（利用对称性，典型用例）。</p> <p>默认恢复整个上下文。</p> <h2 id=zify>zify<a class=headerlink href=#zify title="Permanent link">&para;</a></h2> <p>定义于：<code>Mathlib.Tactic.Zify.zify</code></p> <p><code>zify</code> 策略用于将命题从 <code>Nat</code> 转换到 <code>Int</code>。由于 <code>Int</code> 具有良好减法特性，此举常有益。 <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=n>z</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Nat</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=bp>¬</span><span class=w> </span><span class=n>x</span><span class=bp>*</span><span class=n>y</span><span class=bp>*</span><span class=n>z</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=mi>0</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>3</span><span class=bp>*</span><span class=n>b</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>zify</span>
<span class=w>  </span><span class=n>zify</span><span class=w> </span><span class=n>at</span><span class=w> </span><span class=n>h</span>
<span class=w>  </span><span class=c>/-</span>
<span class=cm>  h : ¬↑x * ↑y * ↑z &lt; 0</span>
<span class=cm>  ⊢ ↑c &lt; ↑a + 3 * ↑b</span>
<span class=cm>  -/</span>
</code></pre></div> <code>zify</code> 可接受额外引理以辅助化简。这在存在自然数减法时尤为有用：传递 <code>≤</code> 参数将使 <code>push_cast</code> 完成更多工作。 <div class=highlight><pre><span></span><code><span class=kd>example</span><span class=w> </span><span class=o>(</span><span class=n>a</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Nat</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=bp>-</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=bp>&lt;</span><span class=w> </span><span class=n>c</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>hab</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=bp>≤</span><span class=w> </span><span class=n>a</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>false</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span>
<span class=w>  </span><span class=n>zify</span><span class=w> </span><span class=o>[</span><span class=n>hab</span><span class=o>]</span><span class=w> </span><span class=n>at</span><span class=w> </span><span class=n>h</span>
<span class=w>  </span><span class=c>/-</span><span class=cm> h : ↑a - ↑b &lt; ↑c -/</span>
</code></pre></div> <code>zify</code> 利用 <code>@[zify_simps]</code> 属性转移命题，并通过 <code>push_cast</code> 策略简化 <code>Int</code> 表达式。某种意义上，<code>zify</code> 与 <code>lift</code> 策略互为对偶。<code>lift (z : Int) to Nat</code> 将整数 <code>z</code>（超类型）的类型更改为 <code>Nat</code>（子类型），需证明 <code>z ≥ 0</code>；关于 <code>z</code> 的命题仍处于 <code>Int</code> 层面。<code>zify</code> 则将关于 <code>Nat</code>（子类型）的命题转换为关于 <code>Int</code>（超类型）的命题，且不改变任何变量的类型。</p> <p>语法 ... [Lean.Parser.Tactic.nestedTactic]</p> <p>语法 ... [Lean.Parser.Tactic.unknown]</p> <p>语法 ... [Lean.cdot] <code>· tac</code> 聚焦主目标并尝试用 <code>tac</code> 解决，否则失败。</p> </article> </div> <script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script> </div> </main> <footer class=md-footer> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-copyright> Made with <a href=https://squidfunk.github.io/mkdocs-material/ target=_blank rel=noopener> Material for MkDocs </a> </div> </div> </div> </footer> </div> <div class=md-dialog data-md-component=dialog> <div class="md-dialog__inner md-typeset"></div> </div> <script id=__config type=application/json>{"base": "../..", "features": ["navigation.tabs", "navigation.sections", "navigation.instant", "search.highlight", "search.share", "content.code.copy", "content.code.annotate"], "search": "../../assets/javascripts/workers/search.973d3a69.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": {"alias": true, "default": "latest", "provider": "mike"}}</script> <script src=../../assets/javascripts/bundle.f55a23d4.min.js></script> <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> </body> </html>