<!doctype html><html lang=en class=no-js> <head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link href=https://leanprover.cn/tool/repl/ rel=canonical><link rel=icon href=../../assets/images/favicon.png><meta name=generator content="mkdocs-1.6.1, mkdocs-material-9.6.20"><title>Lean4 REPL - Lean Prover 中文文档</title><link rel=stylesheet href=../../assets/stylesheets/main.e53b48f4.min.css><link rel=stylesheet href=../../assets/stylesheets/palette.06af60db.min.css><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback"><style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style><link rel=stylesheet href=../../assets/css/admonition-custom.css><link rel=stylesheet href=../../assets/css/custom.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css><script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script></head> <body dir=ltr data-md-color-scheme=default data-md-color-primary=green data-md-color-accent=light-green> <input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off> <input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off> <label class=md-overlay for=__drawer></label> <div data-md-component=skip> <a href=#lean4-repl class=md-skip> Skip to content </a> </div> <div data-md-component=announce> </div> <div data-md-color-scheme=default data-md-component=outdated hidden> </div> <header class=md-header data-md-component=header> <nav class="md-header__inner md-grid" aria-label=Header> <a href=../.. title="Lean Prover 中文文档" class="md-header__button md-logo" aria-label="Lean Prover 中文文档" data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg> </a> <label class="md-header__button md-icon" for=__drawer> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg> </label> <div class=md-header__title data-md-component=header-title> <div class=md-header__ellipsis> <div class=md-header__topic> <span class=md-ellipsis> Lean Prover 中文文档 </span> </div> <div class=md-header__topic data-md-component=header-topic> <span class=md-ellipsis> Lean4 REPL </span> </div> </div> </div> <label class="md-header__button md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg> </label> <div class=md-search data-md-component=search role=dialog> <label class=md-search__overlay for=__search></label> <div class=md-search__inner role=search> <form class=md-search__form name=search> <input type=text class=md-search__input name=query aria-label=Search placeholder=Search autocapitalize=off autocorrect=off autocomplete=off spellcheck=false data-md-component=search-query required> <label class="md-search__icon md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg> </label> <nav class=md-search__options aria-label=Search> <a href=javascript:void(0) class="md-search__icon md-icon" title=Share aria-label=Share data-clipboard data-clipboard-text data-md-component=search-share tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.15c-.05.21-.08.43-.08.66 0 1.61 1.31 2.91 2.92 2.91s2.92-1.3 2.92-2.91A2.92 2.92 0 0 0 18 16.08"/></svg> </a> <button type=reset class="md-search__icon md-icon" title=Clear aria-label=Clear tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg> </button> </nav> </form> <div class=md-search__output> <div class=md-search__scrollwrap tabindex=0 data-md-scrollfix> <div class=md-search-result data-md-component=search-result> <div class=md-search-result__meta> Initializing search </div> <ol class=md-search-result__list role=presentation></ol> </div> </div> </div> </div> </div> <div class=md-header__source> <a href=https://github.com/Lean-zh/Lean-zh.github.io title="Go to repository" class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><!-- Font Awesome Free 7.0.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M439.6 236.1 244 40.5c-5.4-5.5-12.8-8.5-20.4-8.5s-15 3-20.4 8.4L162.5 81l51.5 51.5c27.1-9.1 52.7 16.8 43.4 43.7l49.7 49.7c34.2-11.8 61.2 31 35.5 56.7-26.5 26.5-70.2-2.9-56-37.3L240.3 199v121.9c25.3 12.5 22.3 41.8 9.1 55-6.4 6.4-15.2 10.1-24.3 10.1s-17.8-3.6-24.3-10.1c-17.6-17.6-11.1-46.9 11.2-56v-123c-20.8-8.5-24.6-30.7-18.6-45L142.6 101 8.5 235.1C3 240.6 0 247.9 0 255.5s3 15 8.5 20.4l195.6 195.7c5.4 5.4 12.7 8.4 20.4 8.4s15-3 20.4-8.4l194.7-194.7c5.4-5.4 8.4-12.8 8.4-20.4s-3-15-8.4-20.4"/></svg> </div> <div class=md-source__repository> Lean-zh </div> </a> </div> </nav> </header> <div class=md-container data-md-component=container> <nav class=md-tabs aria-label=Tabs data-md-component=tabs> <div class=md-grid> <ul class=md-tabs__list> <li class=md-tabs__item> <a href=../.. class=md-tabs__link> 主页 </a> </li> <li class=md-tabs__item> <a href=../../projects/verso/ class=md-tabs__link> 项目教程 </a> </li> </ul> </div> </nav> <main class=md-main data-md-component=main> <div class="md-main__inner md-grid"> <div class="md-sidebar md-sidebar--primary" data-md-component=sidebar data-md-type=navigation> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--primary md-nav--lifted" aria-label=Navigation data-md-level=0> <label class=md-nav__title for=__drawer> <a href=../.. title="Lean Prover 中文文档" class="md-nav__button md-logo" aria-label="Lean Prover 中文文档" data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg> </a> Lean Prover 中文文档 </label> <div class=md-nav__source> <a href=https://github.com/Lean-zh/Lean-zh.github.io title="Go to repository" class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><!-- Font Awesome Free 7.0.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M439.6 236.1 244 40.5c-5.4-5.5-12.8-8.5-20.4-8.5s-15 3-20.4 8.4L162.5 81l51.5 51.5c27.1-9.1 52.7 16.8 43.4 43.7l49.7 49.7c34.2-11.8 61.2 31 35.5 56.7-26.5 26.5-70.2-2.9-56-37.3L240.3 199v121.9c25.3 12.5 22.3 41.8 9.1 55-6.4 6.4-15.2 10.1-24.3 10.1s-17.8-3.6-24.3-10.1c-17.6-17.6-11.1-46.9 11.2-56v-123c-20.8-8.5-24.6-30.7-18.6-45L142.6 101 8.5 235.1C3 240.6 0 247.9 0 255.5s3 15 8.5 20.4l195.6 195.7c5.4 5.4 12.7 8.4 20.4 8.4s15-3 20.4-8.4l194.7-194.7c5.4-5.4 8.4-12.8 8.4-20.4s-3-15-8.4-20.4"/></svg> </div> <div class=md-source__repository> Lean-zh </div> </a> </div> <ul class=md-nav__list data-md-scrollfix> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_1> <label class=md-nav__link for=__nav_1 id=__nav_1_label tabindex=0> <span class=md-ellipsis> 主页 </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_1_label aria-expanded=false> <label class=md-nav__title for=__nav_1> <span class="md-nav__icon md-icon"></span> 主页 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../.. class=md-nav__link> <span class=md-ellipsis> Lean-zh </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_2> <label class=md-nav__link for=__nav_2 id=__nav_2_label tabindex=0> <span class=md-ellipsis> 项目教程 </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_2_label aria-expanded=false> <label class=md-nav__title for=__nav_2> <span class="md-nav__icon md-icon"></span> 项目教程 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../projects/verso/ class=md-nav__link> <span class=md-ellipsis> Verso 教程 </span> </a> </li> </ul> </nav> </li> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component=sidebar data-md-type=toc> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--secondary" aria-label="Table of contents"> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> Table of contents </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#_1 class=md-nav__link> <span class=md-ellipsis> 项目概要 </span> </a> <nav class=md-nav aria-label=项目概要> <ul class=md-nav__list> <li class=md-nav__item> <a href=#command-mode class=md-nav__link> <span class=md-ellipsis> 命令模式 (Command Mode) </span> </a> </li> <li class=md-nav__item> <a href=#file-mode class=md-nav__link> <span class=md-ellipsis> 文件模式 (File Mode) </span> </a> </li> <li class=md-nav__item> <a href=#tactic-mode class=md-nav__link> <span class=md-ellipsis> 策略模式 (Tactic Mode) </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#_2 class=md-nav__link> <span class=md-ellipsis> 安装与基本使用 </span> </a> <nav class=md-nav aria-label=安装与基本使用> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_3 class=md-nav__link> <span class=md-ellipsis> 安装 </span> </a> </li> <li class=md-nav__item> <a href=#_4 class=md-nav__link> <span class=md-ellipsis> 基本使用 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#repl class=md-nav__link> <span class=md-ellipsis> REPL 命令模式 </span> </a> <nav class=md-nav aria-label="REPL 命令模式"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_5 class=md-nav__link> <span class=md-ellipsis> 状态跟踪 </span> </a> </li> <li class=md-nav__item> <a href=#_6 class=md-nav__link> <span class=md-ellipsis> 示例解析 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#repl_1 class=md-nav__link> <span class=md-ellipsis> REPL 策略模式 </span> </a> <nav class=md-nav aria-label="REPL 策略模式"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_7 class=md-nav__link> <span class=md-ellipsis> 示例解析 </span> </a> </li> <li class=md-nav__item> <a href=#have class=md-nav__link> <span class=md-ellipsis> 复杂示例：使用 have 策略 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#repl_2 class=md-nav__link> <span class=md-ellipsis> REPL 文件模式 </span> </a> <nav class=md-nav aria-label="REPL 文件模式"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_8 class=md-nav__link> <span class=md-ellipsis> 用法示例 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#pickle class=md-nav__link> <span class=md-ellipsis> Pickle 特性 </span> </a> <nav class=md-nav aria-label="Pickle 特性"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#pickle_1 class=md-nav__link> <span class=md-ellipsis> Pickle 的基本操作 </span> </a> </li> <li class=md-nav__item> <a href=#_9 class=md-nav__link> <span class=md-ellipsis> 示例分析 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#mathlib class=md-nav__link> <span class=md-ellipsis> 配置 Mathlib 依赖 </span> </a> </li> <li class=md-nav__item> <a href=#_10 class=md-nav__link> <span class=md-ellipsis> 更多示例 </span> </a> <nav class=md-nav aria-label=更多示例> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_11 class=md-nav__link> <span class=md-ellipsis> 基础示例：检查变量定义 </span> </a> </li> <li class=md-nav__item> <a href=#by_cases class=md-nav__link> <span class=md-ellipsis> 策略示例：使用 by_cases 分类讨论 </span> </a> </li> <li class=md-nav__item> <a href=#_12 class=md-nav__link> <span class=md-ellipsis> 变量声明与复杂定理 </span> </a> </li> <li class=md-nav__item> <a href=#_13 class=md-nav__link> <span class=md-ellipsis> 策略示例：使用各种策略组合 </span> </a> </li> <li class=md-nav__item> <a href=#have_1 class=md-nav__link> <span class=md-ellipsis> 策略示例：使用 have 引入中间变量 </span> </a> </li> <li class=md-nav__item> <a href=#lake class=md-nav__link> <span class=md-ellipsis> 包管理示例：导入 Lake </span> </a> </li> <li class=md-nav__item> <a href=#sorry class=md-nav__link> <span class=md-ellipsis> 简单示例：基础定义中的 sorry </span> </a> </li> <li class=md-nav__item> <a href=#_14 class=md-nav__link> <span class=md-ellipsis> 策略示例：构造函数应用 </span> </a> </li> <li class=md-nav__item> <a href=#have_2 class=md-nav__link> <span class=md-ellipsis> 策略示例：have 引入中间命题 </span> </a> </li> <li class=md-nav__item> <a href=#rfl class=md-nav__link> <span class=md-ellipsis> 基础示例：使用 rfl 检查相等性 </span> </a> </li> <li class=md-nav__item> <a href=#_15 class=md-nav__link> <span class=md-ellipsis> 示例：使用下划线占位符 </span> </a> </li> <li class=md-nav__item> <a href=#_16 class=md-nav__link> <span class=md-ellipsis> 基础示例：定义数值类型 </span> </a> </li> <li class=md-nav__item> <a href=#_17 class=md-nav__link> <span class=md-ellipsis> 打印示例：查看定义和设置选项 </span> </a> </li> <li class=md-nav__item> <a href=#natabs class=md-nav__link> <span class=md-ellipsis> 策略示例：使用 natAbs 构造自然数 </span> </a> </li> <li class=md-nav__item> <a href=#_18 class=md-nav__link> <span class=md-ellipsis> 错误示例：错误的构造器使用 </span> </a> </li> <li class=md-nav__item> <a href=#_19 class=md-nav__link> <span class=md-ellipsis> 策略示例：错误处理演示 </span> </a> </li> <li class=md-nav__item> <a href=#sorry_1 class=md-nav__link> <span class=md-ellipsis> 示例：多个 sorry 的处理 </span> </a> </li> <li class=md-nav__item> <a href=#have_3 class=md-nav__link> <span class=md-ellipsis> 策略示例：使用 have 引入中间结论 </span> </a> </li> <li class=md-nav__item> <a href=#_20 class=md-nav__link> <span class=md-ellipsis> 策略示例：简单值定义 </span> </a> </li> <li class=md-nav__item> <a href=#_21 class=md-nav__link> <span class=md-ellipsis> 文件模式示例：读取文件并处理错误 </span> </a> </li> <li class=md-nav__item> <a href=#trace-simp class=md-nav__link> <span class=md-ellipsis> 调试示例：使用 trace 和 simp </span> </a> </li> <li class=md-nav__item> <a href=#sorry_2 class=md-nav__link> <span class=md-ellipsis> 策略示例：直接使用 sorry </span> </a> </li> <li class=md-nav__item> <a href=#calc class=md-nav__link> <span class=md-ellipsis> 策略示例：使用 calc（计算块） </span> </a> </li> <li class=md-nav__item> <a href=#_22 class=md-nav__link> <span class=md-ellipsis> 错误处理示例：策略名拼写错误 </span> </a> </li> <li class=md-nav__item> <a href=#_23 class=md-nav__link> <span class=md-ellipsis> 示例：多个定理的连续定义 </span> </a> </li> <li class=md-nav__item> <a href=#sorry_3 class=md-nav__link> <span class=md-ellipsis> 示例：sorry 占位符的基本使用 </span> </a> </li> <li class=md-nav__item> <a href=#_24 class=md-nav__link> <span class=md-ellipsis> 策略示例：定义自然数值 </span> </a> </li> <li class=md-nav__item> <a href=#have_4 class=md-nav__link> <span class=md-ellipsis> 策略示例：使用 have 引入中间结论 </span> </a> </li> <li class=md-nav__item> <a href=#_25 class=md-nav__link> <span class=md-ellipsis> 策略示例：基本策略组合 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#pickle_2 class=md-nav__link> <span class=md-ellipsis> Pickle 模式 </span> </a> <nav class=md-nav aria-label="Pickle 模式"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#pickle_3 class=md-nav__link> <span class=md-ellipsis> Pickle 示例：保存和加载环境 </span> </a> </li> <li class=md-nav__item> <a href=#pickle_4 class=md-nav__link> <span class=md-ellipsis> Pickle 示例：保存和加载环境 </span> </a> </li> <li class=md-nav__item> <a href=#pickle_5 class=md-nav__link> <span class=md-ellipsis> Pickle 示例：保存和加载证明状态 </span> </a> </li> <li class=md-nav__item> <a href=#pickle_6 class=md-nav__link> <span class=md-ellipsis> Pickle 示例：加载并继续证明 </span> </a> </li> <li class=md-nav__item> <a href=#pickle-open class=md-nav__link> <span class=md-ellipsis> Pickle 示例：使用 open 导入定义 </span> </a> </li> <li class=md-nav__item> <a href=#pickle_7 class=md-nav__link> <span class=md-ellipsis> Pickle 示例：加载环境变量 </span> </a> </li> <li class=md-nav__item> <a href=#unsafe class=md-nav__link> <span class=md-ellipsis> 导入模块和使用 unsafe 示例 </span> </a> </li> <li class=md-nav__item> <a href=#pickle-unsafe class=md-nav__link> <span class=md-ellipsis> Pickle 示例：加载环境并定义 unsafe 示例 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#mathlib_1 class=md-nav__link> <span class=md-ellipsis> Mathlib 示例 </span> </a> <nav class=md-nav aria-label="Mathlib 示例"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#pickle_8 class=md-nav__link> <span class=md-ellipsis> 数学定理示例：代数运算与 pickle </span> </a> </li> <li class=md-nav__item> <a href=#pickle_9 class=md-nav__link> <span class=md-ellipsis> Pickle 示例：加载已保存的证明状态 </span> </a> </li> <li class=md-nav__item> <a href=#_26 class=md-nav__link> <span class=md-ellipsis> 复杂示例：实数分析中的指数函数估计 </span> </a> </li> <li class=md-nav__item> <a href=#_27 class=md-nav__link> <span class=md-ellipsis> 策略示例：数学归纳法 </span> </a> </li> <li class=md-nav__item> <a href=#_28 class=md-nav__link> <span class=md-ellipsis> 数论定理示例：使用内置策略 </span> </a> </li> <li class=md-nav__item> <a href=#_29 class=md-nav__link> <span class=md-ellipsis> 示例：归纳法框架 </span> </a> </li> <li class=md-nav__item> <a href=#simpa class=md-nav__link> <span class=md-ellipsis> 策略示例：使用 simpa 策略 </span> </a> </li> <li class=md-nav__item> <a href=#_30 class=md-nav__link> <span class=md-ellipsis> 策略示例：使用归纳法证明 </span> </a> </li> <li class=md-nav__item> <a href=#_31 class=md-nav__link> <span class=md-ellipsis> 数学示例：实数绝对值的讨论 </span> </a> </li> <li class=md-nav__item> <a href=#_32 class=md-nav__link> <span class=md-ellipsis> 策略示例：使用归纳法证明 </span> </a> </li> <li class=md-nav__item> <a href=#_33 class=md-nav__link> <span class=md-ellipsis> 导入示例：保存数学库依赖环境 </span> </a> </li> <li class=md-nav__item> <a href=#_34 class=md-nav__link> <span class=md-ellipsis> 数学证明示例：计算复合函数 </span> </a> </li> <li class=md-nav__item> <a href=#_35 class=md-nav__link> <span class=md-ellipsis> 示例：使用已保存的环境状态 </span> </a> </li> <li class=md-nav__item> <a href=#exact class=md-nav__link> <span class=md-ellipsis> exact? 策略示例：自动推导 </span> </a> </li> </ul> </nav> </li> </ul> </nav> </div> </div> </div> <div class=md-content data-md-component=content> <article class="md-content__inner md-typeset"> <h1 id=lean4-repl>Lean4 REPL<a class=headerlink href=#lean4-repl title="Permanent link">&para;</a></h1> <h2 id=_1>项目概要<a class=headerlink href=#_1 title="Permanent link">&para;</a></h2> <p>REPL (Read-Eval-Print Loop) 是一个交互式编程环境，允许用户输入命令，执行并查看结果。Lean 4 REPL 基于 JSON 通信，支持三种工作模式。</p> <h3 id=command-mode>命令模式 (Command Mode)<a class=headerlink href=#command-mode title="Permanent link">&para;</a></h3> <p>在命令模式下，可以发送完整的 Lean 命令（如声明、定义等）到 REPL，比如：</p> <div class=highlight><pre><span></span><code><span class=p>{</span><span class=w> </span><span class=nt>&quot;cmd&quot;</span><span class=p>:</span><span class=w> </span><span class=s2>&quot;def f := 2&quot;</span><span class=w> </span><span class=p>}</span>
</code></pre></div> <h3 id=file-mode>文件模式 (File Mode)<a class=headerlink href=#file-mode title="Permanent link">&para;</a></h3> <p>文件模式是命令模式的简单封装，允许直接读取和执行整个 Lean 文件的内容。例如：</p> <div class=highlight><pre><span></span><code><span class=p>{</span><span class=w> </span><span class=nt>&quot;path&quot;</span><span class=p>:</span><span class=w> </span><span class=s2>&quot;test/file.lean&quot;</span><span class=p>,</span><span class=w> </span><span class=nt>&quot;allTactics&quot;</span><span class=p>:</span><span class=w> </span><span class=kc>true</span><span class=w> </span><span class=p>}</span>
</code></pre></div> <h3 id=tactic-mode>策略模式 (Tactic Mode)<a class=headerlink href=#tactic-mode title="Permanent link">&para;</a></h3> <p>策略模式允许使用 Lean 的证明策略（tactics）来交互式地构建证明。这个模式通常从一个包含 <code>sorry</code> 的命令开始，然后逐步完成证明。</p> <h2 id=_2>安装与基本使用<a class=headerlink href=#_2 title="Permanent link">&para;</a></h2> <h3 id=_3>安装<a class=headerlink href=#_3 title="Permanent link">&para;</a></h3> <p>首先，克隆并构建 REPL 项目：</p> <div class=highlight><pre><span></span><code>git<span class=w> </span>clone<span class=w> </span>https://github.com/leanprover-community/repl
<span class=nb>cd</span><span class=w> </span>repl
lake<span class=w> </span>update<span class=w> </span>-R<span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span>lake<span class=w> </span>build
</code></pre></div> <p><strong>特别注意</strong>，REPL 的版本需要与目标 Lean 代码的版本保持一致。</p> <h3 id=_4>基本使用<a class=headerlink href=#_4 title="Permanent link">&para;</a></h3> <p>进入仓库，通过 <code>lake exe repl</code> 启动交互式终端，输入 JSON 块，获取相应的输出。</p> <p>此外，也可以通过标准输入输出流进行通信，比如：</p> <div class=highlight><pre><span></span><code><span class=nb>echo</span><span class=w> </span><span class=s1>&#39;{ &quot;cmd&quot;: &quot;def f := 2&quot; }&#39;</span><span class=w> </span><span class=p>|</span><span class=w> </span>lake<span class=w> </span>exe<span class=w> </span>repl
</code></pre></div> <h2 id=repl>REPL 命令模式<a class=headerlink href=#repl title="Permanent link">&para;</a></h2> <p>下边，我们详细介绍 REPL 的三种模式，以及 Pickle 特性。先从最基础的 <strong>命令模式</strong> 开始。</p> <h3 id=_5>状态跟踪<a class=headerlink href=#_5 title="Permanent link">&para;</a></h3> <p>REPL 的命令模式通过 <code>env</code> 字段跟踪环境状态，每次执行 <code>cmd</code> 命令后会返回一个新的环境编号。这种机制有很多好处：</p> <ol> <li><strong>状态追踪</strong>：允许在一个交互终端中启用多个环境，比如 <code>import</code> 不同的模块，每个命令执行后都会生成新的环境编号</li> <li><strong>环境选择</strong>：允许通过指定 <code>env</code> 值回溯到之前的状态，在该环境的基础上执行新命令</li> <li><strong>环境隔离</strong>：不同环境的变量相互独立</li> </ol> <h3 id=_6>示例解析<a class=headerlink href=#_6 title="Permanent link">&para;</a></h3> <p>我们通过一个具体示例来理解命令模式的工作方式：</p> <div class=highlight><pre><span></span><code><span class=c1># 命令序列</span>
<span class=o>{</span><span class=s2>&quot;cmd&quot;</span>:<span class=w> </span><span class=s2>&quot;def f1 := 37&quot;</span><span class=o>}</span><span class=w>                 </span><span class=c1># 命令 1</span>
<span class=o>{</span><span class=s2>&quot;cmd&quot;</span>:<span class=w> </span><span class=s2>&quot;def f2 := 37&quot;</span>,<span class=w> </span><span class=s2>&quot;env&quot;</span>:0<span class=o>}</span><span class=w>        </span><span class=c1># 命令 2</span>
<span class=o>{</span><span class=s2>&quot;cmd&quot;</span>:<span class=w> </span><span class=s2>&quot;def f3 := f1 + f2&quot;</span>,<span class=w> </span><span class=s2>&quot;env&quot;</span>:<span class=w> </span><span class=m>1</span><span class=w> </span><span class=o>}</span><span class=w> </span><span class=c1># 命令 3</span>
<span class=o>{</span><span class=s2>&quot;cmd&quot;</span>:<span class=w> </span><span class=s2>&quot;def f3 := f1 + f2&quot;</span>,<span class=w> </span><span class=s2>&quot;env&quot;</span>:<span class=w> </span><span class=m>1</span><span class=w> </span><span class=o>}</span><span class=w> </span><span class=c1># 命令 4</span>
<span class=o>{</span><span class=s2>&quot;cmd&quot;</span>:<span class=w> </span><span class=s2>&quot;def f3 := f1 + f2&quot;</span>,<span class=w> </span><span class=s2>&quot;env&quot;</span>:<span class=w> </span><span class=m>2</span><span class=w> </span><span class=o>}</span><span class=w> </span><span class=c1># 命令 5</span>
</code></pre></div> <p><strong>环境变化过程</strong>：</p> <ol> <li>定义 <code>f1 := 37</code>，创建新环境 env 0</li> <li>基于 env 0 添加定义 <code>f2 := 37</code>，并创建新环境 env 1</li> <li>基于 env 1 添加定义 <code>f3 := f1 + f2</code>，并创建新环境 env 2</li> <li>基于 env 1 执行相同操作，并创建新环境 env 3</li> <li>基于 env 2 重新定义 <code>f3</code>，报错：<code>'f3' has already been declared</code>，并创建新环境 env 4</li> </ol> <h2 id=repl_1>REPL 策略模式<a class=headerlink href=#repl_1 title="Permanent link">&para;</a></h2> <p>策略模式（Tactic Mode）是 REPL 的核心功能，用于交互式证明构建。</p> <p>策略模式有以下特性：</p> <ol> <li><strong>状态创建</strong>：使用 <code>sorry</code> 创建证明占位符，</li> <li><strong>状态追踪</strong>：通过 <code>proofState</code> 标识状态索引，每个 <code>sorry</code> 按顺序生成 <code>proofState</code>，策略作用也会产生新的证明状态</li> <li><strong>多目标处理</strong>：支持 pick 指定目标来进行下一步证明</li> <li><strong>灵活性</strong>：支持各种证明策略，包括 <code>have, calc</code> 等，且允许分步构建复杂证明</li> </ol> <h3 id=_7>示例解析<a class=headerlink href=#_7 title="Permanent link">&para;</a></h3> <p>为展示方便，我们将输出结果拼接到对应输入行后边：</p> <div class=highlight><pre><span></span><code><span class=c1># 步骤1：创建定理</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span> <span class=p>:</span> <span class=s2>&quot;def f (x : Unit) : Nat := by sorry&quot;</span><span class=p>}</span>
<span class=c1># 返回 proofState 0，并得到 env 0</span>
<span class=p>{</span><span class=s2>&quot;sorries&quot;</span><span class=p>:</span>
 <span class=p>[{</span><span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>,</span>
   <span class=s2>&quot;pos&quot;</span><span class=p>:</span> <span class=p>{</span><span class=s2>&quot;line&quot;</span><span class=p>:</span> <span class=mi>1</span><span class=p>,</span> <span class=s2>&quot;column&quot;</span><span class=p>:</span> <span class=mi>29</span><span class=p>},</span>
   <span class=s2>&quot;goal&quot;</span><span class=p>:</span> <span class=s2>&quot;x : Unit</span><span class=se>\n</span><span class=s2>⊢ Nat&quot;</span><span class=p>,</span>
   <span class=s2>&quot;endPos&quot;</span><span class=p>:</span> <span class=p>{</span><span class=s2>&quot;line&quot;</span><span class=p>:</span> <span class=mi>1</span><span class=p>,</span> <span class=s2>&quot;column&quot;</span><span class=p>:</span> <span class=mi>34</span><span class=p>}}],</span>
 <span class=s2>&quot;messages&quot;</span><span class=p>:</span>
 <span class=p>[{</span><span class=s2>&quot;severity&quot;</span><span class=p>:</span> <span class=s2>&quot;warning&quot;</span><span class=p>,</span>
   <span class=s2>&quot;pos&quot;</span><span class=p>:</span> <span class=p>{</span><span class=s2>&quot;line&quot;</span><span class=p>:</span> <span class=mi>1</span><span class=p>,</span> <span class=s2>&quot;column&quot;</span><span class=p>:</span> <span class=mi>4</span><span class=p>},</span>
   <span class=s2>&quot;endPos&quot;</span><span class=p>:</span> <span class=p>{</span><span class=s2>&quot;line&quot;</span><span class=p>:</span> <span class=mi>1</span><span class=p>,</span> <span class=s2>&quot;column&quot;</span><span class=p>:</span> <span class=mi>5</span><span class=p>},</span>
   <span class=s2>&quot;data&quot;</span><span class=p>:</span> <span class=s2>&quot;declaration uses &#39;sorry&#39;&quot;</span><span class=p>}],</span>
 <span class=s2>&quot;env&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>}</span>

<span class=c1># 步骤2：应用第一个策略</span>
<span class=p>{</span><span class=s2>&quot;tactic&quot;</span><span class=p>:</span> <span class=s2>&quot;apply Int.natAbs&quot;</span><span class=p>,</span> <span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>}</span>
<span class=c1># 生成新的证明状态 proofState 1</span>
<span class=p>{</span><span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>1</span><span class=p>,</span> <span class=s2>&quot;goals&quot;</span><span class=p>:</span> <span class=p>[</span><span class=s2>&quot;x : Unit</span><span class=se>\n</span><span class=s2>⊢ Int&quot;</span><span class=p>]}</span>

<span class=c1># 步骤3：完成证明</span>
<span class=p>{</span><span class=s2>&quot;tactic&quot;</span><span class=p>:</span> <span class=s2>&quot;exact 0&quot;</span><span class=p>,</span> <span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>1</span><span class=p>}</span>
<span class=c1># 空目标列表表示证明完成</span>
<span class=p>{</span><span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>2</span><span class=p>,</span> <span class=s2>&quot;goals&quot;</span><span class=p>:</span> <span class=p>[]}</span>
</code></pre></div> <h3 id=have>复杂示例：使用 have 策略<a class=headerlink href=#have title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=c1># 创建带有中间步骤的定理</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;theorem foo (x : Int) : x = x := by</span><span class=se>\n</span><span class=s2>  have h : x = 1 := by sorry&quot;</span><span class=p>}</span>

<span class=c1># 结果：</span>
<span class=c1># 1. 抛出错误：只放了一处 sorry，存在未解决的目标</span>
<span class=c1># 2. 返回 proofState 0，由 have 的 sorry 产生</span>
<span class=p>{</span><span class=s2>&quot;sorries&quot;</span><span class=p>:</span>
 <span class=p>[{</span><span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>,</span>
   <span class=s2>&quot;pos&quot;</span><span class=p>:</span> <span class=p>{</span><span class=s2>&quot;line&quot;</span><span class=p>:</span> <span class=mi>2</span><span class=p>,</span> <span class=s2>&quot;column&quot;</span><span class=p>:</span> <span class=mi>23</span><span class=p>},</span>
   <span class=s2>&quot;goal&quot;</span><span class=p>:</span> <span class=s2>&quot;x : Int</span><span class=se>\n</span><span class=s2>⊢ x = 1&quot;</span><span class=p>,</span>
   <span class=s2>&quot;endPos&quot;</span><span class=p>:</span> <span class=p>{</span><span class=s2>&quot;line&quot;</span><span class=p>:</span> <span class=mi>2</span><span class=p>,</span> <span class=s2>&quot;column&quot;</span><span class=p>:</span> <span class=mi>28</span><span class=p>}}],</span>
 <span class=s2>&quot;messages&quot;</span><span class=p>:</span>
 <span class=p>[{</span><span class=s2>&quot;severity&quot;</span><span class=p>:</span> <span class=s2>&quot;error&quot;</span><span class=p>,</span>
   <span class=s2>&quot;pos&quot;</span><span class=p>:</span> <span class=p>{</span><span class=s2>&quot;line&quot;</span><span class=p>:</span> <span class=mi>1</span><span class=p>,</span> <span class=s2>&quot;column&quot;</span><span class=p>:</span> <span class=mi>33</span><span class=p>},</span>
   <span class=s2>&quot;endPos&quot;</span><span class=p>:</span> <span class=p>{</span><span class=s2>&quot;line&quot;</span><span class=p>:</span> <span class=mi>2</span><span class=p>,</span> <span class=s2>&quot;column&quot;</span><span class=p>:</span> <span class=mi>28</span><span class=p>},</span>
   <span class=s2>&quot;data&quot;</span><span class=p>:</span> <span class=s2>&quot;unsolved goals</span><span class=se>\n</span><span class=s2>x : Int</span><span class=se>\n</span><span class=s2>h : x = 1</span><span class=se>\n</span><span class=s2>⊢ x = x&quot;</span><span class=p>}],</span>
 <span class=s2>&quot;env&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>}</span>

<span class=c1># 使用 have 策略</span>
<span class=p>{</span><span class=s2>&quot;proofState&quot;</span> <span class=p>:</span> <span class=mi>0</span><span class=p>,</span> <span class=s2>&quot;tactic&quot;</span><span class=p>:</span> <span class=s2>&quot;have h : x = 1 := by sorry&quot;</span><span class=p>}</span>
<span class=c1># 结果：</span>
<span class=c1># 1. have 引入了新的目标 proofState 1</span>
<span class=c1># 2. proofState 0 在执行 have 后变为 proofState 2</span>
<span class=p>{</span><span class=s2>&quot;sorries&quot;</span><span class=p>:</span> <span class=p>[{</span><span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>1</span><span class=p>,</span> <span class=s2>&quot;goal&quot;</span><span class=p>:</span> <span class=s2>&quot;x : Int</span><span class=se>\n</span><span class=s2>⊢ x = 1&quot;</span><span class=p>}],</span>
 <span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>2</span><span class=p>,</span>
 <span class=s2>&quot;goals&quot;</span><span class=p>:</span> <span class=p>[</span><span class=s2>&quot;x : Int</span><span class=se>\n</span><span class=s2>h : x = 1</span><span class=se>\n</span><span class=s2>⊢ x = 1&quot;</span><span class=p>]}</span>
</code></pre></div> <h2 id=repl_2>REPL 文件模式<a class=headerlink href=#repl_2 title="Permanent link">&para;</a></h2> <p>文件模式是 REPL 提供的一个简单但实用的功能，它允许直接读取和执行 Lean 源文件。</p> <h3 id=_8>用法示例<a class=headerlink href=#_8 title="Permanent link">&para;</a></h3> <p>假设 <code>test/file.lean</code> 包含以下内容：</p> <div class=highlight><pre><span></span><code><span class=kd>def</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Nat</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=mi>37</span>
<span class=kd>def</span><span class=w> </span><span class=n>g</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=mi>2</span>
<span class=kd>theorem</span><span class=w> </span><span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=n>g</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=mi>39</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=kd>by</span><span class=w> </span><span class=n>exact</span><span class=w> </span><span class=n>rfl</span>
</code></pre></div> <p>将 <code>allTactics</code> 参数设置为 <code>true</code>，获取更详细的证明过程和状态：</p> <div class=highlight><pre><span></span><code><span class=nb>echo</span><span class=w> </span><span class=s1>&#39;{&quot;path&quot;: &quot;/path/to/file.lean&quot;, &quot;allTactics&quot;: true}&#39;</span><span class=w> </span><span class=p>|</span><span class=w> </span>lake<span class=w> </span>exe<span class=w> </span>repl
</code></pre></div> <p>执行后会得到类似的输出：</p> <div class=highlight><pre><span></span><code><span class=p>{</span><span class=nt>&quot;tactics&quot;</span><span class=p>:</span>
<span class=w> </span><span class=p>[{</span><span class=nt>&quot;tactic&quot;</span><span class=p>:</span><span class=w> </span><span class=s2>&quot;exact rfl&quot;</span><span class=p>,</span>
<span class=w>   </span><span class=nt>&quot;proofState&quot;</span><span class=p>:</span><span class=w> </span><span class=mi>0</span><span class=p>,</span>
<span class=w>   </span><span class=nt>&quot;pos&quot;</span><span class=p>:</span><span class=w> </span><span class=p>{</span><span class=nt>&quot;line&quot;</span><span class=p>:</span><span class=w> </span><span class=mi>3</span><span class=p>,</span><span class=w> </span><span class=nt>&quot;column&quot;</span><span class=p>:</span><span class=w> </span><span class=mi>29</span><span class=p>},</span>
<span class=w>   </span><span class=nt>&quot;goals&quot;</span><span class=p>:</span><span class=w> </span><span class=s2>&quot;⊢ f + g = 39&quot;</span><span class=p>,</span>
<span class=w>   </span><span class=nt>&quot;endPos&quot;</span><span class=p>:</span><span class=w> </span><span class=p>{</span><span class=nt>&quot;line&quot;</span><span class=p>:</span><span class=w> </span><span class=mi>3</span><span class=p>,</span><span class=w> </span><span class=nt>&quot;column&quot;</span><span class=p>:</span><span class=w> </span><span class=mi>38</span><span class=p>}}],</span>
<span class=w> </span><span class=nt>&quot;env&quot;</span><span class=p>:</span><span class=w> </span><span class=mi>0</span><span class=p>}</span>
</code></pre></div> <p>效果等同于将文件内容通过 <code>cmd</code> 命令执行，即：</p> <div class=highlight><pre><span></span><code><span class=nb>echo</span><span class=w> </span><span class=s1>&#39;{&quot;cmd&quot; : &quot;def f : Nat := 37\\ndef g := 2\\ntheorem h : f + g = 39 := by exact rfl&quot;, &quot;allTactics&quot;: true}&#39;</span><span class=w> </span><span class=p>|</span><span class=w> </span>lake<span class=w> </span>exe<span class=w> </span>repl
</code></pre></div> <h2 id=pickle>Pickle 特性<a class=headerlink href=#pickle title="Permanent link">&para;</a></h2> <p>Pickle 特性允许我们将环境状态（env）或证明状态（proofState）保存到文件中，并在需要时重新加载。</p> <p><strong>使用场景</strong>：REPL 是以 Json 数据形式交互的，如果我们想还原当前的证明状态或环境，需要重新执行所有命令。对于复杂的证明过程，重复执行会很耗时。此外，在多机协作时，我们也需要共享证明状态。</p> <h3 id=pickle_1>Pickle 的基本操作<a class=headerlink href=#pickle_1 title="Permanent link">&para;</a></h3> <p>Pickle 的基本操作：</p> <ol> <li><strong>保存环境/状态</strong>（pickleTo）</li> <li><strong>加载状态</strong>（unpickleProofStateFrom）</li> <li><strong>加载环境</strong>（unpickleEnvFrom）</li> </ol> <h3 id=_9>示例分析<a class=headerlink href=#_9 title="Permanent link">&para;</a></h3> <p>看一个实际的例子：</p> <div class=highlight><pre><span></span><code><span class=c1># 1. 导入基础库</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span> <span class=p>:</span> <span class=s2>&quot;import Mathlib&quot;</span><span class=p>}</span>

<span class=c1># 2. 创建定理</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;theorem simple </span><span class=se>\n</span><span class=s2>  (a : ℝ):</span><span class=se>\n</span><span class=s2>  a^((1:ℝ)/2 * 2) = a := by sorry&quot;</span><span class=p>,</span> <span class=s2>&quot;env&quot;</span><span class=p>:</span><span class=mi>0</span><span class=p>}</span>

<span class=c1># 3. 保存证明状态</span>
<span class=p>{</span><span class=s2>&quot;pickleTo&quot;</span><span class=p>:</span> <span class=s2>&quot;test.olean&quot;</span><span class=p>,</span> <span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>}</span>

<span class=c1># 4. 加载证明状态</span>
<span class=p>{</span><span class=s2>&quot;unpickleProofStateFrom&quot;</span><span class=p>:</span> <span class=s2>&quot;test.olean&quot;</span><span class=p>}</span>

<span class=c1># 5. 继续证明</span>
<span class=p>{</span><span class=s2>&quot;tactic&quot;</span><span class=p>:</span> <span class=s2>&quot;ring_nf&quot;</span><span class=p>,</span> <span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>1</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;tactic&quot;</span><span class=p>:</span> <span class=s2>&quot;simp&quot;</span><span class=p>,</span> <span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>2</span><span class=p>}</span>
</code></pre></div> <h2 id=mathlib>配置 Mathlib 依赖<a class=headerlink href=#mathlib title="Permanent link">&para;</a></h2> <p>REPL 本身不依赖 Mathlib，但我们可能需要处理包含 Mathlib 依赖的项目。以 Lean 4.14.0 版本为例，有两种解决方式：</p> <p><strong>方式一：直接添加 Mathlib 依赖</strong></p> <ol> <li>在 REPL 项目的 <code>lakefile.toml</code> 中添加依赖：</li> </ol> <div class=highlight><pre><span></span><code><span class=k>[[require]]</span>
<span class=n>name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s2>&quot;mathlib&quot;</span>
<span class=n>git</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s2>&quot;https://github.com/leanprover-community/mathlib4&quot;</span>
<span class=n>rev</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s2>&quot;4bbdccd9c5f862bf90ff12f0a9e2c8be032b9a84&quot;</span>
</code></pre></div> <ol> <li>更新并构建：</li> </ol> <div class=highlight><pre><span></span><code>lake<span class=w> </span>update<span class=w> </span>-R<span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span>lake<span class=w> </span>exe<span class=w> </span>cache<span class=w> </span>get<span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span>lake<span class=w> </span>build
</code></pre></div> <ol> <li>使用示例：</li> </ol> <div class=highlight><pre><span></span><code><span class=nb>echo</span><span class=w> </span><span class=s1>&#39;{ &quot;cmd&quot;: &quot;import Mathlib&quot; }&#39;</span><span class=w> </span><span class=p>|</span><span class=w> </span>lake<span class=w> </span>exe<span class=w> </span>repl
</code></pre></div> <p><strong>方式二：使用 lake env</strong></p> <p>在包含 Mathlib 依赖的项目中，使用 <code>lake env</code> 指向 REPL 可执行文件：</p> <div class=highlight><pre><span></span><code><span class=nb>echo</span><span class=w> </span><span class=s1>&#39;{ &quot;cmd&quot;: &quot;import Mathlib&quot; }&#39;</span><span class=w> </span><span class=p>|</span><span class=w> </span>lake<span class=w> </span>env<span class=w> </span>/path/to/repl/.lake/build/bin/repl
</code></pre></div> <h2 id=_10>更多示例<a class=headerlink href=#_10 title="Permanent link">&para;</a></h2> <p>最后，附上 REPL 提供的测试示例，以下内容由模型结合测试代码生成。</p> <h3 id=_11>基础示例：检查变量定义<a class=headerlink href=#_11 title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=c1># 输入命令和对应输出</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;def f := 2&quot;</span><span class=p>}</span>                 <span class=c1># 定义 f</span>
<span class=p>{</span><span class=s2>&quot;env&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>}</span>

<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;#check f&quot;</span><span class=p>,</span> <span class=s2>&quot;env&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>}</span>         <span class=c1># 检查 f 的类型</span>
<span class=p>{</span><span class=s2>&quot;messages&quot;</span><span class=p>:</span> <span class=p>[{</span><span class=s2>&quot;data&quot;</span><span class=p>:</span> <span class=s2>&quot;f : Nat&quot;</span><span class=p>}</span><span class=o>...</span><span class=p>]}</span> <span class=c1># f 的类型是 Nat</span>

<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;#check g&quot;</span><span class=p>,</span> <span class=s2>&quot;env&quot;</span><span class=p>:</span> <span class=mi>1</span><span class=p>}</span>         <span class=c1># 检查未定义的 g</span>
<span class=p>{</span><span class=s2>&quot;messages&quot;</span><span class=p>:</span> <span class=p>[{</span><span class=s2>&quot;data&quot;</span><span class=p>:</span> <span class=s2>&quot;unknown identifier &#39;g&#39;&quot;</span><span class=p>}</span><span class=o>...</span><span class=p>]}</span> <span class=c1># 报错：未知标识符</span>
</code></pre></div> <p>使用 <code>#check</code> 命令检查变量的类型，以及处理未定义变量的错误情况。</p> <h3 id=by_cases>策略示例：使用 by_cases 分类讨论<a class=headerlink href=#by_cases title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=c1># 定义带有 sorry 的定理</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;theorem foo (x : Int) : x = x := by sorry&quot;</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;sorries&quot;</span><span class=p>:</span> <span class=p>[{</span><span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>,</span> <span class=s2>&quot;goal&quot;</span><span class=p>:</span> <span class=s2>&quot;x : Int</span><span class=se>\n</span><span class=s2>⊢ x = x&quot;</span><span class=p>}</span><span class=o>...</span><span class=p>]}</span>

<span class=c1># 使用 by_cases 策略分类讨论</span>
<span class=p>{</span><span class=s2>&quot;proofState&quot;</span> <span class=p>:</span> <span class=mi>0</span><span class=p>,</span> <span class=s2>&quot;tactic&quot;</span><span class=p>:</span> <span class=s2>&quot;by_cases h : x &lt; 0&quot;</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>1</span><span class=p>,</span> <span class=s2>&quot;goals&quot;</span><span class=p>:</span> <span class=p>[</span>
  <span class=s2>&quot;case pos</span><span class=se>\n</span><span class=s2>x : Int</span><span class=se>\n</span><span class=s2>h : x &lt; 0</span><span class=se>\n</span><span class=s2>⊢ x = x&quot;</span><span class=p>,</span>
  <span class=s2>&quot;case neg</span><span class=se>\n</span><span class=s2>x : Int</span><span class=se>\n</span><span class=s2>h : ¬x &lt; 0</span><span class=se>\n</span><span class=s2>⊢ x = x&quot;</span><span class=p>]}</span>

<span class=c1># 处理正例</span>
<span class=p>{</span><span class=s2>&quot;proofState&quot;</span> <span class=p>:</span> <span class=mi>1</span><span class=p>,</span> <span class=s2>&quot;tactic&quot;</span><span class=p>:</span> <span class=s2>&quot;case pos =&gt; rfl&quot;</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>2</span><span class=p>,</span> <span class=s2>&quot;goals&quot;</span><span class=p>:</span> <span class=p>[</span><span class=s2>&quot;case neg...&quot;</span><span class=p>]}</span>

<span class=c1># 使用 sorry 完成所有剩余目标</span>
<span class=p>{</span><span class=s2>&quot;proofState&quot;</span> <span class=p>:</span> <span class=mi>1</span><span class=p>,</span> <span class=s2>&quot;tactic&quot;</span><span class=p>:</span> <span class=s2>&quot;all_goals sorry&quot;</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>5</span><span class=p>,</span> <span class=s2>&quot;goals&quot;</span><span class=p>:</span> <span class=p>[]}</span>
</code></pre></div> <p>使用 <code>by_cases</code> 策略进行分类讨论，并通过 <code>all_goals sorry</code> 处理剩余证明目标。</p> <h3 id=_12>变量声明与复杂定理<a class=headerlink href=#_12 title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=c1># 声明变量</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;variable (x y : Nat)&quot;</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;variable (f : Nat → Nat)&quot;</span><span class=p>,</span> <span class=s2>&quot;env&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>}</span>

<span class=c1># 定义复杂定理</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;theorem problem (h0 : f 5 = 3) (h1 : f (4 * x * y) = 2 * y * (f (x + y) + f (x - y))) :</span>
    <span class=err>∃</span> <span class=p>(</span><span class=n>k</span> <span class=p>:</span> <span class=n>Nat</span><span class=p>),</span> <span class=n>f</span> <span class=mi>2015</span> <span class=o>=</span> <span class=n>k</span> <span class=o>:=</span> <span class=n>by</span>\<span class=n>n</span>  <span class=n>sorry</span><span class=s2>&quot;, &quot;</span><span class=n>env</span><span class=s2>&quot;: 1}</span>
</code></pre></div> <p>声明变量和函数变量，并构建包含这些变量的复杂定理。注意到这个例子中的错误提示表明需要正确处理变量作用域。</p> <h3 id=_13>策略示例：使用各种策略组合<a class=headerlink href=#_13 title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=c1># 设置 simp 追踪并定义示例</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;set_option trace.Meta.Tactic.simp true</span><span class=se>\n</span><span class=s2>example {x : Int} (h0 : x &gt; 0) : False := by sorry&quot;</span><span class=p>}</span>

<span class=c1># 尝试不同策略</span>
<span class=p>{</span><span class=s2>&quot;tactic&quot;</span><span class=p>:</span> <span class=s2>&quot;have h : x &gt; 0 := by sorry&quot;</span><span class=p>,</span> <span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>}</span>  <span class=c1># 引入新假设</span>
<span class=p>{</span><span class=s2>&quot;tactic&quot;</span><span class=p>:</span> <span class=s2>&quot;exact h0&quot;</span><span class=p>,</span> <span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>1</span><span class=p>}</span>                    <span class=c1># 使用 exact</span>
<span class=p>{</span><span class=s2>&quot;tactic&quot;</span><span class=p>:</span> <span class=s2>&quot;assumption&quot;</span><span class=p>,</span> <span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>1</span><span class=p>}</span>                  <span class=c1># 使用 assumption</span>
<span class=p>{</span><span class=s2>&quot;tactic&quot;</span><span class=p>:</span> <span class=s2>&quot;simp only [of_eq_true (eq_true h0)]&quot;</span><span class=p>,</span> <span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>1</span><span class=p>}</span>  <span class=c1># simp 带配置</span>
<span class=p>{</span><span class=s2>&quot;tactic&quot;</span><span class=p>:</span> <span class=s2>&quot;{ simp [h0] }&quot;</span><span class=p>,</span> <span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>1</span><span class=p>}</span>              <span class=c1># 局部 simp</span>
<span class=c1># ... 其他策略尝试</span>
</code></pre></div> <p>多种证明策略的使用方式，包括 <code>have</code>、<code>exact</code>、<code>assumption</code> 和带不同配置的 <code>simp</code>。</p> <p>注：为简洁起见，省略了部分输出信息。</p> <h3 id=have_1>策略示例：使用 have 引入中间变量<a class=headerlink href=#have_1 title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=c1># 使用 have 引入中间变量并完成定义</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;def f : Nat := by have t := 37; exact t&quot;</span><span class=p>,</span> <span class=s2>&quot;allTactics&quot;</span><span class=p>:</span> <span class=n>true</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>,</span> <span class=s2>&quot;goals&quot;</span><span class=p>:</span> <span class=p>[</span><span class=s2>&quot;t : Nat</span><span class=se>\n</span><span class=s2>⊢ Nat&quot;</span><span class=p>]}</span>  <span class=c1># 引入 t 后的状态</span>
<span class=p>{</span><span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>1</span><span class=p>,</span> <span class=s2>&quot;goals&quot;</span><span class=p>:</span> <span class=p>[]}</span>                   <span class=c1># exact t 完成证明</span>
</code></pre></div> <p>使用 <code>have</code> 引入中间变量，并用 <code>exact</code> 完成定义，<code>allTactics</code> 参数允许追踪策略执行过程。</p> <h3 id=lake>包管理示例：导入 Lake<a class=headerlink href=#lake title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=c1># 导入 Lake 包并打开 DSL 命名空间</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;import Lake open Lake DSL</span><span class=se>\n</span><span class=s2>package REPL&quot;</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;sorries&quot;</span><span class=p>:</span> <span class=p>[{</span><span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>,</span> <span class=s2>&quot;goal&quot;</span><span class=p>:</span> <span class=s2>&quot;⊢ Nat&quot;</span><span class=p>}</span><span class=o>...</span><span class=p>]}</span>
</code></pre></div> <p>导入和使用 Lake 包管理系统，这是 Lean 4 的标准包管理器。</p> <h3 id=sorry>简单示例：基础定义中的 sorry<a class=headerlink href=#sorry title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=c1># 使用 sorry 定义函数</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;def f : Nat := by sorry&quot;</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;sorries&quot;</span><span class=p>:</span> <span class=p>[{</span><span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>,</span> <span class=s2>&quot;goal&quot;</span><span class=p>:</span> <span class=s2>&quot;⊢ ◾&quot;</span><span class=p>}</span><span class=o>...</span><span class=p>]}</span>
</code></pre></div> <p>最基本的 sorry 占位符使用方式，其中 <code>⊢ ◾</code> 表示需要证明一个值（而不是命题）。</p> <h3 id=_14>策略示例：构造函数应用<a class=headerlink href=#_14 title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=c1># 简单构造函数应用</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;def f : Nat := by apply Nat.succ&quot;</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;messages&quot;</span><span class=p>:</span> <span class=p>[{</span><span class=s2>&quot;data&quot;</span><span class=p>:</span> <span class=s2>&quot;unused variable `h`&quot;</span><span class=o>...</span><span class=p>}]}</span>

<span class=c1># 使用 by_cases 的条件分支</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;def f (x : Bool) : Nat := by</span><span class=se>\n</span><span class=s2>  by_cases x</span><span class=se>\n</span><span class=s2>  { apply Nat.succ }&quot;</span><span class=p>}</span>
</code></pre></div> <p>使用 <code>apply</code> 策略应用构造函数，以及在 <code>by_cases</code> 分支中使用构造函数。</p> <h3 id=have_2>策略示例：have 引入中间命题<a class=headerlink href=#have_2 title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=c1># 创建带有多个 sorry 的示例</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span> <span class=p>:</span> <span class=s2>&quot;example : True := by</span><span class=se>\n</span><span class=s2>  have h : set Nat := by sorry</span><span class=se>\n</span><span class=s2>  sorry&quot;</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;sorries&quot;</span><span class=p>:</span> <span class=p>[</span>
  <span class=p>{</span><span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>,</span> <span class=s2>&quot;goal&quot;</span><span class=p>:</span> <span class=s2>&quot;x : Int</span><span class=se>\n</span><span class=s2>⊢ x = x&quot;</span><span class=p>}</span><span class=o>...</span><span class=p>],</span>  <span class=c1># 第一个 sorry</span>
  <span class=s2>&quot;messages&quot;</span><span class=p>:</span> <span class=p>[{</span><span class=s2>&quot;data&quot;</span><span class=p>:</span> <span class=s2>&quot;declaration uses &#39;sorry&#39;&quot;</span><span class=p>}</span><span class=o>...</span><span class=p>]}</span>

<span class=c1># have 语句产生新的证明状态</span>
<span class=p>{</span><span class=s2>&quot;sorries&quot;</span><span class=p>:</span> <span class=p>[{</span><span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>1</span><span class=p>,</span> <span class=s2>&quot;goal&quot;</span><span class=p>:</span> <span class=s2>&quot;x : Int</span><span class=se>\n</span><span class=s2>⊢ x = 1&quot;</span><span class=p>}],</span>
 <span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>2</span><span class=p>,</span>
 <span class=s2>&quot;goals&quot;</span><span class=p>:</span> <span class=p>[</span><span class=s2>&quot;x : Int</span><span class=se>\n</span><span class=s2>h : x = 1</span><span class=se>\n</span><span class=s2>⊢ x = x&quot;</span><span class=p>]}</span>
</code></pre></div> <p>使用 <code>have</code> 策略引入中间命题，这会产生两个证明目标：一个用于证明引入的命题，另一个用于完成主要证明。</p> <h3 id=rfl>基础示例：使用 rfl 检查相等性<a class=headerlink href=#rfl title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=c1># 定义数值</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;def f := 37&quot;</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;env&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>}</span>

<span class=c1># 使用 rfl 检查相等性</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;#check (rfl : f = 37)&quot;</span><span class=p>,</span> <span class=s2>&quot;env&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>}</span>
<span class=c1># 命令执行成功，无输出表示类型检查通过</span>
</code></pre></div> <p>使用 <code>rfl</code>（reflexivity）证明简单的相等性，并通过 <code>#check</code> 验证。</p> <h3 id=_15>示例：使用下划线占位符<a class=headerlink href=#_15 title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=c1># 使用下划线作为占位符定义函数</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;def f : Nat := _&quot;</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;messages&quot;</span><span class=p>:</span> <span class=p>[{</span><span class=s2>&quot;data&quot;</span><span class=p>:</span> <span class=s2>&quot;constructor List.cons...&quot;</span><span class=p>}</span><span class=o>...</span><span class=p>]}</span>
</code></pre></div> <p>使用下划线（<code>_</code>）作为占位符来定义函数，REPL 会显示可能的构造器信息。</p> <h3 id=_16>基础示例：定义数值类型<a class=headerlink href=#_16 title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=c1># 使用 sorry 定义自然数</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;def f : Nat := sorry&quot;</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;sorries&quot;</span><span class=p>:</span> <span class=p>[{</span><span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>,</span> <span class=s2>&quot;goal&quot;</span><span class=p>:</span> <span class=s2>&quot;⊢ Nat&quot;</span><span class=p>}</span><span class=o>...</span><span class=p>]}</span>
</code></pre></div> <p>使用 <code>sorry</code> 为自然数类型创建一个占位定义。</p> <h3 id=_17>打印示例：查看定义和设置选项<a class=headerlink href=#_17 title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=c1># 打印 List.cons 定义</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;#print List.cons&quot;</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;env&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>}</span>

<span class=c1># 启用打印universe层级</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;set_option pp.universes true&quot;</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;env&quot;</span><span class=p>:</span> <span class=mi>1</span><span class=p>}</span>

<span class=c1># 再次打印 List.cons，这次会显示universe信息</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;#print List.cons&quot;</span><span class=p>,</span> <span class=s2>&quot;env&quot;</span><span class=p>:</span> <span class=mi>1</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;env&quot;</span><span class=p>:</span> <span class=mi>2</span><span class=p>}</span>
</code></pre></div> <p>使用 <code>#print</code> 命令查看定义，以及通过 <code>set_option</code> 控制输出格式。</p> <h3 id=natabs>策略示例：使用 natAbs 构造自然数<a class=headerlink href=#natabs title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=c1># 定义返回自然数的函数</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span> <span class=p>:</span> <span class=s2>&quot;def f (x : Unit) : Nat := by sorry&quot;</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;sorries&quot;</span><span class=p>:</span> <span class=p>[{</span><span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>,</span> <span class=s2>&quot;goal&quot;</span><span class=p>:</span> <span class=s2>&quot;x : Unit</span><span class=se>\n</span><span class=s2>⊢ Nat&quot;</span><span class=p>}</span><span class=o>...</span><span class=p>]}</span>

<span class=c1># 使用 Int.natAbs 将整数转换为自然数</span>
<span class=p>{</span><span class=s2>&quot;tactic&quot;</span><span class=p>:</span> <span class=s2>&quot;apply Int.natAbs&quot;</span><span class=p>,</span> <span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>1</span><span class=p>,</span> <span class=s2>&quot;goals&quot;</span><span class=p>:</span> <span class=p>[</span><span class=s2>&quot;x : Unit</span><span class=se>\n</span><span class=s2>⊢ Int&quot;</span><span class=p>]}</span>

<span class=c1># 提供具体整数值</span>
<span class=p>{</span><span class=s2>&quot;tactic&quot;</span><span class=p>:</span> <span class=s2>&quot;exact -37&quot;</span><span class=p>,</span> <span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>1</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>2</span><span class=p>,</span> <span class=s2>&quot;goals&quot;</span><span class=p>:</span> <span class=p>[]}</span>
</code></pre></div> <p>通过 <code>Int.natAbs</code> 将整数转换为自然数来构造 <code>Nat</code> 类型的值。</p> <h3 id=_18>错误示例：错误的构造器使用<a class=headerlink href=#_18 title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=c1># 尝试使用 constructor 构造 Nat</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;def f (h : Int) : Nat := by constructor&quot;</span><span class=p>,</span> <span class=s2>&quot;infotree&quot;</span><span class=p>:</span> <span class=s2>&quot;substantive&quot;</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;messages&quot;</span><span class=p>:</span> <span class=p>[{</span><span class=s2>&quot;data&quot;</span><span class=p>:</span> <span class=s2>&quot;don&#39;t know how to synthesize placeholder</span><span class=se>\n</span><span class=s2>context:</span><span class=se>\n</span><span class=s2>⊢ Nat&quot;</span><span class=p>}</span><span class=o>...</span><span class=p>]}</span>
</code></pre></div> <p>错误使用 <code>constructor</code> 策略的情况：不能直接用构造器构造 <code>Nat</code> 类型。</p> <h3 id=_19>策略示例：错误处理演示<a class=headerlink href=#_19 title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=c1># 定义定理</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;theorem my_theorem (x : Nat) : x = x := by sorry&quot;</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;sorries&quot;</span><span class=p>:</span> <span class=p>[{</span><span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>,</span> <span class=s2>&quot;goal&quot;</span><span class=p>:</span> <span class=s2>&quot;x : Int</span><span class=se>\n</span><span class=s2>⊢ x = x&quot;</span><span class=p>}</span><span class=o>...</span><span class=p>]}</span>

<span class=c1># 尝试使用未定义的前提</span>
<span class=p>{</span><span class=s2>&quot;tactic&quot;</span><span class=p>:</span> <span class=s2>&quot;exact my_fake_premise&quot;</span><span class=p>,</span> <span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;messages&quot;</span><span class=p>:</span> <span class=p>[{</span><span class=s2>&quot;severity&quot;</span><span class=p>:</span> <span class=s2>&quot;error&quot;</span><span class=p>,</span> <span class=s2>&quot;data&quot;</span><span class=p>:</span> <span class=s2>&quot;unknown identifier &#39;my_fake_premise&#39;&quot;</span><span class=p>}</span><span class=o>...</span><span class=p>]}</span>
</code></pre></div> <p>在使用未定义变量时 REPL 的错误处理机制。</p> <h3 id=sorry_1>示例：多个 sorry 的处理<a class=headerlink href=#sorry_1 title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=c1># 使用多个 sorry 的示例</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span> <span class=p>:</span> <span class=s2>&quot;example : True := by</span><span class=se>\n</span><span class=s2>  sorry</span><span class=se>\n</span><span class=s2>  sorry&quot;</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;sorries&quot;</span><span class=p>:</span> <span class=p>[{</span><span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>,</span> <span class=s2>&quot;goal&quot;</span><span class=p>:</span> <span class=s2>&quot;⊢ Nat&quot;</span><span class=p>}</span><span class=o>...</span><span class=p>]}</span>
</code></pre></div> <p>在同一个证明中使用多个 <code>sorry</code>，REPL 会为每个 <code>sorry</code> 分配独立的 <code>proofState</code>。</p> <h3 id=have_3>策略示例：使用 have 引入中间结论<a class=headerlink href=#have_3 title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=c1># 定义定理</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;theorem foo (x : Int) : x = x := by sorry&quot;</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;sorries&quot;</span><span class=p>:</span> <span class=p>[{</span><span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>,</span> <span class=s2>&quot;goal&quot;</span><span class=p>:</span> <span class=s2>&quot;x : Int</span><span class=se>\n</span><span class=s2>⊢ x = x&quot;</span><span class=p>}</span><span class=o>...</span><span class=p>]}</span>

<span class=c1># 使用 have 引入中间结论</span>
<span class=p>{</span><span class=s2>&quot;proofState&quot;</span> <span class=p>:</span> <span class=mi>0</span><span class=p>,</span> <span class=s2>&quot;tactic&quot;</span><span class=p>:</span> <span class=s2>&quot;have h : x = 1 := sorry&quot;</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;messages&quot;</span><span class=p>:</span> <span class=p>[{</span><span class=s2>&quot;data&quot;</span><span class=p>:</span> <span class=s2>&quot;unsolved goals...&quot;</span><span class=p>}</span><span class=o>...</span><span class=p>]}</span>
</code></pre></div> <p>使用 <code>have</code> 策略引入中间结论，这会产生两个证明目标：一个是证明中间结论，另一个是使用中间结论证明原目标。</p> <h3 id=_20>策略示例：简单值定义<a class=headerlink href=#_20 title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=c1># 定义带有 sorry 的自然数</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span> <span class=p>:</span> <span class=s2>&quot;def f : Nat := by sorry&quot;</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;sorries&quot;</span><span class=p>:</span> <span class=p>[{</span><span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>,</span> <span class=s2>&quot;goal&quot;</span><span class=p>:</span> <span class=s2>&quot;⊢ True&quot;</span><span class=p>}</span><span class=o>...</span><span class=p>]}</span>

<span class=c1># 尝试使用 exact 策略（错误示例）</span>
<span class=p>{</span><span class=s2>&quot;tactic&quot;</span><span class=p>:</span> <span class=s2>&quot;exact 42&quot;</span><span class=p>,</span> <span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>1</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;messages&quot;</span><span class=p>:</span> <span class=p>[{</span><span class=s2>&quot;data&quot;</span><span class=p>:</span> <span class=s2>&quot;no goals to be solved&quot;</span><span class=p>}</span><span class=o>...</span><span class=p>]}</span>
</code></pre></div> <p>一个简单的值定义，以及当尝试在无效状态上使用策略时的错误处理。</p> <h3 id=_21>文件模式示例：读取文件并处理错误<a class=headerlink href=#_21 title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=c1># 读取并执行 Lean 文件</span>
<span class=p>{</span><span class=s2>&quot;path&quot;</span><span class=p>:</span> <span class=s2>&quot;test/file.lean&quot;</span><span class=p>,</span> <span class=s2>&quot;allTactics&quot;</span><span class=p>:</span> <span class=n>true</span><span class=p>}</span>

<span class=c1># 输出包含错误信息</span>
<span class=p>{</span><span class=s2>&quot;sorries&quot;</span><span class=p>:</span> <span class=p>[{</span><span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>,</span> <span class=s2>&quot;goal&quot;</span><span class=p>:</span> <span class=s2>&quot;x : Nat</span><span class=se>\n</span><span class=s2>⊢ x = x&quot;</span><span class=p>}</span><span class=o>...</span><span class=p>]}</span>
<span class=p>{</span><span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>1</span><span class=p>,</span> <span class=s2>&quot;messages&quot;</span><span class=p>:</span> <span class=p>[</span>
  <span class=p>{</span><span class=s2>&quot;data&quot;</span><span class=p>:</span> <span class=s2>&quot;unknown identifier &#39;my_fake_premise&#39;&quot;</span><span class=p>}</span><span class=o>...</span><span class=p>]}</span>
</code></pre></div> <p>文件模式读取 Lean 文件并处理执行过程中的错误（如未知标识符）。</p> <h3 id=trace-simp>调试示例：使用 trace 和 simp<a class=headerlink href=#trace-simp title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=c1># 定义函数和简化规则</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;def f := 37&quot;</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;@[simp] theorem f_def : f = 37 := by rfl&quot;</span><span class=p>,</span> <span class=s2>&quot;env&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>}</span>

<span class=c1># 启用 simp 跟踪</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;set_option trace.Meta.Tactic.simp true&quot;</span><span class=p>,</span> <span class=s2>&quot;env&quot;</span><span class=p>:</span> <span class=mi>1</span><span class=p>}</span>

<span class=c1># 使用 simp 证明</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;example : f = 37 := by simp&quot;</span><span class=p>,</span> <span class=s2>&quot;env&quot;</span><span class=p>:</span> <span class=mi>2</span><span class=p>}</span>

<span class=c1># 使用 trace 进行调试</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;example : f = 37 := by sorry&quot;</span><span class=p>,</span> <span class=s2>&quot;env&quot;</span><span class=p>:</span> <span class=mi>2</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;tactic&quot;</span><span class=p>:</span> <span class=s2>&quot;trace </span><span class=se>\&quot;</span><span class=s2>37</span><span class=se>\&quot;</span><span class=s2>&quot;</span><span class=p>,</span> <span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;tactic&quot;</span><span class=p>:</span> <span class=s2>&quot;simp&quot;</span><span class=p>,</span> <span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>}</span>

<span class=c1># 在证明中嵌入 trace</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;example : True := by</span><span class=se>\n</span><span class=s2>  trace </span><span class=se>\&quot;</span><span class=s2>!</span><span class=se>\&quot;\n</span><span class=s2>  trivial&quot;</span><span class=p>}</span>
</code></pre></div> <p>使用 <code>trace</code> 和 <code>simp</code> 进行调试和简化证明，以及设置跟踪选项。</p> <h3 id=sorry_2>策略示例：直接使用 sorry<a class=headerlink href=#sorry_2 title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=c1># 定义带有 sorry 的函数</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;def f : Nat := by sorry&quot;</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;env&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>}</span>

<span class=c1># 直接使用 sorry 完成证明</span>
<span class=p>{</span><span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>,</span> <span class=s2>&quot;tactic&quot;</span><span class=p>:</span> <span class=s2>&quot;sorry&quot;</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;env&quot;</span><span class=p>:</span> <span class=mi>2</span><span class=p>}</span>
</code></pre></div> <p>最简单的 sorry 用法：直接用 sorry 完成定义或证明。</p> <h3 id=calc>策略示例：使用 calc（计算块）<a class=headerlink href=#calc title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=c1># 使用 calc 块进行链式推导</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;example : 3 = 5 := by calc</span><span class=se>\n</span><span class=s2>  3 = 4 := by sorry</span><span class=se>\n</span><span class=s2>  4 = 5 := by sorry&quot;</span><span class=p>,</span> <span class=s2>&quot;allTactics&quot;</span><span class=p>:</span> <span class=n>true</span> <span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;tactics&quot;</span><span class=p>:</span> <span class=p>[{</span><span class=s2>&quot;tactic&quot;</span><span class=p>:</span> <span class=s2>&quot;exact rfl&quot;</span><span class=p>,</span> <span class=s2>&quot;goals&quot;</span><span class=p>:</span> <span class=s2>&quot;⊢ f + g = 39&quot;</span><span class=o>...</span><span class=p>}]}</span>
</code></pre></div> <p>使用 <code>calc</code> 语法构建链式等式推导，每一步都使用 <code>sorry</code> 标记待证明的步骤。</p> <h3 id=_22>错误处理示例：策略名拼写错误<a class=headerlink href=#_22 title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=c1># 定义带有 sorry 的函数</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span> <span class=p>:</span> <span class=s2>&quot;def f : Nat := by sorry&quot;</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;sorries&quot;</span><span class=p>:</span> <span class=p>[{</span><span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>,</span> <span class=s2>&quot;goal&quot;</span><span class=p>:</span> <span class=s2>&quot;⊢ Nat&quot;</span><span class=p>}</span><span class=o>...</span><span class=p>]}</span>

<span class=c1># 错误的策略名称 (exat 应为 exact)</span>
<span class=p>{</span><span class=s2>&quot;tactic&quot;</span><span class=p>:</span> <span class=s2>&quot;exat 42&quot;</span><span class=p>,</span> <span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>1</span><span class=p>,</span> <span class=s2>&quot;goals&quot;</span><span class=p>:</span> <span class=p>[</span><span class=s2>&quot;⊢ Nat&quot;</span><span class=p>]}</span>  <span class=c1># 策略执行失败，目标保持不变</span>
</code></pre></div> <p>当策略名称拼写错误时（<code>exat</code> 而不是 <code>exact</code>），REPL 会保持证明状态不变，允许继续尝试正确的策略。</p> <h3 id=_23>示例：多个定理的连续定义<a class=headerlink href=#_23 title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=c1># 定义第一个定理</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;theorem thm1 : 1 = 1 := sorry&quot;</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;sorries&quot;</span><span class=p>:</span> <span class=p>[{</span><span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>,</span> <span class=s2>&quot;goal&quot;</span><span class=p>:</span> <span class=s2>&quot;⊢ 1 = 1&quot;</span><span class=p>}</span><span class=o>...</span><span class=p>],</span> <span class=s2>&quot;env&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>}</span>

<span class=c1># 在同一环境下定义第二个定理</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;theorem thm2 : 2 = 2 := sorry&quot;</span><span class=p>,</span> <span class=s2>&quot;env&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;sorries&quot;</span><span class=p>:</span> <span class=p>[{</span><span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>1</span><span class=p>,</span> <span class=s2>&quot;goal&quot;</span><span class=p>:</span> <span class=s2>&quot;⊢ 2 = 2&quot;</span><span class=p>}</span><span class=o>...</span><span class=p>],</span> <span class=s2>&quot;env&quot;</span><span class=p>:</span> <span class=mi>1</span><span class=p>}</span>
</code></pre></div> <p>在同一环境中连续定义多个待证明的定理，每个定理获得独立的 <code>proofState</code>。</p> <h3 id=sorry_3>示例：sorry 占位符的基本使用<a class=headerlink href=#sorry_3 title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=c1># 使用 sorry 定义一个自然数</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;def f : Nat := by sorry&quot;</span><span class=p>,</span> <span class=s2>&quot;env&quot;</span><span class=p>:</span> <span class=mi>5</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;sorries&quot;</span><span class=p>:</span> <span class=p>[{</span><span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>,</span> <span class=s2>&quot;goal&quot;</span><span class=p>:</span> <span class=s2>&quot;⊢ ◾&quot;</span><span class=p>}</span><span class=o>...</span><span class=p>],</span>
 <span class=s2>&quot;messages&quot;</span><span class=p>:</span> <span class=p>[{</span><span class=s2>&quot;data&quot;</span><span class=p>:</span> <span class=s2>&quot;declaration uses &#39;sorry&#39;&quot;</span><span class=p>}</span><span class=o>...</span><span class=p>],</span>
 <span class=s2>&quot;env&quot;</span><span class=p>:</span> <span class=mi>2</span><span class=p>}</span>
</code></pre></div> <p>使用 <code>sorry</code> 作为占位符来定义一个尚未实现的自然数值，其中 <code>⊢ ◾</code> 表示需要提供一个 <code>Nat</code> 类型的值。</p> <h3 id=_24>策略示例：定义自然数值<a class=headerlink href=#_24 title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=c1># 定义带证明的自然数</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span> <span class=p>:</span> <span class=s2>&quot;def f : Nat := by sorry&quot;</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;sorries&quot;</span><span class=p>:</span> <span class=p>[{</span><span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>,</span> <span class=s2>&quot;goal&quot;</span><span class=p>:</span> <span class=s2>&quot;⊢ Nat&quot;</span><span class=p>}</span><span class=o>...</span><span class=p>]}</span>

<span class=c1># 尝试应用 Int.natAbs（错误示范）</span>
<span class=p>{</span><span class=s2>&quot;tactic&quot;</span><span class=p>:</span> <span class=s2>&quot;apply Int.natAbs&quot;</span><span class=p>,</span> <span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;messages&quot;</span><span class=p>:</span> <span class=p>[{</span><span class=s2>&quot;data&quot;</span><span class=p>:</span> <span class=s2>&quot;type expected, got (set Nat...&quot;</span><span class=p>}</span><span class=o>...</span><span class=p>]}</span>

<span class=c1># 引入中间值</span>
<span class=p>{</span><span class=s2>&quot;tactic&quot;</span><span class=p>:</span> <span class=s2>&quot;have t : Nat := 42&quot;</span><span class=p>,</span> <span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mf>2.</span><span class=o>..</span><span class=p>}</span>

<span class=c1># 使用引入的值完成证明</span>
<span class=p>{</span><span class=s2>&quot;tactic&quot;</span><span class=p>:</span> <span class=s2>&quot;exact t&quot;</span><span class=p>,</span> <span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>2</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>3</span><span class=p>,</span> <span class=s2>&quot;goals&quot;</span><span class=p>:</span> <span class=p>[]}</span>
</code></pre></div> <p>通过引入具体值（42）来定义自然数，以及处理错误策略应用的情况。</p> <h3 id=have_4>策略示例：使用 have 引入中间结论<a class=headerlink href=#have_4 title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=c1># 方式一：在定理中直接使用 have</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;theorem foo (x : Int) : x = x := by</span><span class=se>\n</span><span class=s2>  have h : x = 1 := by sorry&quot;</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;messages&quot;</span><span class=p>:</span> <span class=p>[</span><span class=s2>&quot;unsolved goals</span><span class=se>\n</span><span class=s2>x : Int</span><span class=se>\n</span><span class=s2>h : x = 1</span><span class=se>\n</span><span class=s2>⊢ x = x&quot;</span><span class=o>...</span><span class=p>]}</span>

<span class=c1># 方式二：分步执行 have</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;theorem foo (x : Int) : x = x := by sorry&quot;</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;sorries&quot;</span><span class=p>:</span> <span class=p>[{</span><span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>1</span><span class=p>,</span> <span class=s2>&quot;goal&quot;</span><span class=p>:</span> <span class=s2>&quot;x : Int</span><span class=se>\n</span><span class=s2>⊢ x = x&quot;</span><span class=p>}</span><span class=o>...</span><span class=p>]}</span>

<span class=p>{</span><span class=s2>&quot;proofState&quot;</span> <span class=p>:</span> <span class=mi>0</span><span class=p>,</span> <span class=s2>&quot;tactic&quot;</span><span class=p>:</span> <span class=s2>&quot;have h : x = 1 := by sorry&quot;</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;sorries&quot;</span><span class=p>:</span> <span class=p>[{</span><span class=s2>&quot;goal&quot;</span><span class=p>:</span> <span class=s2>&quot;x : Int</span><span class=se>\n</span><span class=s2>⊢ x = 1&quot;</span><span class=p>}],</span>
 <span class=s2>&quot;goals&quot;</span><span class=p>:</span> <span class=p>[</span><span class=s2>&quot;x : Int</span><span class=se>\n</span><span class=s2>h : x = 1</span><span class=se>\n</span><span class=s2>⊢ x = 1&quot;</span><span class=p>]}</span>
</code></pre></div> <p>两种使用 <code>have</code> 引入中间结论的方式，以及它们产生的证明状态。</p> <h3 id=_25>策略示例：基本策略组合<a class=headerlink href=#_25 title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=c1># 定义函数 f，使用策略模式</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;def f : Nat := by&quot;</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;tactics&quot;</span><span class=p>:</span> <span class=p>[</span>
    <span class=c1># 第一个策略：引入中间变量</span>
    <span class=p>{</span><span class=s2>&quot;tactic&quot;</span><span class=p>:</span> <span class=s2>&quot;have t := 37&quot;</span><span class=p>,</span> <span class=s2>&quot;goals&quot;</span><span class=p>:</span> <span class=s2>&quot;⊢ Nat&quot;</span><span class=o>...</span><span class=p>},</span>
    <span class=c1># 第二个策略：使用引入的变量完成证明</span>
    <span class=p>{</span><span class=s2>&quot;tactic&quot;</span><span class=p>:</span> <span class=s2>&quot;exact t&quot;</span><span class=p>,</span> <span class=s2>&quot;goals&quot;</span><span class=p>:</span> <span class=s2>&quot;t : Nat</span><span class=se>\n</span><span class=s2>⊢ Nat&quot;</span><span class=o>...</span><span class=p>}</span>
<span class=p>]}</span>
</code></pre></div> <p>使用 <code>have</code> 和 <code>exact</code> 策略的组合来构造一个简单的自然数定义。</p> <h2 id=pickle_2>Pickle 模式<a class=headerlink href=#pickle_2 title="Permanent link">&para;</a></h2> <h3 id=pickle_3>Pickle 示例：保存和加载环境<a class=headerlink href=#pickle_3 title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=c1># 定义并保存环境</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;def f := 42&quot;</span><span class=p>}</span>                         <span class=c1># 定义 f</span>
<span class=p>{</span><span class=s2>&quot;pickleTo&quot;</span><span class=p>:</span> <span class=s2>&quot;test/a.olean&quot;</span><span class=p>,</span> <span class=s2>&quot;env&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>}</span>        <span class=c1># 保存环境</span>

<span class=c1># 加载环境并使用</span>
<span class=p>{</span><span class=s2>&quot;unpickleEnvFrom&quot;</span><span class=p>:</span> <span class=s2>&quot;test/a.olean&quot;</span><span class=p>}</span>           <span class=c1># 加载</span>
</code></pre></div> <p>环境的序列化操作。</p> <h3 id=pickle_4>Pickle 示例：保存和加载环境<a class=headerlink href=#pickle_4 title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=c1># 导入基础库并定义函数</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;import Lean&quot;</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;def f := 42&quot;</span><span class=p>,</span> <span class=s2>&quot;env&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>}</span>

<span class=c1># 保存环境到文件</span>
<span class=p>{</span><span class=s2>&quot;pickleTo&quot;</span><span class=p>:</span> <span class=s2>&quot;test/b.olean&quot;</span><span class=p>,</span> <span class=s2>&quot;env&quot;</span><span class=p>:</span> <span class=mi>1</span><span class=p>}</span>

<span class=c1># 从文件加载环境</span>
<span class=p>{</span><span class=s2>&quot;unpickleEnvFrom&quot;</span><span class=p>:</span> <span class=s2>&quot;test/b.olean&quot;</span><span class=p>}</span>

<span class=c1># 在加载的环境中验证定义</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;example : f = 42 := by rfl&quot;</span><span class=p>,</span> <span class=s2>&quot;env&quot;</span><span class=p>:</span> <span class=mi>2</span><span class=p>}</span>
</code></pre></div> <p>使用 <code>pickleTo</code> 和 <code>unpickleEnvFrom</code> 命令来保存和恢复环境状态，并在恢复的环境中继续工作。</p> <h3 id=pickle_5>Pickle 示例：保存和加载证明状态<a class=headerlink href=#pickle_5 title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=c1># 导入基础库并定义带 sorry 的函数</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span> <span class=p>:</span> <span class=s2>&quot;import Lean&quot;</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span> <span class=p>:</span> <span class=s2>&quot;def f : Nat := by sorry&quot;</span><span class=p>,</span> <span class=s2>&quot;env&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;sorries&quot;</span><span class=p>:</span> <span class=p>[{</span><span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>,</span> <span class=s2>&quot;goal&quot;</span><span class=p>:</span> <span class=s2>&quot;⊢ Nat&quot;</span><span class=p>}</span><span class=o>...</span><span class=p>]}</span>

<span class=c1># 保存初始状态</span>
<span class=p>{</span><span class=s2>&quot;pickleTo&quot;</span><span class=p>:</span> <span class=s2>&quot;test/c.olean&quot;</span><span class=p>,</span> <span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>}</span>

<span class=c1># 加载状态并继续证明</span>
<span class=p>{</span><span class=s2>&quot;unpickleProofStateFrom&quot;</span><span class=p>:</span> <span class=s2>&quot;test/c.olean&quot;</span><span class=p>,</span> <span class=s2>&quot;env&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;tactic&quot;</span><span class=p>:</span> <span class=s2>&quot;have t : Nat := 42&quot;</span><span class=p>,</span> <span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>2</span><span class=p>}</span>

<span class=c1># 保存中间状态</span>
<span class=p>{</span><span class=s2>&quot;pickleTo&quot;</span><span class=p>:</span> <span class=s2>&quot;test/d.olean&quot;</span><span class=p>,</span> <span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>3</span><span class=p>}</span>

<span class=c1># 加载中间状态并完成证明</span>
<span class=p>{</span><span class=s2>&quot;unpickleProofStateFrom&quot;</span><span class=p>:</span> <span class=s2>&quot;test/d.olean&quot;</span><span class=p>,</span> <span class=s2>&quot;env&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;tactic&quot;</span><span class=p>:</span> <span class=s2>&quot;exact t&quot;</span><span class=p>,</span> <span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>5</span><span class=p>}</span>
</code></pre></div> <p>在证明过程中使用 pickle 保存和加载证明状态，实现证明的断点续传。</p> <h3 id=pickle_6>Pickle 示例：加载并继续证明<a class=headerlink href=#pickle_6 title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=c1># 从文件加载证明状态</span>
<span class=p>{</span><span class=s2>&quot;unpickleProofStateFrom&quot;</span><span class=p>:</span> <span class=s2>&quot;test/d.olean&quot;</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;env&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>}</span>

<span class=c1># 使用 exact 完成证明</span>
<span class=p>{</span><span class=s2>&quot;tactic&quot;</span><span class=p>:</span> <span class=s2>&quot;exact t&quot;</span><span class=p>,</span> <span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;messages&quot;</span><span class=p>:</span> <span class=p>[{</span><span class=s2>&quot;data&quot;</span><span class=p>:</span> <span class=s2>&quot;f : Nat&quot;</span><span class=p>}</span><span class=o>...</span><span class=p>]}</span>
</code></pre></div> <p>从 <code>.olean</code> 文件加载证明状态，并继续完成证明过程。</p> <h3 id=pickle-open>Pickle 示例：使用 open 导入定义<a class=headerlink href=#pickle-open title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=c1># 在命名空间 X 中定义 Y</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;def X.Y : Nat := 37&quot;</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;env&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>}</span>

<span class=c1># 打开命名空间 X</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;open X&quot;</span><span class=p>,</span> <span class=s2>&quot;env&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;env&quot;</span><span class=p>:</span> <span class=mi>1</span><span class=p>}</span>

<span class=c1># 直接使用 Y（无需 X.Y）验证值</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;example : Y = 37 := rfl&quot;</span><span class=p>,</span> <span class=s2>&quot;env&quot;</span><span class=p>:</span> <span class=mi>1</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;env&quot;</span><span class=p>:</span> <span class=mi>2</span><span class=p>}</span>

<span class=c1># 保存环境状态</span>
<span class=p>{</span><span class=s2>&quot;pickleTo&quot;</span><span class=p>:</span> <span class=s2>&quot;test/e.olean&quot;</span><span class=p>,</span> <span class=s2>&quot;env&quot;</span><span class=p>:</span> <span class=mi>1</span><span class=p>}</span>
</code></pre></div> <p>使用命名空间（namespace）组织代码，以及通过 <code>open</code> 命令简化访问。</p> <h3 id=pickle_7>Pickle 示例：加载环境变量<a class=headerlink href=#pickle_7 title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=c1># 加载已保存的环境</span>
<span class=p>{</span><span class=s2>&quot;unpickleEnvFrom&quot;</span><span class=p>:</span> <span class=s2>&quot;test/e.olean&quot;</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;env&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>}</span>

<span class=c1># 在加载的环境中使用变量</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;example : Y = 37 := rfl&quot;</span><span class=p>,</span> <span class=s2>&quot;env&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;env&quot;</span><span class=p>:</span> <span class=mi>1</span><span class=p>}</span>
</code></pre></div> <p>从 <code>.olean</code> 文件加载预定义的环境并使用其中的变量。</p> <h3 id=unsafe>导入模块和使用 unsafe 示例<a class=headerlink href=#unsafe title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=c1># 导入 Lean 核心库并打开编译器命名空间</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;import Lean&quot;</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;open Lean.Compiler&quot;</span><span class=p>,</span> <span class=s2>&quot;env&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>}</span>

<span class=c1># 使用 unsafe 定义包含 sorry 的示例</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;unsafe example : ◾ := sorry&quot;</span><span class=p>,</span> <span class=s2>&quot;env&quot;</span><span class=p>:</span> <span class=mi>1</span><span class=p>}</span>

<span class=c1># 保存环境状态</span>
<span class=p>{</span><span class=s2>&quot;pickleTo&quot;</span><span class=p>:</span> <span class=s2>&quot;test/f.olean&quot;</span><span class=p>,</span> <span class=s2>&quot;env&quot;</span><span class=p>:</span> <span class=mi>1</span><span class=p>}</span>
</code></pre></div> <p>导入模块、使用 unsafe 关键字，以及将环境状态保存到文件。输出中包含了一些编译器的追踪信息（使用 <code>traces</code> 字段）和重写规则的应用过程。</p> <h3 id=pickle-unsafe>Pickle 示例：加载环境并定义 unsafe 示例<a class=headerlink href=#pickle-unsafe title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=c1># 从文件加载环境</span>
<span class=p>{</span><span class=s2>&quot;unpickleEnvFrom&quot;</span><span class=p>:</span> <span class=s2>&quot;test/f.olean&quot;</span><span class=p>}</span>

<span class=c1># 在加载的环境中定义不安全示例</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;unsafe example : ◾ := sorry&quot;</span><span class=p>,</span> <span class=s2>&quot;env&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;sorries&quot;</span><span class=p>:</span> <span class=p>[{</span><span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>,</span> <span class=s2>&quot;goal&quot;</span><span class=p>:</span> <span class=s2>&quot;⊢ Nat&quot;</span><span class=p>}</span><span class=o>...</span><span class=p>]}</span>
</code></pre></div> <p>从持久化文件加载环境，并在该环境中定义一个带有 <code>unsafe</code> 标记的示例。</p> <h2 id=mathlib_1>Mathlib 示例<a class=headerlink href=#mathlib_1 title="Permanent link">&para;</a></h2> <p>以下示例涉及 Mathlib 依赖。</p> <h3 id=pickle_8>数学定理示例：代数运算与 pickle<a class=headerlink href=#pickle_8 title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=c1># 导入必要的库</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;import Mathlib</span><span class=se>\n</span><span class=s2>open BigOperators</span><span class=se>\n</span><span class=s2>open Real</span><span class=se>\n</span><span class=s2>open Nat&quot;</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;env&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>}</span>

<span class=c1># 定义数学定理</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;theorem mathd_algebra_455</span><span class=se>\n</span><span class=s2>  (x : Nat)</span><span class=se>\n</span><span class=s2>  (h : 2 * (2 * (2 * (2 * x))) = 48) :</span><span class=se>\n</span><span class=s2>  x = 3 := by sorry&quot;</span><span class=p>,</span> <span class=s2>&quot;env&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;sorries&quot;</span><span class=p>:</span> <span class=p>[{</span><span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>,</span> <span class=s2>&quot;goal&quot;</span><span class=p>:</span> <span class=s2>&quot;...&quot;</span><span class=p>}</span><span class=o>...</span><span class=p>]}</span>

<span class=c1># 保存证明状态</span>
<span class=p>{</span><span class=s2>&quot;pickleTo&quot;</span><span class=p>:</span> <span class=s2>&quot;test/pickle.olean&quot;</span><span class=p>,</span> <span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>}</span>
</code></pre></div> <p>设置一个包含数学运算的定理，并使用 pickle 保存证明状态，以便后续继续完成证明。</p> <h3 id=pickle_9>Pickle 示例：加载已保存的证明状态<a class=headerlink href=#pickle_9 title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=c1># 从文件加载证明状态</span>
<span class=p>{</span><span class=s2>&quot;unpickleProofStateFrom&quot;</span><span class=p>:</span> <span class=s2>&quot;test/pickle.olean&quot;</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;sorries&quot;</span><span class=p>:</span> <span class=p>[{</span><span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>,</span> <span class=s2>&quot;goal&quot;</span><span class=p>:</span> <span class=s2>&quot;x : Nat</span><span class=se>\n</span><span class=s2>⊢ x + 1 &gt; x&quot;</span><span class=p>}</span><span class=o>...</span><span class=p>]}</span>

<span class=c1># 应用数值规范化策略</span>
<span class=p>{</span><span class=s2>&quot;tactic&quot;</span><span class=p>:</span> <span class=s2>&quot;norm_num at h&quot;</span><span class=p>,</span> <span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>1</span><span class=p>,</span> <span class=s2>&quot;goals&quot;</span><span class=p>:</span> <span class=p>[</span>
  <span class=s2>&quot;case zero</span><span class=se>\n</span><span class=s2>⊢ 0 + 1 &gt; 0&quot;</span><span class=p>,</span>
  <span class=s2>&quot;case succ</span><span class=se>\n</span><span class=s2>x : Nat</span><span class=se>\n</span><span class=s2>hx : x + 1 &gt; x</span><span class=se>\n</span><span class=s2>⊢ x + 1 + 1 &gt; x + 1&quot;</span><span class=p>]}</span>
</code></pre></div> <p>从已保存的证明状态文件中恢复，并继续使用 <code>norm_num</code> 策略进行数值规范化。</p> <h3 id=_26>复杂示例：实数分析中的指数函数估计<a class=headerlink href=#_26 title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=c1># 导入数学库并设置幂运算符号</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;import Mathlib</span><span class=se>\n</span><span class=s2>open Real</span><span class=se>\n</span><span class=s2>local macro_rules | `($x ^ $y) =&gt; `(HPow.hPow $x $y)&quot;</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;env&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>}</span>

<span class=c1># 证明指数函数的近似估计定理</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;example </span><span class=si>{n}</span><span class=s2> {x a b : ℝ} (m : ℕ) (e₁ : n + 1 = m) (rm : ℝ) (er : ↑m = rm) </span>
        <span class=p>(</span><span class=n>h</span> <span class=p>:</span> <span class=o>|</span><span class=n>x</span><span class=o>|</span> <span class=err>≤</span> <span class=mi>1</span><span class=p>)</span> <span class=p>(</span><span class=n>e</span> <span class=p>:</span> <span class=o>|</span><span class=mi>1</span> <span class=o>-</span> <span class=n>a</span><span class=o>|</span> <span class=err>≤</span> <span class=n>b</span> <span class=o>-</span> <span class=o>|</span><span class=n>x</span><span class=o>|</span> <span class=o>/</span> <span class=n>rm</span> <span class=o>*</span> <span class=p>((</span><span class=n>rm</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>/</span> <span class=n>rm</span><span class=p>))</span> <span class=p>:</span> 
        <span class=o>|</span><span class=n>exp</span> <span class=n>x</span> <span class=o>-</span> <span class=n>expNear</span> <span class=n>n</span> <span class=n>x</span> <span class=n>a</span><span class=o>|</span> <span class=err>≤</span> <span class=o>|</span><span class=n>x</span><span class=o>|</span> <span class=o>^</span> <span class=n>n</span> <span class=o>/</span> <span class=n>n</span><span class=o>.</span><span class=n>factorial</span> <span class=o>*</span> <span class=n>b</span> <span class=o>:=</span> 
        <span class=n>by</span> <span class=n>apply</span> <span class=n>Real</span><span class=o>.</span><span class=n>exp_approx_end</span><span class=s1>&#39; m e₁ rm er h e&quot;, </span>
 <span class=s2>&quot;env&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>}</span>
</code></pre></div> <p>一个关于指数函数近似估计的复杂定理，使用 <code>Real.exp_approx_end'</code> 完成证明。</p> <h3 id=_27>策略示例：数学归纳法<a class=headerlink href=#_27 title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=c1># 导入必要的策略库</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;import Mathlib.Tactic.Cases&quot;</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;env&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>}</span>

<span class=c1># 使用归纳法证明自然数性质</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;example {x : Nat} : x + 1 &gt; x := by</span><span class=se>\n</span><span class=s2>  induction&#39; x with x hx&quot;</span><span class=p>,</span> <span class=s2>&quot;env&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;sorries&quot;</span><span class=p>:</span> <span class=p>[{</span><span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>,</span> 
  <span class=s2>&quot;goal&quot;</span><span class=p>:</span> <span class=s2>&quot;x : ℕ</span><span class=se>\n</span><span class=s2>h : 2 * (2 * (2 * (2 * x))) = 48</span><span class=se>\n</span><span class=s2>⊢ x = 3&quot;</span><span class=p>}</span><span class=o>...</span><span class=p>]}</span>
</code></pre></div> <p>使用 <code>induction'</code> 策略对自然数进行归纳证明。</p> <h3 id=_28>数论定理示例：使用内置策略<a class=headerlink href=#_28 title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=c1># 导入必要的库</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;import Mathlib.Algebra.BigOperators.Group.Finset</span><span class=se>\n</span><span class=s2>...&quot;</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;env&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>}</span>

<span class=c1># GCD 计算示例</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;theorem mathd_numbertheory_188 : Nat.gcd 180 168 = 12 := by norm_num&quot;</span><span class=p>}</span>

<span class=c1># 计算真因子之和</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;theorem mathd_numbertheory_403 : ∑ k in (Nat.properDivisors 198), k = 270 := by simp...&quot;</span><span class=p>}</span>

<span class=c1># 数列求和取模</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;theorem mathd_numbertheory_109 : (∑ k in Finset.Icc 1 100, v k) % 7 = 4 := by simp_rw...&quot;</span><span class=p>}</span>
</code></pre></div> <p>使用 Lean 的内置策略（<code>norm_num</code>, <code>simp</code>）来证明数论相关的定理，包括 GCD 计算、因子求和和模运算。</p> <h3 id=_29>示例：归纳法框架<a class=headerlink href=#_29 title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=c1># 导入策略库</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;import Mathlib.Tactic.Cases&quot;</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;env&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>}</span>

<span class=c1># 使用归纳法证明自然数性质</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;example {x : Nat} : x + 1 &gt; x := by</span><span class=se>\n</span><span class=s2>  induction&#39; x with x hx</span><span class=se>\n</span><span class=s2>  all_goals sorry&quot;</span><span class=p>,</span> <span class=s2>&quot;env&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;env&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>}</span>
</code></pre></div> <p>使用 <code>induction'</code> 策略设置归纳证明的基本框架。虽然这里用 <code>sorry</code> 跳过了具体证明步骤，但展示了归纳证明的基本结构。</p> <h3 id=simpa>策略示例：使用 simpa 策略<a class=headerlink href=#simpa title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=c1># 创建 False 的示例证明</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;example : False := by sorry&quot;</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;sorries&quot;</span><span class=p>:</span> <span class=p>[{</span><span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>,</span> <span class=s2>&quot;goal&quot;</span><span class=p>:</span> <span class=s2>&quot;⊢ False&quot;</span><span class=p>}</span><span class=o>...</span><span class=p>]}</span>

<span class=c1># 使用 simpa 策略</span>
<span class=p>{</span><span class=s2>&quot;tactic&quot;</span><span class=p>:</span> <span class=s2>&quot;simpa using show False by done&quot;</span><span class=p>,</span> <span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;sorries&quot;</span><span class=p>:</span> <span class=p>[</span><span class=o>...</span><span class=p>],</span> <span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>3</span><span class=p>,</span> <span class=s2>&quot;goals&quot;</span><span class=p>:</span> <span class=p>[</span>
  <span class=s2>&quot;case pos</span><span class=se>\n</span><span class=s2>x : ℝ</span><span class=se>\n</span><span class=s2>h0 : |x| &gt; 1...&quot;</span><span class=p>,</span>
  <span class=s2>&quot;case neg</span><span class=se>\n</span><span class=s2>x : ℝ</span><span class=se>\n</span><span class=s2>h0 : |x| &gt; 1...&quot;</span><span class=p>]}</span>
</code></pre></div> <p>使用 <code>simpa</code> 策略简化证明目标，并通过 <code>show</code> 指定中间结果。</p> <h3 id=_30>策略示例：使用归纳法证明<a class=headerlink href=#_30 title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=c1># 导入 Mathlib 并定义定理</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;import Mathlib&quot;</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;env&quot;</span> <span class=p>:</span> <span class=mi>0</span><span class=p>,</span> <span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;theorem foo (x : Nat) : x = x := by sorry&quot;</span><span class=p>}</span>

<span class=c1># 方式一：使用 induction 后逐步处理</span>
<span class=p>{</span><span class=s2>&quot;proofState&quot;</span> <span class=p>:</span> <span class=mi>0</span><span class=p>,</span> <span class=s2>&quot;tactic&quot;</span><span class=p>:</span> <span class=s2>&quot;induction x&quot;</span><span class=p>}</span>        <span class=c1># 归纳</span>
<span class=p>{</span><span class=s2>&quot;proofState&quot;</span> <span class=p>:</span> <span class=mi>1</span><span class=p>,</span> <span class=s2>&quot;tactic&quot;</span><span class=p>:</span> <span class=s2>&quot;next =&gt; rfl&quot;</span><span class=p>}</span>        <span class=c1># 处理下一个分支</span>

<span class=c1># 方式二：使用 induction with 模式匹配语法</span>
<span class=p>{</span><span class=s2>&quot;proofState&quot;</span> <span class=p>:</span> <span class=mi>0</span><span class=p>,</span> <span class=s2>&quot;tactic&quot;</span><span class=p>:</span> <span class=s2>&quot;induction x with</span><span class=se>\n</span><span class=s2>| zero =&gt; sorry</span><span class=se>\n</span><span class=s2>| succ x =&gt; sorry&quot;</span><span class=p>}</span>
</code></pre></div> <p>两种使用归纳法的方式：逐步处理和模式匹配语法。两种方式都会生成基础情况和归纳步骤的证明目标。</p> <h3 id=_31>数学示例：实数绝对值的讨论<a class=headerlink href=#_31 title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=c1># 导入数学库并打开实数命名空间</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;import Mathlib</span><span class=se>\n</span><span class=s2>open Real&quot;</span><span class=p>}</span>

<span class=c1># 定义关于实数绝对值的命题</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;example {x : ℝ} (h0: |x| &gt; 1) : (x &lt; 0) ∨ (2 * x &gt; 2) := by sorry&quot;</span><span class=p>,</span> <span class=s2>&quot;env&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;sorries&quot;</span><span class=p>:</span> <span class=p>[{</span><span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>,</span> <span class=s2>&quot;goal&quot;</span><span class=p>:</span> <span class=s2>&quot;⊢ False&quot;</span><span class=p>}</span><span class=o>...</span><span class=p>]}</span>

<span class=c1># 尝试使用多个辅助引理和分类讨论</span>
<span class=p>{</span><span class=s2>&quot;tactic&quot;</span><span class=p>:</span> <span class=s2>&quot;on_goal 1 =&gt;</span><span class=se>\n</span><span class=s2>  have h1 : x = x := by sorry</span><span class=se>\n</span><span class=s2>  have h2 : x = x := by sorry</span><span class=se>\n</span><span class=s2>  by_cases h3 : x &lt; 0&quot;</span><span class=p>,</span> <span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>1</span><span class=p>,</span> <span class=s2>&quot;messages&quot;</span><span class=p>:</span> <span class=p>[{</span><span class=s2>&quot;data&quot;</span><span class=p>:</span> <span class=s2>&quot;unsolved goals</span><span class=se>\n</span><span class=s2>⊢ False&quot;</span><span class=p>}</span><span class=o>...</span><span class=p>]}</span>
</code></pre></div> <p>处理涉及实数绝对值的命题，使用 <code>have</code> 引入辅助引理和 <code>by_cases</code> 进行分类讨论（虽然这个尝试未能完成证明）。</p> <h3 id=_32>策略示例：使用归纳法证明<a class=headerlink href=#_32 title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=c1># 导入策略库</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;import Mathlib.Tactic.Cases&quot;</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;env&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>}</span>

<span class=c1># 创建关于自然数的示例定理</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;example {x : Nat} : x + 1 &gt; x := by sorry&quot;</span><span class=p>,</span> <span class=s2>&quot;env&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>}</span>

<span class=c1># 应用归纳法策略，生成两个子目标</span>
<span class=p>{</span><span class=s2>&quot;tactic&quot;</span><span class=p>:</span> <span class=s2>&quot;induction&#39; x with x hx&quot;</span><span class=p>,</span> <span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;messages&quot;</span><span class=p>:</span> <span class=p>[{</span><span class=s2>&quot;data&quot;</span><span class=p>:</span> <span class=s2>&quot;unsolved goals</span><span class=se>\n</span>
  <span class=k>case</span> <span class=n>zero</span>\<span class=n>n</span><span class=err>⊢</span> <span class=mi>0</span> <span class=o>+</span> <span class=mi>1</span> <span class=o>&gt;</span> <span class=mi>0</span>\<span class=n>n</span>
  <span class=k>case</span> <span class=n>succ</span>\<span class=n>nx</span> <span class=p>:</span> <span class=n>Nat</span>\<span class=n>nhx</span> <span class=p>:</span> <span class=n>x</span> <span class=o>+</span> <span class=mi>1</span> <span class=o>&gt;</span> <span class=n>x</span>\<span class=n>n</span><span class=err>⊢</span> <span class=n>x</span> <span class=o>+</span> <span class=mi>1</span> <span class=o>+</span> <span class=mi>1</span> <span class=o>&gt;</span> <span class=n>x</span> <span class=o>+</span> <span class=mi>1</span><span class=s2>&quot;}...]}</span>
</code></pre></div> <p>使用 <code>induction'</code> 策略对自然数进行归纳证明，生成基础情况和归纳步骤两个子目标。</p> <h3 id=_33>导入示例：保存数学库依赖环境<a class=headerlink href=#_33 title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=c1># 导入数学库相关模块</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;import Mathlib</span><span class=se>\n</span><span class=s2>open BigOperators</span><span class=se>\n</span><span class=s2>open Real</span><span class=se>\n</span><span class=s2>open Nat&quot;</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;env&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>}</span>

<span class=c1># 保存环境到文件</span>
<span class=p>{</span><span class=s2>&quot;pickleTo&quot;</span><span class=p>:</span> <span class=s2>&quot;test/H20231215.olean&quot;</span><span class=p>,</span> <span class=s2>&quot;env&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>}</span>
</code></pre></div> <p>导入 Mathlib 相关模块并将环境持久化保存，这对于需要频繁使用数学库的证明很有帮助。</p> <h3 id=_34>数学证明示例：计算复合函数<a class=headerlink href=#_34 title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=c1># 导入必要的库</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;import Mathlib</span><span class=se>\n</span><span class=s2>open Real</span><span class=se>\n</span><span class=s2>open Nat</span><span class=se>\n</span><span class=s2>open BigOperators&quot;</span><span class=p>}</span>

<span class=c1># 定义定理：关于复合函数 p(q(2)) 的计算</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span> <span class=p>:</span> <span class=s2>&quot;theorem mathd_algebra_35</span>
  <span class=p>(</span><span class=n>p</span> <span class=n>q</span> <span class=p>:</span> <span class=n>ℝ</span> <span class=err>→</span> <span class=n>ℝ</span><span class=p>)</span>
  <span class=p>(</span><span class=n>h</span><span class=err>₀</span> <span class=p>:</span> <span class=err>∀</span> <span class=n>x</span><span class=p>,</span> <span class=n>p</span> <span class=n>x</span> <span class=o>=</span> <span class=mi>2</span> <span class=o>-</span> <span class=n>x</span><span class=o>^</span><span class=mi>2</span><span class=p>)</span>
  <span class=p>(</span><span class=n>h</span><span class=err>₁</span> <span class=p>:</span> <span class=err>∀</span> <span class=n>x</span><span class=p>,</span> <span class=n>x</span> <span class=err>≠</span> <span class=mi>0</span> <span class=o>-&gt;</span> <span class=n>q</span> <span class=n>x</span> <span class=o>=</span> <span class=mi>6</span> <span class=o>/</span> <span class=n>x</span><span class=p>)</span> <span class=p>:</span>
  <span class=n>p</span> <span class=p>(</span><span class=n>q</span> <span class=mi>2</span><span class=p>)</span> <span class=o>=</span> <span class=o>-</span><span class=mi>7</span> <span class=o>:=</span> <span class=n>by</span> <span class=n>sorry</span><span class=s2>&quot;, &quot;</span><span class=n>env</span><span class=s2>&quot;: 0}</span>

<span class=c1># 尝试证明步骤（未完成）</span>
<span class=p>{</span><span class=s2>&quot;tactic&quot;</span><span class=p>:</span> <span class=s2>&quot;have hQ : ∀ x, p x = 6 / x&quot;</span><span class=p>,</span> <span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;tactic&quot;</span><span class=p>:</span> <span class=s2>&quot;  intro x&quot;</span><span class=p>,</span> <span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>1</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;tactic&quot;</span><span class=p>:</span> <span class=s2>&quot;  calc p x = 6 / x * p x := h₀ (x)...&quot;</span><span class=p>,</span> <span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>2</span><span class=p>}</span>
</code></pre></div> <p>一个数学证明的开始，涉及实数函数的复合计算，尽管证明尚未完成。</p> <h3 id=_35>示例：使用已保存的环境状态<a class=headerlink href=#_35 title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=c1># 加载保存的环境状态</span>
<span class=p>{</span><span class=s2>&quot;unpickleEnvFrom&quot;</span><span class=p>:</span> <span class=s2>&quot;test/H20231215.olean&quot;</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;env&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>}</span>

<span class=c1># 在加载的环境中定义新定理</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;theorem mathd_numbertheory_739 :</span><span class=se>\n</span><span class=s2>  9! % 10 = 0 := by sorry&quot;</span><span class=p>,</span> <span class=s2>&quot;env&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;env&quot;</span><span class=p>:</span> <span class=mi>1</span><span class=p>}</span>
</code></pre></div> <p>使用 pickle 功能加载预先保存的环境状态，并在其基础上定义新的定理。</p> <h3 id=exact>exact? 策略示例：自动推导<a class=headerlink href=#exact title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=c1># 导入 Mathlib</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;import Mathlib&quot;</span><span class=p>}</span>

<span class=c1># 测试简单定理：0 &lt; 1</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;theorem test : 0 &lt; 1 := by sorry&quot;</span><span class=p>,</span> <span class=s2>&quot;env&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;tactic&quot;</span><span class=p>:</span> <span class=s2>&quot;exact?&quot;</span><span class=p>,</span> <span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>}</span>  <span class=c1># exact? 自动找到证明</span>

<span class=c1># 测试不可能的定理：3 = 7</span>
<span class=p>{</span><span class=s2>&quot;cmd&quot;</span><span class=p>:</span> <span class=s2>&quot;theorem test : 3 = 7 := by sorry&quot;</span><span class=p>,</span> <span class=s2>&quot;env&quot;</span><span class=p>:</span> <span class=mi>0</span><span class=p>}</span>
<span class=p>{</span><span class=s2>&quot;tactic&quot;</span><span class=p>:</span> <span class=s2>&quot;exact?&quot;</span><span class=p>,</span> <span class=s2>&quot;proofState&quot;</span><span class=p>:</span> <span class=mi>2</span><span class=p>}</span>   <span class=c1># exact? 无法找到证明</span>
</code></pre></div> <p><code>exact?</code> 策略的自动推导能力：对于显然成立的命题能自动找到证明，对于明显错误的命题则无法完成证明。</p> </article> </div> <script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script> </div> </main> <footer class=md-footer> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-copyright> Made with <a href=https://squidfunk.github.io/mkdocs-material/ target=_blank rel=noopener> Material for MkDocs </a> </div> </div> </div> </footer> </div> <div class=md-dialog data-md-component=dialog> <div class="md-dialog__inner md-typeset"></div> </div> <script id=__config type=application/json>{"base": "../..", "features": ["navigation.tabs", "navigation.sections", "navigation.instant", "search.highlight", "search.share", "content.code.copy", "content.code.annotate"], "search": "../../assets/javascripts/workers/search.973d3a69.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": {"alias": true, "default": "latest", "provider": "mike"}}</script> <script src=../../assets/javascripts/bundle.f55a23d4.min.js></script> <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> </body> </html>